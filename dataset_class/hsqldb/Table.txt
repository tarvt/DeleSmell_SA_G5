Location: Table.java

Content: 

public void addColumnNoCheck(ColumnSchema column){

  columnList.add(column.getName().name,column);

  columnCount++;

}

Location: Table.java

Content: 

/** 

 * Performs the table level checks and adds a column to the table at the DDL level. Only used at table creation, not at alter column.

 */

public void addColumn(ColumnSchema column){

  String name=column.getName().name;

  if (findColumn(name) >= 0) {

    throw Error.error(ErrorCode.X_42504,name);

  }

  if (column.isIdentity()) {

    if (identityColumn != -1) {

      throw Error.error(ErrorCode.X_42525,name);

    }

    identityColumn=columnCount;

    identitySequence=column.getIdentitySequence();

  }

  addColumnNoCheck(column);

}

Location: Table.java

Content: 

boolean areColumnsNotNull(int[] indexes){

  return ArrayUtil.areAllIntIndexesInBooleanArray(indexes,colNotNull);

}

Location: Table.java

Content: 

/** 

 * Used for drop / retype column.

 */

void checkColumnInCheckConstraint(int colIndex){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.getConstraintType() == SchemaObject.ConstraintTypes.CHECK && !c.isNotNull() && c.hasColumn(colIndex)) {

      HsqlName name=c.getName();

      throw Error.error(ErrorCode.X_42502,name.getSchemaQualifiedStatementName());

    }

  }

}

Location: Table.java

Content: 

/** 

 * Used for retype column. Checks whether column is in an FK or is referenced by a FK

 * @param colIndex index

 */

void checkColumnInFKConstraint(int colIndex){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.hasColumn(colIndex) && (c.getConstraintType() == SchemaObject.ConstraintTypes.MAIN || c.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY)) {

      HsqlName name=c.getName();

      throw Error.error(ErrorCode.X_42533,name.getSchemaQualifiedStatementName());

    }

  }

}

Location: Table.java

Content: 

/** 

 * Used for column defaults and nullability. Checks whether column is in an FK with a given referential action type.

 * @param colIndex index of column

 * @param actionType referential action of the FK

 */

void checkColumnInFKConstraint(int colIndex,int actionType){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY && c.hasColumn(colIndex) && (actionType == c.getUpdateAction() || actionType == c.getDeleteAction())) {

      HsqlName name=c.getName();

      throw Error.error(ErrorCode.X_42533,name.getSchemaQualifiedStatementName());

    }

  }

}

Location: Table.java

Content: 

/** 

 * Match two valid, equal length, columns arrays for type of columns for referential constraints

 * @param col column array from this Table

 * @param other the other Table object

 * @param othercol column array from the other Table

 */

void checkReferentialColumnsMatch(int[] col,Table other,int[] othercol){

  for (int i=0; i < col.length; i++) {

    Type type=colTypes[col[i]];

    Type otherType=other.colTypes[othercol[i]];

    if (!type.canCompareDirect(otherType)) {

      throw Error.error(ErrorCode.X_42562);

    }

  }

}

Location: Table.java

Content: 

/** 

 * columnMap is null for deletes 

 */

void collectFKReadLocks(int[] columnMap,OrderedHashSet set){

  for (int i=0; i < fkMainConstraints.length; i++) {

    Constraint constraint=fkMainConstraints[i];

    Table ref=constraint.getRef();

    int[] mainColumns=constraint.getMainColumns();

    if (ref == this) {

      continue;

    }

    if (columnMap == null) {

      if (constraint.core.hasDeleteAction) {

        int[] cols=constraint.getDeleteAction() == SchemaObject.ReferentialAction.CASCADE ? null : constraint.getRefColumns();

        if (set.add(ref.getName())) {

          ref.collectFKReadLocks(cols,set);

        }

      }

    }

 else     if (ArrayUtil.haveCommonElement(columnMap,mainColumns)) {

      if (set.add(ref.getName())) {

        ref.collectFKReadLocks(constraint.getRefColumns(),set);

      }

    }

  }

}

Location: Table.java

Content: 

/** 

 * columnMap is null for deletes 

 */

void collectFKWriteLocks(int[] columnMap,OrderedHashSet set){

  for (int i=0; i < fkMainConstraints.length; i++) {

    Constraint constraint=fkMainConstraints[i];

    Table ref=constraint.getRef();

    int[] mainColumns=constraint.getMainColumns();

    if (ref == this) {

      continue;

    }

    if (columnMap == null) {

      if (constraint.core.hasDeleteAction) {

        int[] cols=constraint.getDeleteAction() == SchemaObject.ReferentialAction.CASCADE ? null : constraint.getRefColumns();

        if (set.add(ref.getName())) {

          ref.collectFKWriteLocks(cols,set);

        }

      }

    }

 else     if (ArrayUtil.haveCommonElement(columnMap,mainColumns)) {

      if (constraint.core.hasUpdateAction) {

        if (set.add(ref.getName())) {

          ref.collectFKWriteLocks(constraint.getRefColumns(),set);

        }

      }

    }

  }

}

Location: Table.java

Content: 

/** 

 * compares two full table rows based on a set of columns

 * @param a a full row

 * @param b a full row

 * @param cols array of column indexes to compare

 * @param coltypes array of column types for the full row

 * @return comparison result, -1,0,+1

 */

public static int compareRows(Session session,Object[] a,Object[] b,int[] cols,Type[] coltypes){

  int fieldcount=cols.length;

  for (int j=0; j < fieldcount; j++) {

    int i=coltypes[cols[j]].compare(session,a[cols[j]],b[cols[j]]);

    if (i != 0) {

      return i;

    }

  }

  return 0;

}

Location: Table.java

Content: 

/** 

 * Used to create an index automatically for system and temp tables. Used for internal operation tables with null Session param.

 */

Index createIndexForColumns(Session session,int[] columns){

  Index index=null;

  HsqlName indexName=database.nameManager.newAutoName("IDX_T",getSchemaName(),getName(),SchemaObject.INDEX);

  try {

    index=createAndAddIndexStructure(session,indexName,columns,null,null,false,false,false);

  }

 catch (  Throwable t) {

    return null;

  }

  return index;

}

Location: Table.java

Content: 

/** 

 * Shortcut for creating default PK's.

 */

public void createPrimaryKey(){

  createPrimaryKey(null,ValuePool.emptyIntArray,false);

}

Location: Table.java

Content: 

public void createPrimaryKeyConstraint(HsqlName indexName,int[] columns,boolean columnsNotNull){

  createPrimaryKey(indexName,columns,columnsNotNull);

  Constraint c=new Constraint(indexName,this,getPrimaryIndex(),SchemaObject.ConstraintTypes.PRIMARY_KEY);

  addConstraint(c);

}

Location: Table.java

Content: 

/** 

 * Creates a single or multi-column primary key and index. sets the colTypes array. Finalises the creation of the table. (fredt@users)

 */

public void createPrimaryKey(HsqlName indexName,int[] columns,boolean columnsNotNull){

  if (columns == null) {

    columns=ValuePool.emptyIntArray;

  }

  for (int i=0; i < columns.length; i++) {

    getColumn(columns[i]).setPrimaryKey(true);

  }

  setColumnStructures();

  Type[] primaryKeyTypes=new Type[columns.length];

  ArrayUtil.projectRow(colTypes,columns,primaryKeyTypes);

  HsqlName name=indexName;

  if (name == null) {

    name=database.nameManager.newAutoName("IDX",getSchemaName(),getName(),SchemaObject.INDEX);

  }

  createPrimaryIndex(columns,primaryKeyTypes,name);

  setBestRowIdentifiers();

}

Location: Table.java

Content: 

/** 

 * Enforce max field sizes according to SQL column definition. SQL92 13.8

 */

public void enforceRowConstraints(Session session,Object[] data){

  for (int i=0; i < columnCount; i++) {

    Type type=colTypes[i];

    ColumnSchema column;

    if (hasDomainColumns && type.isDomainType()) {

      Constraint[] constraints=type.userTypeModifier.getConstraints();

      column=getColumn(i);

      for (int j=0; j < constraints.length; j++) {

        constraints[j].checkCheckConstraint(session,this,column,data[i]);

      }

    }

    if (colNotNull[i] && data[i] == null) {

      String constraintName;

      Constraint c=getNotNullConstraintForColumn(i);

      if (c == null) {

        if (ArrayUtil.find(getPrimaryKey(),i) > -1) {

          c=getPrimaryConstraint();

        }

      }

      constraintName=c == null ? "" : c.getName().name;

      column=getColumn(i);

      String[] info=new String[]{constraintName,tableName.statementName,column.getName().statementName};

      throw Error.error(null,ErrorCode.X_23502,ErrorCode.COLUMN_CONSTRAINT,info);

    }

  }

}

Location: Table.java

Content: 

public void enforceTypeLimits(Session session,Object[] data){

  int i=0;

  try {

    for (; i < columnCount; i++) {

      data[i]=colTypes[i].convertToTypeLimits(session,data[i]);

    }

  }

 catch (  HsqlException e) {

    int code=e.getErrorCode();

    if (code == -ErrorCode.X_22001 || code == -ErrorCode.X_22003 || code == -ErrorCode.X_22008) {

      ColumnSchema column=getColumn(i);

      String[] info=new String[]{"",tableName.statementName,column.getName().statementName};

      throw Error.error(e,code,ErrorCode.COLUMN_CONSTRAINT,info);

    }

    throw e;

  }

}

Location: Table.java

Content: 

int[] findColumnIndexes(String[] list){

  int[] cols=new int[list.length];

  for (int i=0; i < cols.length; i++) {

    cols[i]=findColumn(list[i]);

  }

  return cols;

}

Location: Table.java

Content: 

IndexUse[] findIndexForColumns(Session session,OrderedIntHashSet set,int opType,boolean ordered){

  IndexUse[] indexUse=Index.emptyUseArray;

  if (set.isEmpty()) {

    return Index.emptyUseArray;

  }

  for (int i=0, count=indexList.length; i < count; i++) {

    Index currentIndex=getIndex(i);

    int[] indexcols=currentIndex.getColumns();

    int matchCount=ordered ? set.getOrderedStartMatchCount(indexcols) : set.getStartMatchCount(indexcols);

    if (matchCount == 0) {

      continue;

    }

    if (matchCount == set.size()) {

      return currentIndex.asArray();

    }

    if (matchCount == currentIndex.getColumnCount()) {

      if (currentIndex.isUnique()) {

        return currentIndex.asArray();

      }

    }

    if (indexUse.length == 0 && matchCount == currentIndex.getColumnCount()) {

      indexUse=currentIndex.asArray();

    }

 else {

      IndexUse[] newList=new IndexUse[indexUse.length + 1];

      ArrayUtil.copyArray(indexUse,newList,indexUse.length);

      newList[newList.length - 1]=new IndexUse(currentIndex,matchCount);

      indexUse=newList;

    }

  }

  return indexUse;

}

Location: Table.java

Content: 

/** 

 * Fires all row-level triggers of the given set (trigger type)

 */

void fireTriggers(Session session,int trigVecIndex,Object[] oldData,Object[] newData,int[] cols){

  if (!database.isReferentialIntegrity()) {

    return;

  }

  TriggerDef[] trigVec=triggerLists[trigVecIndex];

  for (int i=0, size=trigVec.length; i < size; i++) {

    TriggerDef td=trigVec[i];

    boolean sqlTrigger=td instanceof TriggerDefSQL;

    if (cols != null && td.getUpdateColumnIndexes() != null && !ArrayUtil.haveCommonElement(td.getUpdateColumnIndexes(),cols)) {

      continue;

    }

    if (td.isForEachRow()) {

switch (td.triggerType) {

case Trigger.INSERT_BEFORE_ROW:

        break;

case Trigger.INSERT_AFTER_ROW:

      if (!sqlTrigger) {

        newData=(Object[])ArrayUtil.duplicateArray(newData);

      }

    break;

case Trigger.UPDATE_AFTER_ROW:

  if (!sqlTrigger) {

    oldData=(Object[])ArrayUtil.duplicateArray(oldData);

    newData=(Object[])ArrayUtil.duplicateArray(newData);

  }

break;

case Trigger.UPDATE_BEFORE_ROW:

case Trigger.DELETE_BEFORE_ROW:

case Trigger.DELETE_AFTER_ROW:

if (!sqlTrigger) {

oldData=(Object[])ArrayUtil.duplicateArray(oldData);

}

break;

}

td.pushPair(session,oldData,newData);

}

 else {

td.pushPair(session,null,null);

}

}

}

Location: Table.java

Content: 

void fireTriggers(Session session,int trigVecIndex,RowSetNavigator rowSet){

  if (!database.isReferentialIntegrity()) {

    return;

  }

  TriggerDef[] trigVec=triggerLists[trigVecIndex];

  for (int i=0, size=trigVec.length; i < size; i++) {

    TriggerDef td=trigVec[i];

    boolean sqlTrigger=td instanceof TriggerDefSQL;

    if (td.hasOldTable()) {

    }

    td.pushPair(session,null,null);

  }

}

Location: Table.java

Content: 

void fireTriggers(Session session,int trigVecIndex,RowSetNavigatorDataChange rowSet){

  if (!database.isReferentialIntegrity()) {

    return;

  }

  TriggerDef[] trigVec=triggerLists[trigVecIndex];

  for (int i=0, size=trigVec.length; i < size; i++) {

    TriggerDef td=trigVec[i];

    boolean sqlTrigger=td instanceof TriggerDefSQL;

    if (td.hasOldTable()) {

    }

    td.pushPair(session,null,null);

  }

}

Location: Table.java

Content: 

void generateAndCheckData(Session session,Object[] data){

  if (hasGeneratedValues) {

    setGeneratedColumns(session,data);

  }

  enforceTypeLimits(session,data);

  if (hasDomainColumns || hasNotNullColumns) {

    enforceRowConstraints(session,data);

  }

}

Location: Table.java

Content: 

public int[] getBestRowIdentifiers(){

  return bestRowIdentifierCols;

}

Location: Table.java

Content: 

public Index getClusteredIndex(){

  for (int i=0; i < indexList.length; i++) {

    if (indexList[i].isClustered()) {

      return indexList[i];

    }

  }

  return null;

}

Location: Table.java

Content: 

boolean[] getColumnCheckList(int[] columnIndexes){

  boolean[] columnCheckList=new boolean[columnCount];

  for (int i=0; i < columnIndexes.length; i++) {

    int index=columnIndexes[i];

    if (index > -1) {

      columnCheckList[index]=true;

    }

  }

  return columnCheckList;

}

Location: Table.java

Content: 

int[] getColumnIndexes(HashMappedList list){

  int[] cols=new int[list.size()];

  for (int i=0; i < cols.length; i++) {

    cols[i]=((Integer)list.get(i)).intValue();

  }

  return cols;

}

Location: Table.java

Content: 

int[] getColumnIndexes(OrderedHashSet set){

  int[] cols=new int[set.size()];

  for (int i=0; i < cols.length; i++) {

    cols[i]=getColumnIndex((String)set.get(i));

    if (cols[i] == -1) {

      throw Error.error(ErrorCode.X_42501,(String)set.get(i));

    }

  }

  return cols;

}

Location: Table.java

Content: 

/** 

 * Returns the index of given column name or throws if not found

 */

public int getColumnIndex(String name){

  int i=findColumn(name);

  if (i == -1) {

    throw Error.error(ErrorCode.X_42501,name);

  }

  return i;

}

Location: Table.java

Content: 

public String getColumnListSQL(int[] col,int len){

  StringBuffer sb=new StringBuffer();

  sb.append('(');

  for (int i=0; i < len; i++) {

    sb.append(getColumn(col[i]).getName().statementName);

    if (i < len - 1) {

      sb.append(',');

    }

  }

  sb.append(')');

  return sb.toString();

}

Location: Table.java

Content: 

public String getColumnListWithTypeSQL(){

  StringBuffer sb=new StringBuffer();

  sb.append('(');

  for (int j=0; j < columnCount; j++) {

    ColumnSchema column=getColumn(j);

    String colname=column.getName().statementName;

    Type type=column.getDataType();

    if (j > 0) {

      sb.append(',');

    }

    sb.append(colname);

    sb.append(' ');

    sb.append(type.getTypeDefinition());

  }

  sb.append(')');

  return sb.toString();

}

Location: Table.java

Content: 

/** 

 * Returns direct mapping array.

 */

int[] getColumnMap(){

  return defaultColumnMap;

}

Location: Table.java

Content: 

public OrderedHashSet getColumnNameSet(){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0; i < columnCount; i++) {

    set.add(((ColumnSchema)columnList.get(i)).getName());

  }

  return set;

}

Location: Table.java

Content: 

public OrderedHashSet getColumnNameSet(boolean[] columnCheckList){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0; i < columnCheckList.length; i++) {

    if (columnCheckList[i]) {

      set.add(columnList.get(i));

    }

  }

  return set;

}

Location: Table.java

Content: 

public OrderedHashSet getColumnNameSet(int[] columnIndexes){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0; i < columnIndexes.length; i++) {

    set.add(((ColumnSchema)columnList.get(i)).getName());

  }

  return set;

}

Location: Table.java

Content: 

public void getColumnNames(boolean[] columnCheckList,Set set){

  for (int i=0; i < columnCheckList.length; i++) {

    if (columnCheckList[i]) {

      set.add(((ColumnSchema)columnList.get(i)).getName());

    }

  }

}

Location: Table.java

Content: 

/** 

 * Return the position of the constraint within the list

 */

int getConstraintIndex(String constraintName){

  for (int i=0, size=constraintList.length; i < size; i++) {

    if (constraintList[i].getName().name.equals(constraintName)) {

      return i;

    }

  }

  return -1;

}

Location: Table.java

Content: 

/** 

 * Returns list of constraints dependent on more than one column

 */

OrderedHashSet getContainingConstraints(int colIndex){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.hasColumnPlus(colIndex)) {

      set.add(c);

    }

  }

  return set;

}

Location: Table.java

Content: 

OrderedHashSet getContainingIndexNames(int colIndex){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0, size=indexList.length; i < size; i++) {

    Index index=indexList[i];

    if (ArrayUtil.find(index.getColumns(),colIndex) != -1) {

      set.add(index.getName());

    }

  }

  return set;

}

Location: Table.java

Content: 

public RangeVariable[] getDefaultRanges(){

  if (defaultRanges == null) {

    defaultRanges=new RangeVariable[]{new RangeVariable(this,0)};

  }

  return defaultRanges;

}

Location: Table.java

Content: 

/** 

 * For log statements. Find a single row to delete.

 */

public Row getDeleteRowFromLog(Session session,Object[] data){

  Row row=null;

  PersistentStore store=getRowStore(session);

  if (hasPrimaryKey()) {

    Index index=getPrimaryIndex();

    int[] colsSequence=index.getDefaultColumnMap();

    RowIterator it=index.findFirstRow(session,store,data,colsSequence);

    it.next();

    row=it.getCurrentRow();

    it.release();

  }

 else   if (bestIndex == null) {

    RowIterator it=rowIterator(session);

    while (it.next()) {

      row=it.getCurrentRow();

      if (Table.compareRows(session,row.getData(),data,defaultColumnMap,colTypes) == 0) {

        break;

      }

    }

    it.release();

  }

 else {

    RowIterator it=bestIndex.findFirstRow(session,store,data);

    while (it.next()) {

      row=it.getCurrentRow();

      Object[] rowdata=row.getData();

      if (bestIndex.compareRowNonUnique(session,rowdata,data,bestIndex.getColumns()) != 0) {

        row=null;

        break;

      }

      if (Table.compareRows(session,rowdata,data,defaultColumnMap,colTypes) == 0) {

        break;

      }

    }

    it.release();

  }

  return row;

}

Location: Table.java

Content: 

/** 

 * Returns list of MAIN constraints dependent on this PK or UNIQUE constraint

 */

OrderedHashSet getDependentConstraints(Constraint constraint){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0, size=fkMainConstraints.length; i < size; i++) {

    Constraint c=fkMainConstraints[i];

    if (c.core.uniqueName == constraint.getName()) {

      set.add(c);

    }

  }

  return set;

}

Location: Table.java

Content: 

/** 

 * Returns list of constraints dependent only on one column

 */

OrderedHashSet getDependentConstraints(int colIndex){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.hasColumnOnly(colIndex)) {

      set.add(c);

    }

  }

  return set;

}

Location: Table.java

Content: 

public OrderedHashSet getDependentExternalConstraints(){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.getConstraintType() == SchemaObject.ConstraintTypes.MAIN || c.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY) {

      if (c.core.mainTable != c.core.refTable) {

        set.add(c);

      }

    }

  }

  return set;

}

Location: Table.java

Content: 

/** 

 * Returns any foreign key constraint equivalent to the column sets

 */

Constraint getFKConstraintForColumns(Table tableMain,int[] mainCols,int[] refCols){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.isEquivalent(tableMain,mainCols,this,refCols)) {

      return c;

    }

  }

  return null;

}

Location: Table.java

Content: 

/** 

 * Returns the list of FK constraints.

 */

public Constraint[] getFKConstraints(){

  return fkConstraints;

}

Location: Table.java

Content: 

/** 

 * Finds an existing index for an ordered full column group

 */

Index getFullIndexForColumns(int[] cols){

  for (int i=0; i < indexList.length; i++) {

    if (ArrayUtil.haveEqualArrays(indexList[i].getColumns(),cols,cols.length)) {

      return indexList[i];

    }

  }

  return null;

}

Location: Table.java

Content: 

/** 

 * Returns an index on all the columns

 */

public Index getFullIndex(Session session){

  if (fullIndex == null) {

    fullIndex=getFullIndexForColumns(defaultColumnMap);

    if (fullIndex == null) {

      fullIndex=createIndexForColumns(session,defaultColumnMap);

    }

  }

  return fullIndex;

}

Location: Table.java

Content: 

/** 

 * Returns the identity column index.

 */

int getIdentityColumnIndex(){

  return identityColumn;

}

Location: Table.java

Content: 

/** 

 * Finds an existing index for an unordered full column group

 */

Index getIndexForColumns(int[] cols){

  for (int i=0; i < indexList.length; i++) {

    if (ArrayUtil.haveEqualSets(indexList[i].getColumns(),cols,cols.length)) {

      return indexList[i];

    }

  }

  return null;

}

Location: Table.java

Content: 

/** 

 * Finds an existing index for a column group - for persistent tables

 */

Index getIndexForColumns(Session session,int[] cols){

  readLock.lock();

  try {

    int i=bestIndexForColumn[cols[0]];

    if (i > -1) {

      return indexList[i];

    }

    return null;

  }

  finally {

    readLock.unlock();

  }

}

Location: Table.java

Content: 

/** 

 * Finds an existing index for a column set or create one for temporary tables. synchronized required for shared INFORMATION_SCHEMA etc. tables

 */

IndexUse[] getIndexForColumns(Session session,OrderedIntHashSet set,int opType,boolean ordered){

  readLock.lock();

  try {

    if (set.isEmpty()) {

      return Index.emptyUseArray;

    }

    IndexUse[] indexUse=findIndexForColumns(session,set,opType,ordered);

    if (indexUse.length == 0) {

      Index selected=null;

switch (tableType) {

case TableBase.TEMP_TABLE:

case TableBase.INFO_SCHEMA_TABLE:

case TableBase.MODULE_TABLE:

case TableBase.FUNCTION_TABLE:

case TableBase.SYSTEM_SUBQUERY:

case TableBase.VIEW_TABLE:

{

          selected=createIndexForColumns(session,set.toArray());

          break;

        }

    }

    if (selected != null) {

      indexUse=selected.asArray();

    }

  }

  return indexUse;

}

  finally {

  readLock.unlock();

}

}

Location: Table.java

Content: 

/** 

 * Finds an existing index for a column

 */

Index getIndexForColumn(Session session,int col){

  readLock.lock();

  try {

    int i=bestIndexForColumn[col];

    if (i > -1) {

      return indexList[i];

    }

switch (tableType) {

case TableBase.TEMP_TABLE:

case TableBase.INFO_SCHEMA_TABLE:

case TableBase.MODULE_TABLE:

case TableBase.FUNCTION_TABLE:

case TableBase.SYSTEM_SUBQUERY:

case TableBase.VIEW_TABLE:

{

        Index index=createIndexForColumns(session,new int[]{col});

        return index;

      }

  }

  return null;

}

  finally {

  readLock.unlock();

}

}

Location: Table.java

Content: 

/** 

 * Returns the index of the Index object of the given name or -1 if not found.

 */

int getIndexIndex(String indexName){

  Index[] indexes=indexList;

  for (int i=0; i < indexes.length; i++) {

    if (indexName.equals(indexes[i].getName().name)) {

      return i;

    }

  }

  return -1;

}

Location: Table.java

Content: 

/** 

 * Return the list of file pointers to root nodes for this table's indexes.

 */

public final long[] getIndexRootsArray(){

  PersistentStore store=database.persistentStoreCollection.getStore(this);

  long[] roots=new long[indexList.length];

  for (int index=0; index < indexList.length; index++) {

    CachedObject accessor=store.getAccessor(indexList[index]);

    roots[index]=accessor == null ? -1 : accessor.getPos();

  }

  return roots;

}

Location: Table.java

Content: 

public String getIndexRootsSQL(long[] roots){

  StringBuffer sb=new StringBuffer(128);

  sb.append(Tokens.T_SET).append(' ').append(Tokens.T_TABLE).append(' ');

  sb.append(getName().getSchemaQualifiedStatementName());

  sb.append(' ').append(Tokens.T_INDEX).append(' ').append('\'');

  sb.append(StringUtil.getList(roots," ",""));

  sb.append(' ');

  sb.append(StringUtil.getList(new long[indexList.length]," ",""));

  sb.append(' ').append(store.elementCount());

  sb.append('\'');

  return sb.toString();

}

Location: Table.java

Content: 

/** 

 * Returns the Index object of the given name or null if not found.

 */

Index getIndex(String indexName){

  Index[] indexes=indexList;

  int i=getIndexIndex(indexName);

  return i == -1 ? null : indexes[i];

}

Location: Table.java

Content: 

/** 

 * Returns empty mapping array.

 */

int[] getNewColumnMap(){

  return new int[columnCount];

}

Location: Table.java

Content: 

/** 

 * Returns array for a new row with SQL DEFAULT value for each column n where exists[n] is false. This provides default values only where required and avoids evaluating these values where they will be overwritten.

 */

public Object[] getNewRowData(Session session){

  Object[] data=new Object[columnCount];

  int i;

  if (hasDefaultValues) {

    for (i=0; i < columnCount; i++) {

      Expression def=colDefaults[i];

      if (def != null) {

        data[i]=def.getValue(session,colTypes[i]);

      }

    }

  }

  return data;

}

Location: Table.java

Content: 

/** 

 * Returns the next constraint of a given type

 * @param from

 * @param type

 */

int getNextConstraintIndex(int from,int type){

  for (int i=from, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.getConstraintType() == type) {

      return i;

    }

  }

  return -1;

}

Location: Table.java

Content: 

Constraint getNotNullConstraintForColumn(int colIndex){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.isNotNull() && c.notNullColumnIndex == colIndex) {

      return c;

    }

  }

  return null;

}

Location: Table.java

Content: 

/** 

 * Returns the primary constraint.

 */

public Constraint getPrimaryConstraint(){

  return hasPrimaryKey() ? constraintList[0] : null;

}

Location: Table.java

Content: 

public OrderedHashSet getReferencesForDependents(){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0; i < colTypes.length; i++) {

    ColumnSchema column=getColumn(i);

    OrderedHashSet refs=column.getReferences();

    if (refs != null && !refs.isEmpty()) {

      set.add(column.getName());

    }

  }

  for (int i=0; i < fkConstraints.length; i++) {

    if (fkConstraints[i].getMainTableName() != getName()) {

      set.add(fkConstraints[i].getName());

    }

  }

  for (int i=0; i < triggerList.length; i++) {

    set.add(triggerList[i].getName());

  }

  return set;

}

Location: Table.java

Content: 

public String getSQLForClustered(){

  if (!isCached() && !isText()) {

    return null;

  }

  Index index=getClusteredIndex();

  if (index == null) {

    return null;

  }

  String colList=getColumnListSQL(index.getColumns(),index.getColumnCount());

  StringBuffer sb=new StringBuffer(64);

  sb.append(Tokens.T_SET).append(' ').append(Tokens.T_TABLE).append(' ');

  sb.append(getName().getSchemaQualifiedStatementName());

  sb.append(' ').append(Tokens.T_CLUSTERED).append(' ');

  sb.append(Tokens.T_ON).append(' ').append(colList);

  return sb.toString();

}

Location: Table.java

Content: 

public String getSQLForReadOnly(){

  if (isReadOnly) {

    StringBuffer sb=new StringBuffer(64);

    sb.append(Tokens.T_SET).append(' ').append(Tokens.T_TABLE).append(' ');

    sb.append(getName().getSchemaQualifiedStatementName());

    sb.append(' ').append(Tokens.T_READ).append(' ');

    sb.append(Tokens.T_ONLY);

    return sb.toString();

  }

 else {

    return null;

  }

}

Location: Table.java

Content: 

public String getSQLForTableSpace(){

  if (!isCached() || tableSpace == DataSpaceManager.tableIdDefault) {

    return null;

  }

  StringBuffer sb=new StringBuffer(64);

  sb.append(Tokens.T_SET).append(' ').append(Tokens.T_TABLE).append(' ');

  sb.append(getName().getSchemaQualifiedStatementName());

  sb.append(' ').append(Tokens.T_SPACE).append(' ').append(tableSpace);

  return sb.toString();

}

Location: Table.java

Content: 

public String[] getSQLForTextSource(boolean withHeader){

  if (isText()) {

    HsqlArrayList list=new HsqlArrayList();

    if (isReadOnly) {

      list.add(getSQLForReadOnly());

    }

    String dataSource=((TextTable)this).getDataSourceDDL();

    if (dataSource != null) {

      list.add(dataSource);

    }

    String header=((TextTable)this).getDataSourceHeader();

    if (withHeader && header != null && !isReadOnly) {

      list.add(header);

    }

    String[] array=new String[list.size()];

    list.toArray(array);

    return array;

  }

 else {

    return null;

  }

}

Location: Table.java

Content: 

String[] getSQL(OrderedHashSet resolved,OrderedHashSet unresolved){

  for (int i=0; i < constraintList.length; i++) {

    Constraint c=constraintList[i];

    if (c.isForward) {

      unresolved.add(c);

    }

 else     if (c.getConstraintType() == SchemaObject.ConstraintTypes.UNIQUE || c.getConstraintType() == SchemaObject.ConstraintTypes.PRIMARY_KEY) {

      resolved.add(c.getName());

    }

  }

  HsqlArrayList list=new HsqlArrayList();

  list.add(getSQL());

  if (!isTemp && !isText && identitySequence != null && identitySequence.getName() == null) {

    list.add(NumberSequence.getRestartSQL(this));

  }

  for (int i=0; i < indexList.length; i++) {

    if (!indexList[i].isConstraint() && indexList[i].getColumnCount() > 0) {

      list.add(indexList[i].getSQL());

    }

  }

  String[] array=new String[list.size()];

  list.toArray(array);

  return array;

}

Location: Table.java

Content: 

/** 

 * Returns the Index object of the given name or null if not found.

 */

Index getSystemIndex(String indexName){

  Index[] indexes=indexList;

  for (int i=0; i < indexes.length; i++) {

    if (indexName.equals(indexes[i].getName().name)) {

      if (indexes[i].isConstraint()) {

        return indexes[i];

      }

    }

  }

  return null;

}

Location: Table.java

Content: 

public String getTableTypeString(){

switch (tableType) {

case TableBase.MEMORY_TABLE:

    return Tokens.T_MEMORY;

case TableBase.CACHED_TABLE:

  return Tokens.T_CACHED;

case TableBase.TEXT_TABLE:

return Tokens.T_TEXT;

case TableBase.MODULE_TABLE:

return Tokens.T_MODULE;

case TableBase.FUNCTION_TABLE:

return Tokens.T_FUNCTION;

case TableBase.INFO_SCHEMA_TABLE:

case TableBase.VIEW_TABLE:

return Tokens.T_VIEW;

case TableBase.TEMP_TABLE:

return Tokens.T_TEMP;

case TableBase.SYSTEM_SUBQUERY:

default :

return "SUBQUERY";

}

}

Location: Table.java

Content: 

public int getTriggerIndex(String name){

  for (int i=0; i < triggerList.length; i++) {

    if (triggerList[i].getName().name.equals(name)) {

      return i;

    }

  }

  return -1;

}

Location: Table.java

Content: 

public TriggerDef[] getTriggers(){

  return triggerList;

}

Location: Table.java

Content: 

/** 

 * Returns a trigger.

 */

TriggerDef getTrigger(String name){

  for (int i=triggerList.length - 1; i >= 0; i--) {

    if (triggerList[i].getName().name.equals(name)) {

      return triggerList[i];

    }

  }

  return null;

}

Location: Table.java

Content: 

/** 

 * Returns the UNIQUE or PK constraint with the given column signature.

 */

Constraint getUniqueConstraintForColumns(int[] cols){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.isUniqueWithColumns(cols)) {

      return c;

    }

  }

  return null;

}

Location: Table.java

Content: 

/** 

 * Returns any unique Constraint using this index

 * @param index

 */

public Constraint getUniqueConstraintForIndex(Index index){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.getMainIndex() == index) {

      if (c.getConstraintType() == SchemaObject.ConstraintTypes.PRIMARY_KEY || c.getConstraintType() == SchemaObject.ConstraintTypes.UNIQUE) {

        return c;

      }

    }

  }

  return null;

}

Location: Table.java

Content: 

int[] getUniqueNotNullColumnGroup(boolean[] usedColumns){

  for (int i=0, count=constraintList.length; i < count; i++) {

    Constraint constraint=constraintList[i];

    if (constraint.getConstraintType() == SchemaObject.ConstraintTypes.UNIQUE) {

      int[] indexCols=constraint.getMainColumns();

      if (ArrayUtil.areAllIntIndexesInBooleanArray(indexCols,colNotNull) && ArrayUtil.areAllIntIndexesInBooleanArray(indexCols,usedColumns)) {

        return indexCols;

      }

    }

 else     if (constraint.getConstraintType() == SchemaObject.ConstraintTypes.PRIMARY_KEY) {

      int[] indexCols=constraint.getMainColumns();

      if (ArrayUtil.areAllIntIndexesInBooleanArray(indexCols,usedColumns)) {

        return indexCols;

      }

    }

  }

  return null;

}

Location: Table.java

Content: 

/** 

 * Returns any unique Constraint using this index

 * @param index

 */

public Constraint getUniqueOrPKConstraintForIndex(Index index){

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.getMainIndex() == index && (c.getConstraintType() == SchemaObject.ConstraintTypes.UNIQUE || c.getConstraintType() == SchemaObject.ConstraintTypes.PRIMARY_KEY)) {

      return c;

    }

  }

  return null;

}

Location: Table.java

Content: 

public OrderedHashSet getUniquePKConstraintNames(){

  OrderedHashSet set=new OrderedHashSet();

  for (int i=0, size=constraintList.length; i < size; i++) {

    Constraint c=constraintList[i];

    if (c.getConstraintType() == SchemaObject.ConstraintTypes.UNIQUE || c.getConstraintType() == SchemaObject.ConstraintTypes.PRIMARY_KEY) {

      set.add(c.getName());

    }

  }

  return set;

}

Location: Table.java

Content: 

/** 

 * Returns the Index object of the given name or null if not found.

 */

Index getUserIndex(String indexName){

  Index[] indexes=indexList;

  for (int i=0; i < indexes.length; i++) {

    if (indexName.equals(indexes[i].getName().name)) {

      if (!indexes[i].isConstraint()) {

        return indexes[i];

      }

    }

  }

  return null;

}

Location: Table.java

Content: 

public boolean hasGeneratedColumn(){

  return hasGeneratedValues;

}

Location: Table.java

Content: 

public boolean hasIdentityColumn(){

  return identityColumn != -1;

}

Location: Table.java

Content: 

public boolean hasLobColumn(){

  return hasLobColumn;

}

Location: Table.java

Content: 

boolean hasTrigger(int trigVecIndex){

  return triggerLists[trigVecIndex].length != 0;

}

Location: Table.java

Content: 

public boolean hasUpdatedColumn(int[] colMap){

  return hasUpdatedValues && !ArrayUtil.isAnyIntIndexInBooleanArray(colMap,colUpdated);

}

Location: Table.java

Content: 

int indexTypeForColumn(Session session,int col){

  int i=bestIndexForColumn[col];

  if (i > -1) {

    return indexList[i].isUnique() && indexList[i].getColumnCount() == 1 ? Index.INDEX_UNIQUE : Index.INDEX_NON_UNIQUE;

  }

switch (tableType) {

case TableBase.TEMP_TABLE:

case TableBase.INFO_SCHEMA_TABLE:

case TableBase.MODULE_TABLE:

case TableBase.FUNCTION_TABLE:

case TableBase.SYSTEM_SUBQUERY:

case TableBase.VIEW_TABLE:

{

      return Index.INDEX_NON_UNIQUE;

    }

}

return Index.INDEX_NONE;

}

Location: Table.java

Content: 

/** 

 * Not for general use. Used by ScriptReader to unconditionally insert a row into the table when the .script file is read.

 */

public void insertFromScript(Session session,PersistentStore store,Object[] data){

  systemUpdateIdentityValue(data);

  if (session.database.getProperties().isVersion18()) {

    for (int i=0; i < columnCount; i++) {

      if (data[i] != null) {

        int length;

        if (colTypes[i].isCharacterType() || colTypes[i].isBinaryType()) {

          if (data[i] instanceof String) {

            length=((String)data[i]).length();

          }

 else           if (data[i] instanceof BinaryData) {

            length=(int)((BinaryData)data[i]).length(session);

          }

 else {

            throw Error.runtimeError(ErrorCode.X_07000,"Table");

          }

          if (length > colTypes[i].precision) {

            length=((length / 10) + 1) * 10;

            colTypes[i]=Type.getType(colTypes[i].typeCode,colTypes[i].getCharacterSet(),colTypes[i].getCollation(),length,0);

            ColumnSchema column=getColumn(i);

            column.setType(colTypes[i]);

          }

        }

      }

    }

  }

  insertData(session,store,data);

}

Location: Table.java

Content: 

/** 

 * Multi-row insert method. Used for CREATE TABLE AS ... queries.

 */

void insertIntoTable(Session session,Result result){

  PersistentStore store=getRowStore(session);

  RowSetNavigator nav=result.initialiseNavigator();

  while (nav.next()) {

    Object[] data=nav.getCurrent();

    Object[] newData=(Object[])ArrayUtil.resizeArrayIfDifferent(data,columnCount);

    insertData(session,store,newData);

  }

}

Location: Table.java

Content: 

/** 

 */

public void insertNoCheckFromLog(Session session,Object[] data){

  systemUpdateIdentityValue(data);

  PersistentStore store=getRowStore(session);

  Row row=(Row)store.getNewCachedObject(session,data,true);

  session.addInsertAction(this,store,row,null);

}

Location: Table.java

Content: 

/** 

 * Used for subquery inserts. No checks. No identity columns.

 */

void insertResult(Session session,PersistentStore store,Result ins){

  RowSetNavigator nav=ins.initialiseNavigator();

  while (nav.next()) {

    Object[] data=nav.getCurrent();

    Object[] newData=(Object[])ArrayUtil.resizeArrayIfDifferent(data,columnCount);

    insertData(session,store,newData);

  }

}

Location: Table.java

Content: 

/** 

 * Mid level method for inserting single rows. Performs constraint checks and fires row level triggers.

 */

Row insertSingleRow(Session session,PersistentStore store,Object[] data,int[] changedCols){

  generateAndCheckData(session,data);

  if (isView) {

    return null;

  }

  Row row=(Row)store.getNewCachedObject(session,data,true);

  session.addInsertAction(this,store,row,changedCols);

  return row;

}

Location: Table.java

Content: 

/** 

 * Used by the system tables only

 */

public void insertSys(Session session,PersistentStore store,Object[] data){

  Row row=(Row)store.getNewCachedObject(session,data,false);

  store.indexRow(session,row);

}

Location: Table.java

Content: 

/** 

 * Used for system table inserts. No checks. No identity columns.

 */

public int insertSys(Session session,PersistentStore store,Result ins){

  RowSetNavigator nav=ins.getNavigator();

  int count=0;

  while (nav.next()) {

    insertSys(session,store,nav.getCurrent());

    count++;

  }

  return count;

}

Location: Table.java

Content: 

public boolean isBestRowIdentifiersStrict(){

  return bestRowIdentifierStrict;

}

Location: Table.java

Content: 

public boolean isCached(){

  return isCached;

}

Location: Table.java

Content: 

public boolean isDropped(){

  return isDropped;

}

Location: Table.java

Content: 

/** 

 * Text or Cached Tables are normally file based

 */

public boolean isFileBased(){

  return isCached || isText;

}

Location: Table.java

Content: 

boolean isIndexed(int colIndex){

  return bestIndexForColumn[colIndex] != -1;

}

Location: Table.java

Content: 

/** 

 * returns false if the table has to be recreated in order to add / drop indexes. Only CACHED tables return false.

 */

final boolean isIndexingMutable(){

  return !isCached;

}

Location: Table.java

Content: 

public final boolean isSchemaBaseTable(){

switch (tableType) {

case TableBase.MEMORY_TABLE:

case TableBase.CACHED_TABLE:

case TableBase.TEXT_TABLE:

    return true;

default :

  return false;

}

}

Location: Table.java

Content: 

public final boolean isTemp(){

  return isTemp;

}

Location: Table.java

Content: 

public final boolean isText(){

  return isText;

}

Location: Table.java

Content: 

public final boolean isView(){

  return isView;

}

Location: Table.java

Content: 

public final boolean isWithDataSource(){

  return isWithDataSource;

}

Location: Table.java

Content: 

/** 

 * For removal or addition of columns, constraints and indexes HsqlName objects are used from the old tables but no object is reused. Does not work in this form for FK's as Constraint.ConstraintCore is not transferred to a referencing or referenced table

 */

Table moveDefinition(Session session,int newType,ColumnSchema column,Constraint constraint,Index index,int colIndex,int adjust,OrderedHashSet dropConstraints,OrderedHashSet dropIndexes){

  boolean newPK=false;

  if (constraint != null && constraint.getConstraintType() == SchemaObject.ConstraintTypes.PRIMARY_KEY) {

    newPK=true;

  }

  Table tn;

  if (isText) {

    tn=new TextTable(database,tableName,newType);

    ((TextTable)tn).dataSource=((TextTable)this).dataSource;

    ((TextTable)tn).isReversed=((TextTable)this).isReversed;

    ((TextTable)tn).isConnected=((TextTable)this).isConnected;

  }

 else {

    tn=new Table(database,tableName,newType);

  }

  if (tableType == TEMP_TABLE) {

    tn.persistenceScope=persistenceScope;

  }

  tn.tableSpace=tableSpace;

  for (int i=0; i < columnCount; i++) {

    ColumnSchema col=(ColumnSchema)columnList.get(i);

    if (i == colIndex) {

      if (column != null) {

        tn.addColumn(column);

      }

      if (adjust <= 0) {

        continue;

      }

    }

    col=col.duplicate();

    col.setPrimaryKey(false);

    tn.addColumn(col);

  }

  if (columnCount == colIndex) {

    tn.addColumn(column);

  }

  int[] pkCols=null;

  if (hasPrimaryKey() && !dropConstraints.contains(getPrimaryConstraint().getName())) {

    pkCols=getPrimaryKey();

    pkCols=ArrayUtil.toAdjustedColumnArray(pkCols,colIndex,adjust);

  }

 else   if (newPK) {

    pkCols=constraint.getMainColumns();

  }

  tn.createPrimaryKey(getIndex(0).getName(),pkCols,false);

  for (int i=1; i < indexList.length; i++) {

    Index idx=indexList[i];

    if (dropIndexes.contains(idx.getName())) {

      continue;

    }

    int[] colarr=ArrayUtil.toAdjustedColumnArray(idx.getColumns(),colIndex,adjust);

    Index newIdx=tn.createIndexStructure(idx.getName(),colarr,idx.getColumnDesc(),null,idx.isUnique(),idx.isConstraint(),idx.isForward());

    newIdx.setClustered(idx.isClustered());

    tn.addIndexStructure(newIdx);

  }

  if (index != null) {

    index.setTable(tn);

    tn.addIndexStructure(index);

  }

  HsqlArrayList newList=new HsqlArrayList();

  if (newPK) {

    constraint.core.mainIndex=tn.indexList[0];

    constraint.core.mainTable=tn;

    constraint.core.mainTableName=tn.tableName;

    newList.add(constraint);

  }

  for (int i=0; i < constraintList.length; i++) {

    Constraint c=constraintList[i];

    if (dropConstraints.contains(c.getName())) {

      continue;

    }

    c=c.duplicate();

    c.updateTable(session,this,tn,colIndex,adjust);

    newList.add(c);

  }

  if (!newPK && constraint != null) {

    constraint.updateTable(session,this,tn,-1,0);

    newList.add(constraint);

  }

  tn.constraintList=new Constraint[newList.size()];

  newList.toArray(tn.constraintList);

  tn.updateConstraintLists();

  tn.setBestRowIdentifiers();

  tn.triggerList=triggerList;

  tn.triggerLists=triggerLists;

  for (int i=0; i < tn.constraintList.length; i++) {

    tn.constraintList[i].compile(session,tn);

  }

  for (int i=0; i < tn.columnCount; i++) {

    tn.getColumn(i).compile(session,tn);

  }

  return tn;

}

Location: Table.java

Content: 

/** 

 * Used when dropping all triggers.

 */

void releaseTriggers(){

  for (int i=0; i < TriggerDef.NUM_TRIGS; i++) {

    for (int j=0; j < triggerLists[i].length; j++) {

      triggerLists[i][j].terminate();

    }

    triggerLists[i]=TriggerDef.emptyArray;

  }

  triggerList=TriggerDef.emptyArray;

}

Location: Table.java

Content: 

void removeConstraint(int index){

  constraintList=(Constraint[])ArrayUtil.toAdjustedArray(constraintList,null,index,-1);

  updateConstraintLists();

}

Location: Table.java

Content: 

void renameColumn(ColumnSchema column,HsqlName newName){

  String oldname=column.getName().name;

  int i=getColumnIndex(oldname);

  if (findColumn(newName.name) != -1) {

    throw Error.error(ErrorCode.X_42504);

  }

  columnList.setKey(i,newName.name);

  column.getName().rename(newName);

}

Location: Table.java

Content: 

void renameColumn(ColumnSchema column,String newName,boolean isquoted){

  String oldname=column.getName().name;

  int i=getColumnIndex(oldname);

  columnList.setKey(i,newName);

  column.getName().rename(newName,isquoted);

}

Location: Table.java

Content: 

/** 

 * sets the flag for the presence of any default expression

 */

void resetDefaultsFlag(){

  hasDefaultValues=false;

  hasGeneratedValues=false;

  hasUpdatedValues=false;

  hasNotNullColumns=false;

  hasDomainColumns=false;

  hasLobColumn=false;

  for (int i=0; i < columnCount; i++) {

    hasDefaultValues|=colDefaults[i] != null;

    hasGeneratedValues|=colGenerated[i];

    hasUpdatedValues|=colUpdated[i];

    hasNotNullColumns|=colNotNull[i];

    if (colTypes[i].isDomainType()) {

      hasDomainColumns=true;

    }

    if (colTypes[i].isLobType()) {

      hasLobColumn=true;

    }

  }

}

Location: Table.java

Content: 

public RowIterator rowIteratorClustered(PersistentStore store){

  Index index=getClusteredIndex();

  if (index == null) {

    index=getPrimaryIndex();

  }

  return index.firstRow(store);

}

Location: Table.java

Content: 

public RowIterator rowIteratorClustered(Session session){

  PersistentStore store=getRowStore(session);

  Index index=getClusteredIndex();

  if (index == null) {

    index=getPrimaryIndex();

  }

  return index.firstRow(session,store,0,null);

}

Location: Table.java

Content: 

void setColumnStructures(){

  if (colTypes == null) {

    colTypes=new Type[columnCount];

  }

  colDefaults=new Expression[columnCount];

  colNotNull=new boolean[columnCount];

  emptyColumnCheckList=new boolean[columnCount];

  colGenerated=new boolean[columnCount];

  colUpdated=new boolean[columnCount];

  defaultColumnMap=new int[columnCount];

  for (int i=0; i < columnCount; i++) {

    setSingleColumnTypeVars(i);

  }

  resetDefaultsFlag();

}

Location: Table.java

Content: 

void setColumnTypeVars(int i){

  setSingleColumnTypeVars(i);

  resetDefaultsFlag();

}

Location: Table.java

Content: 

public void setGeneratedColumns(Session session,Object[] data){

  if (hasGeneratedValues) {

    for (int i=0; i < colGenerated.length; i++) {

      if (colGenerated[i]) {

        Expression e=getColumn(i).getGeneratingExpression();

        RangeIterator range=session.sessionContext.getCheckIterator(getDefaultRanges()[0]);

        range.setCurrent(data);

        data[i]=e.getValue(session,colTypes[i]);

      }

    }

  }

}

Location: Table.java

Content: 

/** 

 * If there is an identity column in the table, sets the value and/or adjusts the identity value for the table.

 */

protected void setIdentityColumn(Session session,Object[] data){

  if (identityColumn != -1) {

    Number id=(Number)data[identityColumn];

    if (identitySequence.getName() == null) {

      if (id == null) {

        id=(Number)identitySequence.getValueObject();

        data[identityColumn]=id;

      }

 else {

        identitySequence.userUpdate(id.longValue());

      }

    }

 else {

      if (id == null) {

        id=(Number)session.sessionData.getSequenceValue(identitySequence);

        data[identityColumn]=id;

      }

    }

    if (session != null) {

      session.setLastIdentity(id);

    }

  }

}

Location: Table.java

Content: 

/** 

 * Sets the index roots of a cached table to specified file pointers. If a file pointer is -1 then the particular index root is null. A null index root signifies an empty table. Accordingly, all index roots should be null or all should be a valid file pointer/reference.

 */

public void setIndexRoots(long[] roots,long[] uniqueSize,long cardinality){

  if (!isCached) {

    throw Error.error(ErrorCode.X_42501,tableName.name);

  }

  PersistentStore store=database.persistentStoreCollection.getStore(this);

  for (int index=0; index < indexList.length; index++) {

    store.setAccessor(indexList[index],roots[index]);

  }

  for (int index=0; index < indexList.length; index++) {

    store.setElementCount(indexList[index],cardinality,uniqueSize[index]);

  }

}

Location: Table.java

Content: 

/** 

 * Sets the index roots.

 */

void setIndexRoots(Session session,String s){

  if (!isCached) {

    throw Error.error(ErrorCode.X_42501,tableName.name);

  }

  int indexCount=getIndexCount();

  ParserDQL p=new ParserDQL(session,new Scanner(session,s),null);

  long[] roots=new long[indexCount];

  long[] uniqueSize=new long[indexCount];

  long cardinality=-1;

  p.read();

  for (int index=0; index < indexCount; index++) {

    long v=p.readBigint();

    roots[index]=v;

  }

  try {

    for (int index=0; index < indexCount; index++) {

      long v=p.readBigint();

      uniqueSize[index]=v;

    }

    cardinality=p.readBigint();

  }

 catch (  Exception e) {

  }

  setIndexRoots(roots,uniqueSize,cardinality);

}

Location: Table.java

Content: 

private void setSingleColumnTypeVars(int i){

  ColumnSchema column=getColumn(i);

  Type dataType=column.getDataType();

  colTypes[i]=dataType;

  colNotNull[i]=column.isPrimaryKey() || !column.isNullable();

  defaultColumnMap[i]=i;

  if (column.isIdentity()) {

    identitySequence=column.getIdentitySequence();

    identityColumn=i;

  }

 else   if (identityColumn == i) {

    identitySequence=null;

    identityColumn=-1;

  }

  colDefaults[i]=column.getDefaultExpression();

  colGenerated[i]=column.isGenerated();

  colUpdated[i]=column.isAutoUpdate();

}

Location: Table.java

Content: 

public void setUpdatedColumns(Session session,Object[] data){

  if (hasUpdatedValues) {

    for (int i=0; i < colUpdated.length; i++) {

      if (colUpdated[i]) {

        Expression e=getColumn(i).getUpdateExpression();

        data[i]=e.getValue(session,colTypes[i]);

      }

    }

  }

}

Location: Table.java

Content: 

public void systemSetIdentityColumn(Session session,Object[] data){

  if (identityColumn != -1) {

    Number id=(Number)data[identityColumn];

    if (id == null) {

      id=(Number)identitySequence.getValueObject();

      data[identityColumn]=id;

    }

 else {

      identitySequence.userUpdate(id.longValue());

    }

  }

}

Location: Table.java

Content: 

/** 

 * If there is an identity column in the table, sets the max identity value.

 */

public void systemUpdateIdentityValue(Object[] data){

  if (identityColumn != -1) {

    Number id=(Number)data[identityColumn];

    if (id != null) {

      identitySequence.systemUpdate(id.longValue());

    }

  }

}

Location: Table.java

Content: 

public Table(Database database,HsqlName name,int type){

  this.database=database;

  this.tableName=name;

  this.persistenceId=database.persistentStoreCollection.getNextId();

switch (type) {

case CHANGE_SET_TABLE:

    persistenceScope=SCOPE_STATEMENT;

  isSessionBased=true;

break;

case SYSTEM_SUBQUERY:

persistenceScope=SCOPE_STATEMENT;

isSessionBased=true;

break;

case INFO_SCHEMA_TABLE:

persistenceScope=SCOPE_TRANSACTION;

isSessionBased=true;

break;

case SYSTEM_TABLE:

persistenceScope=SCOPE_FULL;

isSchemaBased=true;

break;

case CACHED_TABLE:

if (database.logger.isFileDatabase()) {

persistenceScope=SCOPE_FULL;

isSchemaBased=true;

isCached=true;

isLogged=!database.isFilesReadOnly();

break;

}

type=MEMORY_TABLE;

case MEMORY_TABLE:

persistenceScope=SCOPE_FULL;

isSchemaBased=true;

isLogged=!database.isFilesReadOnly();

break;

case TEMP_TABLE:

persistenceScope=SCOPE_TRANSACTION;

isTemp=true;

isSchemaBased=true;

isSessionBased=true;

break;

case TEMP_TEXT_TABLE:

persistenceScope=SCOPE_SESSION;

if (!database.logger.isFileDatabase()) {

throw Error.error(ErrorCode.DATABASE_IS_MEMORY_ONLY);

}

isSchemaBased=true;

isSessionBased=true;

isTemp=true;

isText=true;

isReadOnly=true;

break;

case TEXT_TABLE:

persistenceScope=SCOPE_FULL;

if (!database.logger.isFileDatabase()) {

if (!database.logger.isAllowedFullPath()) {

throw Error.error(ErrorCode.DATABASE_IS_MEMORY_ONLY);

}

isReadOnly=true;

}

isSchemaBased=true;

isText=true;

break;

case VIEW_TABLE:

persistenceScope=SCOPE_STATEMENT;

isSchemaBased=true;

isSessionBased=true;

isView=true;

break;

case MODULE_TABLE:

case RESULT_TABLE:

persistenceScope=SCOPE_SESSION;

isSessionBased=true;

break;

case TableBase.FUNCTION_TABLE:

persistenceScope=SCOPE_STATEMENT;

isSessionBased=true;

break;

default :

throw Error.runtimeError(ErrorCode.U_S0500,"Table");

}

tableType=type;

identityColumn=-1;

columnList=new HashMappedList();

indexList=Index.emptyArray;

constraintList=Constraint.emptyArray;

fkConstraints=Constraint.emptyArray;

fkMainConstraints=Constraint.emptyArray;

checkConstraints=Constraint.emptyArray;

triggerList=TriggerDef.emptyArray;

triggerLists=new TriggerDef[TriggerDef.NUM_TRIGS][];

for (int i=0; i < TriggerDef.NUM_TRIGS; i++) {

triggerLists[i]=TriggerDef.emptyArray;

}

if (database.isFilesReadOnly() && isFileBased()) {

this.isReadOnly=true;

}

}

Location: Table.java

Content: 

/** 

 * trigger transition table 

 */

public Table(Table table,HsqlName name){

  persistenceScope=SCOPE_STATEMENT;

  name.schema=SqlInvariants.SYSTEM_SCHEMA_HSQLNAME;

  this.tableName=name;

  this.database=table.database;

  this.tableType=RESULT_TABLE;

  this.columnList=table.columnList;

  this.columnCount=table.columnCount;

  this.indexList=Index.emptyArray;

  this.constraintList=Constraint.emptyArray;

  createPrimaryKey();

}

Location: Table.java

Content: 

void terminateTriggers(){

  for (int i=0; i < TriggerDef.NUM_TRIGS; i++) {

    for (int j=0; j < triggerLists[i].length; j++) {

      triggerLists[i][j].terminate();

    }

  }

}

Location: Table.java

Content: 

void updateConstraintLists(){

  int fkCount=0;

  int mainCount=0;

  int checkCount=0;

  referentialActions=0;

  cascadingDeletes=0;

  for (int i=0; i < constraintList.length; i++) {

switch (constraintList[i].getConstraintType()) {

case SchemaObject.ConstraintTypes.FOREIGN_KEY:

      fkCount++;

    break;

case SchemaObject.ConstraintTypes.MAIN:

  mainCount++;

break;

case SchemaObject.ConstraintTypes.CHECK:

if (constraintList[i].isNotNull()) {

break;

}

checkCount++;

break;

}

}

fkConstraints=fkCount == 0 ? Constraint.emptyArray : new Constraint[fkCount];

fkCount=0;

fkMainConstraints=mainCount == 0 ? Constraint.emptyArray : new Constraint[mainCount];

mainCount=0;

checkConstraints=checkCount == 0 ? Constraint.emptyArray : new Constraint[checkCount];

checkCount=0;

colRefFK=new boolean[columnCount];

colMainFK=new boolean[columnCount];

for (int i=0; i < constraintList.length; i++) {

switch (constraintList[i].getConstraintType()) {

case SchemaObject.ConstraintTypes.FOREIGN_KEY:

fkConstraints[fkCount]=constraintList[i];

ArrayUtil.intIndexesToBooleanArray(constraintList[i].getRefColumns(),colRefFK);

fkCount++;

break;

case SchemaObject.ConstraintTypes.MAIN:

fkMainConstraints[mainCount]=constraintList[i];

ArrayUtil.intIndexesToBooleanArray(constraintList[i].getMainColumns(),colMainFK);

if (constraintList[i].hasCoreTriggeredAction()) {

referentialActions++;

if (constraintList[i].getDeleteAction() == SchemaObject.ReferentialAction.CASCADE) {

cascadingDeletes++;

}

}

mainCount++;

break;

case SchemaObject.ConstraintTypes.CHECK:

if (constraintList[i].isNotNull()) {

break;

}

checkConstraints[checkCount]=constraintList[i];

checkCount++;

break;

}

}

}

Location: Table.java

Content: 

void verifyConstraintsIntegrity(){

  for (int i=0; i < constraintList.length; i++) {

    Constraint c=constraintList[i];

    if (c.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY || c.getConstraintType() == SchemaObject.ConstraintTypes.MAIN) {

      if (c.getMain() != database.schemaManager.findUserTable(c.getMain().getName().name,c.getMain().getName().schema.name)) {

        throw Error.runtimeError(ErrorCode.U_S0500,"FK mismatch : " + c.getName().name);

      }

      if (c.getRef() != database.schemaManager.findUserTable(c.getRef().getName().name,c.getRef().getName().schema.name)) {

        throw Error.runtimeError(ErrorCode.U_S0500,"FK mismatch : " + c.getName().name);

      }

    }

  }

}

