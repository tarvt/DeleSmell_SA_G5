Location: Server.java

Content: 

/** 

 * Retrieves whether the specified socket should be allowed to make a connection.

 * @param socket the socket to test.

 * @return boolean

 */

protected boolean allowConnection(Socket socket){

  if (isShuttingDown) {

    return false;

  }

  return (acl == null) ? true : acl.permitAccess(socket.getInetAddress().getAddress());

}

Location: Server.java

Content: 

/** 

 * Checks if this Server object is or is not running and throws if the current state does not match the specified value.

 * @param running if true, ensure the server is running, else ensure theserver is not running

 * @throws HsqlException if the supplied value does not match thecurrent running status

 */

public void checkRunning(boolean running){

  int state;

  boolean error;

  printWithThread("checkRunning(" + running + ") entered");

  state=getState();

  error=(running && state != ServerConstants.SERVER_STATE_ONLINE) || (!running && state != ServerConstants.SERVER_STATE_SHUTDOWN);

  if (error) {

    String msg="server is " + (running ? "not " : "") + "running";

    throw Error.error(ErrorCode.GENERAL_ERROR,msg);

  }

  printWithThread("checkRunning(" + running + ") exited");

}

Location: Server.java

Content: 

/** 

 * Feature is turned off by, pending a property to allow it.

 * @return int

 */

protected int closeOldestDatabase(){

  return -1;

}

Location: Server.java

Content: 

protected void finalize(){

  if (serverThread != null) {

    hongshuai();

    printWithThread("releaseServerSocket() entered");

    if (socket != null) {

      printWithThread("Releasing server socket: [" + socket + "]");

      setState(ServerConstants.SERVER_STATE_CLOSING);

      try {

        socket.close();

      }

 catch (      IOException e) {

        printError("Exception closing server socket");

        printError("releaseServerSocket(): " + e);

      }

      socket=null;

    }

    printWithThread("releaseServerSocket() exited");

  }

}

Location: Server.java

Content: 

/** 

 * Retrieves, in string form, this server's host address.

 * @return this server's host address

 */

public String getAddress(){

  return socket == null ? serverProperties.getProperty(ServerProperties.sc_key_address) : socket.getInetAddress().getHostAddress();

}

Location: Server.java

Content: 

/** 

 * Retrieves the url alias (network name) of the i'th database that this Server hosts.

 * @param index the index of the url alias upon which to report

 * @param asconfigured if true, report the configured value, elsethe live value

 * @return the url alias component of the i'th databasethat this Server hosts, or null if no such name exists.

 */

public String getDatabaseName(int index,boolean asconfigured){

  if (asconfigured) {

    return serverProperties.getProperty(ServerProperties.sc_key_dbname + "." + index);

  }

 else   if (getState() == ServerConstants.SERVER_STATE_ONLINE) {

    return (dbAlias == null || index < 0 || index >= dbAlias.length) ? null : dbAlias[index];

  }

 else {

    return null;

  }

}

Location: Server.java

Content: 

/** 

 * Retrieves the HSQLDB path descriptor (uri) of the i'th Database that this Server hosts.

 * @param index the index of the uri upon which to report

 * @param asconfigured if true, report the configured value, elsethe live value

 * @return the HSQLDB database path descriptor of the i'th databasethat this Server hosts, or null if no such path descriptor exists

 */

public String getDatabasePath(int index,boolean asconfigured){

  if (asconfigured) {

    return serverProperties.getProperty(ServerProperties.sc_key_database + "." + index);

  }

 else   if (getState() == ServerConstants.SERVER_STATE_ONLINE) {

    return (dbPath == null || index < 0 || index >= dbPath.length) ? null : dbPath[index];

  }

 else {

    return null;

  }

}

Location: Server.java

Content: 

public String getDatabaseType(int index){

  return (dbType == null || index < 0 || index >= dbType.length) ? null : dbType[index];

}

Location: Server.java

Content: 

/** 

 * return database ID

 * @param aliasPath String

 * @return int

 */

synchronized final int getDBIndex(String aliasPath){

  int semipos=aliasPath.indexOf(';');

  String alias=aliasPath;

  String filepath=null;

  if (semipos != -1) {

    alias=aliasPath.substring(0,semipos);

    filepath=aliasPath.substring(semipos + 1);

  }

  int dbIndex=ArrayUtil.find(dbAlias,alias);

  if (dbIndex == -1) {

    if (filepath == null) {

      HsqlException e=Error.error(ErrorCode.GENERAL_ERROR,"database alias does not exist");

      printError("database alias=" + alias + " does not exist");

      setServerError(e);

      throw e;

    }

 else {

      return openDatabase(alias,filepath);

    }

  }

 else {

    return dbIndex;

  }

}

Location: Server.java

Content: 

/** 

 * Returns a map of n values from server.dbname.n values to database names from the properties object.

 * @return IntKeyHashMap

 */

private IntKeyHashMap getDBNameArray(){

  final String prefix=ServerProperties.sc_key_dbname + ".";

  final int prefixLen=prefix.length();

  IntKeyHashMap idToAliasMap=new IntKeyHashMap();

  Enumeration en=serverProperties.propertyNames();

  for (; en.hasMoreElements(); ) {

    String key=(String)en.nextElement();

    if (!key.startsWith(prefix)) {

      continue;

    }

    int dbNumber;

    try {

      dbNumber=Integer.parseInt(key.substring(prefixLen));

    }

 catch (    NumberFormatException e1) {

      printWithThread("malformed database enumerator: " + key);

      continue;

    }

    String alias=serverProperties.getProperty(key).toLowerCase();

    if (!aliasSet.add(alias)) {

      printWithThread("duplicate alias: " + alias);

    }

    Object existing=idToAliasMap.put(dbNumber,alias);

    if (existing != null) {

      printWithThread("duplicate database enumerator: " + key);

    }

  }

  return idToAliasMap;

}

Location: Server.java

Content: 

/** 

 * Retrieves the PrintWriter to which server errors are printed.

 * @return the PrintWriter to which server errors are printed.

 */

public PrintWriter getErrWriter(){

  return errWriter;

}

Location: Server.java

Content: 

final int getFirstEmptyDatabaseIndex(){

  for (int i=0; i < dbAlias.length; i++) {

    if (dbAlias[i] == null) {

      return i;

    }

  }

  return -1;

}

Location: Server.java

Content: 

/** 

 * Retrieves the PrintWriter to which server messages are printed.

 * @return the PrintWriter to which server messages are printed.

 */

public PrintWriter getLogWriter(){

  return logWriter;

}

Location: Server.java

Content: 

/** 

 * Retrieves this server's host port.

 * @return this server's host port

 */

public int getPort(){

  return serverProperties.getIntegerProperty(ServerProperties.sc_key_port,ServerConfiguration.getDefaultPort(serverProtocol,isTls()));

}

Location: Server.java

Content: 

/** 

 * Retrieves the server's product version, as a String.  <p> Typically, this will be something like: "1.x.x" or "2.x.x" and so on.

 * @return the product version of the server

 */

public String getProductVersion(){

  return HsqlDatabaseProperties.THIS_VERSION;

}

Location: Server.java

Content: 

/** 

 * Retrieves a Throwable indicating the last server error, if any. <p>

 * @return a Throwable indicating the last server error

 */

public Throwable getServerError(){

  return serverError;

}

Location: Server.java

Content: 

/** 

 * Retrieves a String identifying this Server object.

 * @return a String identifying this Server object

 */

public String getServerId(){

  return serverId;

}

Location: Server.java

Content: 

/** 

 * Returns thread object for "HSQLDB Server" thread

 * @return thread

 */

public Thread getServerThread(){

  return serverThread;

}

Location: Server.java

Content: 

/** 

 * Retrieves current state of this server in numerically coded form. <p> Typically, this will be one of: <ol> <li>ServerProperties.SERVER_STATE_ONLINE (1) <li>ServerProperties.SERVER_STATE_OPENING (4) <li>ServerProperties.SERVER_STATE_CLOSING (8) <li>ServerProperties.SERVER_STATE_SHUTDOWN (16) </ol>

 * @return this server's state code.

 */

public int getState(){

  return serverState;

}

Location: Server.java

Content: 

/** 

 * Retrieves a character sequence describing this server's current state, including the message of the last exception, if there is one and it is still in context.

 * @return this server's state represented as a character sequence.

 */

public String getStateDescriptor(){

  String state;

switch (serverState) {

case ServerConstants.SERVER_STATE_SHUTDOWN:

    state="SHUTDOWN";

  break;

case ServerConstants.SERVER_STATE_OPENING:

state="OPENING";

break;

case ServerConstants.SERVER_STATE_CLOSING:

state="CLOSING";

break;

case ServerConstants.SERVER_STATE_ONLINE:

state="ONLINE";

break;

default :

state="UNKNOWN";

break;

}

return state;

}

Location: Server.java

Content: 

/** 

 * Initializes this server, setting the accepted connection protocol.

 * @param protocol typically either SC_PROTOCOL_HTTP or SC_PROTOCOL_HSQL

 */

protected void init(int protocol){

  serverState=ServerConstants.SERVER_STATE_SHUTDOWN;

  serverConnSet=new HashSet();

  serverId=toString();

  serverId=serverId.substring(serverId.lastIndexOf('.') + 1);

  serverProtocol=protocol;

  serverProperties=ServerConfiguration.newDefaultProperties(protocol);

  logWriter=new PrintWriter(System.out);

  errWriter=new PrintWriter(System.err);

  JavaSystem.setLogToSystem(isTrace());

}

Location: Server.java

Content: 

/** 

 * Retrieves whether this server calls System.exit() when shutdown.

 * @return true if this server does not call System.exit()

 */

public boolean isNoSystemExit(){

  return serverProperties.isPropertyTrue(ServerProperties.sc_key_no_system_exit);

}

Location: Server.java

Content: 

/** 

 * Returns true if this server is not running

 * @return boolean

 */

public boolean isNotRunning(){

  int state=getState();

  return state == ServerConstants.SERVER_STATE_SHUTDOWN;

}

Location: Server.java

Content: 

/** 

 * Retrieves whether this server restarts on shutdown.

 * @return true this server restarts on shutdown

 */

public boolean isRestartOnShutdown(){

  return serverProperties.isPropertyTrue(ServerProperties.sc_key_autorestart_server);

}

Location: Server.java

Content: 

/** 

 * Retrieves whether silent mode operation was requested in the server properties.

 * @return if true, silent mode was requested, else trace messagesare to be printed

 */

public boolean isSilent(){

  return isSilent;

}

Location: Server.java

Content: 

/** 

 * Retrieves whether the use of secure sockets was requested in the server properties.

 * @return if true, secure sockets are requested, else not

 */

public boolean isTls(){

  return serverProperties.isPropertyTrue(ServerProperties.sc_key_tls);

}

Location: Server.java

Content: 

/** 

 * Retrieves whether JDBC trace messages are to go to System.out or the DriverManger PrintStream/PrintWriter, if any.

 * @return true if tracing is on (JDBC trace messages to system out)

 */

public boolean isTrace(){

  return serverProperties.isPropertyTrue(ServerProperties.sc_key_trace);

}

Location: Server.java

Content: 

/** 

 * This is called from org.hsqldb.DatabaseManager when a database is shutdown. This shuts the server down if it is the last database

 * @param id database id

 */

public final void notify(int id){

  printWithThread("notify( database shutdown," + id + ") entered");

  releaseDatabase(id);

  boolean shutdown=true;

  for (int i=0; i < dbID.length; i++) {

    if (dbAlias[i] != null) {

      shutdown=false;

    }

  }

  if (!isRemoteOpen && shutdown) {

    hongshuai();

    printWithThread("stop() entered");

    int previousState=getState();

    if (serverThread == null) {

      printWithThread("stop() serverThread is null; no action taken");

      return previousState;

    }

    releaseServerSocket();

    printWithThread("stop() exiting");

  }

}

Location: Server.java

Content: 

/** 

 * Opens this server's database instances. This method returns true If at least one database goes online, otherwise it returns false. If opening any of the databases is attempted and an exception is thrown, the server error is set to this exception.

 * @return boolean

 */

final boolean openDatabases(){

  printWithThread("openDatabases() entered");

  boolean success=false;

  setDBInfoArrays();

  for (int i=0; i < dbAlias.length; i++) {

    if (dbAlias[i] == null) {

      continue;

    }

    printWithThread("Opening database: [" + dbType[i] + dbPath[i]+ "]");

    StopWatch sw=new StopWatch();

    int id;

    try {

      id=DatabaseManager.getDatabase(dbType[i],dbPath[i],this,dbProps[i]);

      dbID[i]=id;

      success=true;

    }

 catch (    HsqlException e) {

      printError("Database [index=" + i + ", db="+ dbType[i]+ dbPath[i]+ ", alias="+ dbAlias[i]+ "] did not open: "+ e.toString());

      setServerError(e);

      dbAlias[i]=null;

      dbPath[i]=null;

      dbType[i]=null;

      dbProps[i]=null;

      continue;

    }

    sw.stop();

    String msg="Database [index=" + i + ", id="+ id+ ", db="+ dbType[i]+ dbPath[i]+ ", alias="+ dbAlias[i]+ "] opened successfully";

    print(sw.elapsedTimeToMessage(msg));

  }

  printWithThread("openDatabases() exiting");

  if (isRemoteOpen) {

    success=true;

  }

  if (!success && getServerError() == null) {

    setServerError(Error.error(ErrorCode.SERVER_NO_DATABASE));

  }

  return success;

}

Location: Server.java

Content: 

/** 

 * Open and return database index

 * @param alias String

 * @param datapath String

 * @return int

 */

final int openDatabase(String alias,String datapath){

  if (!isRemoteOpen) {

    HsqlException e=Error.error(ErrorCode.GENERAL_ERROR,"remote open not allowed");

    printError("Remote database open not allowed");

    setServerError(e);

    throw e;

  }

  int i=getFirstEmptyDatabaseIndex();

  if (i < -1) {

    i=closeOldestDatabase();

    if (i < -1) {

      HsqlException e=Error.error(ErrorCode.GENERAL_ERROR,"limit of open databases reached");

      printError("limit of open databases reached");

      setServerError(e);

      throw e;

    }

  }

  HsqlProperties newprops=DatabaseURL.parseURL(datapath,false,false);

  if (newprops == null) {

    HsqlException e=Error.error(ErrorCode.GENERAL_ERROR,"invalid database path");

    printError("invalid database path");

    setServerError(e);

    throw e;

  }

  String path=newprops.getProperty(DatabaseURL.url_database);

  String type=newprops.getProperty(DatabaseURL.url_connection_type);

  try {

    int dbid=DatabaseManager.getDatabase(type,path,this,newprops);

    dbID[i]=dbid;

    dbActionSequence[i]=actionSequence;

    dbAlias[i]=alias;

    dbPath[i]=path;

    dbType[i]=type;

    dbProps[i]=newprops;

    return i;

  }

 catch (  HsqlException e) {

    printError("Database [index=" + i + ", db="+ dbType[i]+ dbPath[i]+ ", alias="+ dbAlias[i]+ "] did not open: "+ e.toString());

    setServerError(e);

    throw e;

  }

}

Location: Server.java

Content: 

/** 

 * Constructs and installs a new ServerSocket instance for this server.

 * @throws Exception if it is not possible to construct and installa new ServerSocket

 */

private void openServerSocket() throws Exception {

  String address;

  int port;

  String[] candidateAddrs;

  String emsg;

  StopWatch sw;

  printWithThread("openServerSocket() entered");

  if (isTls()) {

    printWithThread("Requesting TLS/SSL-encrypted JDBC");

  }

  sw=new StopWatch();

  socketFactory=HsqlSocketFactory.getInstance(isTls());

  address=getAddress();

  port=getPort();

  if (StringUtil.isEmpty(address) || ServerConstants.SC_DEFAULT_ADDRESS.equalsIgnoreCase(address.trim())) {

    socket=socketFactory.createServerSocket(port);

  }

 else {

    try {

      socket=socketFactory.createServerSocket(port,address);

    }

 catch (    UnknownHostException e) {

      candidateAddrs=ServerConfiguration.listLocalInetAddressNames();

      int messageID;

      Object[] messageParameters;

      if (candidateAddrs.length > 0) {

        messageID=ErrorCode.M_SERVER_OPEN_SERVER_SOCKET_1;

        StringBuffer sb=new StringBuffer();

        for (int i=0; i < candidateAddrs.length; i++) {

          if (sb.length() > 0) {

            sb.append(", ");

          }

          sb.append(candidateAddrs[i]);

        }

        messageParameters=new Object[]{address,sb.toString()};

      }

 else {

        messageID=ErrorCode.M_SERVER_OPEN_SERVER_SOCKET_2;

        messageParameters=new Object[]{address};

      }

      throw new UnknownHostException(Error.getMessage(messageID,0,messageParameters));

    }

  }

  socket.setSoTimeout(1000);

  printWithThread("Got server socket: " + socket);

  print(sw.elapsedTimeToMessage("Server socket opened successfully"));

  if (socketFactory.isSecure()) {

    print("Using TLS/SSL-encrypted JDBC");

  }

  printWithThread("openServerSocket() exiting");

}

Location: Server.java

Content: 

/** 

 * Prints message for the specified key, without any special formatting. The message content comes from the server resource bundle and thus may localized according to the default JVM locale.<p> Uses System.out directly instead of Trace.printSystemOut() so it always prints, regardless of Trace settings.

 * @param key for message

 */

protected static void printHelp(String key){

  System.out.println(ResourceBundleHandler.getString(serverBundleHandle,key));

}

Location: Server.java

Content: 

/** 

 * Prints a description of the server properties iff !isSilent().

 */

protected void printProperties(){

  Enumeration e;

  String key;

  String value;

  if (isSilent()) {

    return;

  }

  e=serverProperties.propertyNames();

  while (e.hasMoreElements()) {

    key=(String)e.nextElement();

    value=serverProperties.getProperty(key);

    printWithThread(key + "=" + value);

  }

}

Location: Server.java

Content: 

/** 

 * Prints a description of the request encapsulated by the Result argument, r. Printing occurs iff isSilent() is false. <p> The message is formatted similarly to print(String), additionally indicating the connection identifier.  <p> For Server instances, cid is typically the value assigned to each ServerConnection object that is unique amongst all such identifiers in each distinct JVM session / class loader context. <p> For WebServer instances, a single logical connection actually spawns a new physical WebServerConnection object for each request, so the cid is typically the underlying session id, since that does not change for the duration of the logical connection.

 * @param cid the connection identifier

 * @param r the request whose description is to be printed

 */

final void printRequest(int cid,Result r){

  if (isSilent()) {

    return;

  }

  StringBuffer sb=new StringBuffer();

  sb.append(cid);

  sb.append(':');

switch (r.getType()) {

case ResultConstants.PREPARE:

{

      sb.append("SQLCLI:SQLPREPARE ");

      sb.append(r.getMainString());

      break;

    }

case ResultConstants.EXECDIRECT:

{

    sb.append(r.getMainString());

    break;

  }

case ResultConstants.EXECUTE_INVALID:

case ResultConstants.EXECUTE:

{

  sb.append("SQLCLI:SQLEXECUTE:");

  sb.append(r.getStatementID());

  break;

}

case ResultConstants.BATCHEXECUTE:

sb.append("SQLCLI:SQLEXECUTE:");

sb.append("BATCHMODE:");

sb.append(r.getStatementID());

break;

case ResultConstants.UPDATE_RESULT:

{

sb.append("SQLCLI:RESULTUPDATE:");

sb.append(r.getStatementID());

break;

}

case ResultConstants.FREESTMT:

{

sb.append("SQLCLI:SQLFREESTMT:");

sb.append(r.getStatementID());

break;

}

case ResultConstants.GETSESSIONATTR:

{

sb.append("HSQLCLI:GETSESSIONATTR");

break;

}

case ResultConstants.SETSESSIONATTR:

{

sb.append("HSQLCLI:SETSESSIONATTR:");

break;

}

case ResultConstants.ENDTRAN:

{

sb.append("SQLCLI:SQLENDTRAN:");

switch (r.getActionType()) {

case ResultConstants.TX_COMMIT:

sb.append("COMMIT");

break;

case ResultConstants.TX_ROLLBACK:

sb.append("ROLLBACK");

break;

case ResultConstants.TX_SAVEPOINT_NAME_RELEASE:

sb.append("SAVEPOINT_NAME_RELEASE ");

sb.append(r.getMainString());

break;

case ResultConstants.TX_SAVEPOINT_NAME_ROLLBACK:

sb.append("SAVEPOINT_NAME_ROLLBACK ");

sb.append(r.getMainString());

break;

default :

sb.append(r.getActionType());

}

break;

}

case ResultConstants.STARTTRAN:

{

sb.append("SQLCLI:SQLSTARTTRAN");

break;

}

case ResultConstants.DISCONNECT:

{

sb.append("SQLCLI:SQLDISCONNECT");

break;

}

case ResultConstants.SETCONNECTATTR:

{

sb.append("SQLCLI:SQLSETCONNECTATTR:");

switch (r.getConnectionAttrType()) {

case ResultConstants.SQL_ATTR_SAVEPOINT_NAME:

{

sb.append("SQL_ATTR_SAVEPOINT_NAME ");

sb.append(r.getMainString());

break;

}

default :

{

sb.append(r.getConnectionAttrType());

}

}

break;

}

case ResultConstants.CLOSE_RESULT:

{

sb.append("HQLCLI:CLOSE_RESULT:RESULT_ID ");

sb.append(r.getResultId());

break;

}

case ResultConstants.REQUESTDATA:

{

sb.append("HQLCLI:REQUESTDATA:RESULT_ID ");

sb.append(r.getResultId());

sb.append(" ROWOFFSET ");

sb.append(r.getUpdateCount());

sb.append(" ROWCOUNT ");

sb.append(r.getFetchSize());

break;

}

default :

{

sb.append("SQLCLI:MODE:");

sb.append(r.getType());

break;

}

}

print(sb.toString());

}

Location: Server.java

Content: 

/** 

 * Prints value from server's resource bundle, formatted to identify that the print operation is against this server instance. Value may be localized according to the default JVM locale

 * @param key the resource key

 */

final void printResource(String key){

  String resource;

  StringTokenizer st;

  if (serverBundleHandle < 0) {

    return;

  }

  resource=ResourceBundleHandler.getString(serverBundleHandle,key);

  if (resource == null) {

    return;

  }

  st=new StringTokenizer(resource,"\n\r");

  while (st.hasMoreTokens()) {

    print(st.nextToken());

  }

}

Location: Server.java

Content: 

/** 

 * Prints a timestamped message indicating that this server is online 

 */

private void printServerOnlineMessage(){

  String s=getProductName() + " " + getProductVersion()+ " is online on port "+ this.getPort();

  printWithTimestamp(s);

  printResource("online.help");

}

Location: Server.java

Content: 

/** 

 * Prints the stack trace of the Throwable, t, to this Server object's errWriter. <p>

 * @param t the Throwable whose stack trace is to be printed

 */

protected void printStackTrace(Throwable t){

  if (errWriter != null) {

    t.printStackTrace(errWriter);

    errWriter.flush();

  }

}

Location: Server.java

Content: 

/** 

 * Prints a message formatted similarly to print(String), additionally identifying the current (calling) thread. Replaces old method trace(String msg).

 * @param msg the message to print

 */

protected void printWithThread(String msg){

  if (!isSilent()) {

    print("[" + Thread.currentThread() + "]: "+ msg);

  }

}

Location: Server.java

Content: 

/** 

 * Prints the specified message, s, prepended with a timestamp representing the current date and time, formatted to identify that the print operation is against this server instance.

 * @param msg the message to print

 */

final void printWithTimestamp(String msg){

  print(HsqlDateTime.getSystemTimeString() + " " + msg);

}

Location: Server.java

Content: 

/** 

 * Attempts to put properties from the file with the specified path. The file extension '.properties' is implicit and should not be included in the path specification.

 * @param path the path of the desired properties file, without the'.properties' file extension

 * @throws HsqlException if this server is running

 * @return true if the indicated file was read successfully, else false

 */

public boolean putPropertiesFromFile(String path){

  return putPropertiesFromFile(path,".properties");

}

Location: Server.java

Content: 

/** 

 * Attempts to put properties from the file with given extension.

 * @param path the path of the desired properties file.

 * @param extension extension to add to path

 * @throws HsqlException if this server is running

 * @return true if the indicated file was read successfully, else false

 */

public boolean putPropertiesFromFile(String path,String extension){

  if (getState() != ServerConstants.SERVER_STATE_SHUTDOWN) {

    throw Error.error(ErrorCode.GENERAL_ERROR,"server properties");

  }

  path=FileUtil.getFileUtil().canonicalOrAbsolutePath(path);

  ServerProperties p=ServerConfiguration.getPropertiesFromFile(ServerConstants.SC_PROTOCOL_HSQL,path,extension);

  if (p == null || p.isEmpty()) {

    return false;

  }

  printWithThread("putPropertiesFromFile(): [" + path + ".properties]");

  try {

    setProperties(p);

  }

 catch (  Exception e) {

    throw Error.error(e,ErrorCode.GENERAL_ERROR,ErrorCode.M_Message_Pair,new String[]{"Failed to set properties"});

  }

  return true;

}

Location: Server.java

Content: 

/** 

 * Puts properties from the supplied string argument.  The relevant key value pairs are the same as those for the (web)server.properties file format, except that the 'server.' prefix should not be specified.

 * @param s semicolon-delimited key=value pair string,e.g. silent=false;port=8080;...

 * @throws HsqlException if this server is running

 */

public void putPropertiesFromString(String s){

  if (getState() != ServerConstants.SERVER_STATE_SHUTDOWN) {

    throw Error.error(ErrorCode.GENERAL_ERROR);

  }

  if (StringUtil.isEmpty(s)) {

    return;

  }

  printWithThread("putPropertiesFromString(): [" + s + "]");

  HsqlProperties p=HsqlProperties.delimitedArgPairsToProps(s,"=",";",ServerProperties.sc_key_prefix);

  try {

    setProperties(p);

  }

 catch (  Exception e) {

    throw Error.error(e,ErrorCode.GENERAL_ERROR,ErrorCode.M_Message_Pair,new String[]{"Failed to set properties"});

  }

}

Location: Server.java

Content: 

/** 

 * This releases the resources used for a database. Is called with id 0 multiple times for non-existent databases

 * @param id int

 */

final synchronized void releaseDatabase(int id){

  ServerConnection[] array;

  printWithThread("releaseDatabase(" + id + ") entered");

  for (int i=0; i < dbID.length; i++) {

    if (dbID[i] == id && dbAlias[i] != null) {

      dbID[i]=0;

      dbActionSequence[i]=0;

      dbAlias[i]=null;

      dbPath[i]=null;

      dbType[i]=null;

      dbProps[i]=null;

    }

  }

synchronized (serverConnSet) {

    array=new ServerConnection[serverConnSet.size()];

    serverConnSet.toArray(array);

  }

  for (int i=0; i < array.length; i++) {

    ServerConnection sc=array[i];

    if (sc.dbID == id) {

      sc.signalClose();

    }

  }

  printWithThread("releaseDatabase(" + id + ") exiting");

}

Location: Server.java

Content: 

/** 

 * Creates a new Server instance handling HSQL protocol connections.

 */

public Server(){

  this(ServerConstants.SC_PROTOCOL_HSQL);

}

Location: Server.java

Content: 

/** 

 * Creates a new Server instance handling the specified connection protocol. <p> For example, the no-args WebServer constructor invokes this constructor with ServerConstants.SC_PROTOCOL_HTTP, while the Server() no args constructor invokes this constructor with ServerConstants.SC_PROTOCOL_HSQL. <p>

 * @param protocol the ServerConstants code indicating whichconnection protocol to handle

 */

protected Server(int protocol){

  init(protocol);

}

Location: Server.java

Content: 

/** 

 * Used by Connection object

 * @param dbIndex int

 */

synchronized void setActionSequence(int dbIndex){

  dbActionSequence[dbIndex]=actionSequence++;

}

Location: Server.java

Content: 

/** 

 * Sets the InetAddress with which this server's ServerSocket will be constructed.  A null or empty string or the special value "0.0.0.0" can be used to bypass explicit selection, causing the ServerSocket to be constructed without specifying an InetAddress.

 * @param address A string representing the desired InetAddress as wouldbe retrieved by InetAddres.getByName(), or a null or empty string or "0.0.0.0" to signify that the server socket should be constructed using the signature that does not specify the InetAddress.

 * @throws HsqlException if this server is running

 */

public void setAddress(String address){

  checkRunning(false);

  if (StringUtil.isEmpty(address)) {

    address=ServerConstants.SC_DEFAULT_ADDRESS;

  }

  printWithThread("setAddress(" + address + ")");

  serverProperties.setProperty(ServerProperties.sc_key_address,address);

}

Location: Server.java

Content: 

/** 

 * Sets whether server thread is a daemon. Used before starting. The default is false.

 * @param daemon if true, start the thread as a daemon thread

 */

public void setDaemon(boolean daemon){

  checkRunning(false);

  printWithThread("setDaemon(" + daemon + ")");

  serverProperties.setProperty(ServerProperties.sc_key_daemon,daemon);

}

Location: Server.java

Content: 

/** 

 * Sets the external name (url alias) of the i'th hosted database.

 * @param index int

 * @param name external name (url alias) of the i'th HSQLDB databaseinstance this server is to host.

 */

public void setDatabaseName(int index,String name){

  checkRunning(false);

  printWithThread("setDatabaseName(" + index + ","+ name+ ")");

  serverProperties.setProperty(ServerProperties.sc_key_dbname + "." + index,name);

}

Location: Server.java

Content: 

/** 

 * Sets the path of the hosted database. The path always starts with the catalog type. Examples of the path include: "file:mydir/mydb", "mem:mymemdb", "res:org/mydomain/mydbs/settingsdb".

 * @param index int

 * @param path The path of the i'th HSQLDB database instance this server isto host.

 */

public void setDatabasePath(int index,String path){

  checkRunning(false);

  printWithThread("setDatabasePath(" + index + ","+ path+ ")");

  serverProperties.setProperty(ServerProperties.sc_key_database + "." + index,path);

}

Location: Server.java

Content: 

/** 

 * Initialises the database attributes lists from the server properties object.

 */

private void setDBInfoArrays(){

  IntKeyHashMap dbNumberMap=getDBNameArray();

  int maxDatabases=dbNumberMap.size();

  if (serverProperties.isPropertyTrue(ServerProperties.sc_key_remote_open_db)) {

    int max=serverProperties.getIntegerProperty(ServerProperties.sc_key_max_databases,ServerConstants.SC_DEFAULT_MAX_DATABASES);

    if (maxDatabases < max) {

      maxDatabases=max;

    }

  }

  dbAlias=new String[maxDatabases];

  dbPath=new String[dbAlias.length];

  dbType=new String[dbAlias.length];

  dbID=new int[dbAlias.length];

  dbActionSequence=new long[dbAlias.length];

  dbProps=new HsqlProperties[dbAlias.length];

  Iterator it=dbNumberMap.keySet().iterator();

  for (int i=0; it.hasNext(); ) {

    int dbNumber=it.nextInt();

    String path=getDatabasePath(dbNumber,true);

    if (path == null) {

      printWithThread("missing database path: " + dbNumberMap.get(dbNumber));

      continue;

    }

    HsqlProperties dbURL=DatabaseURL.parseURL(path,false,false);

    if (dbURL == null) {

      printWithThread("malformed database path: " + path);

      continue;

    }

    dbAlias[i]=(String)dbNumberMap.get(dbNumber);

    dbPath[i]=dbURL.getProperty("database");

    dbType[i]=dbURL.getProperty("connection_type");

    dbProps[i]=dbURL;

    i++;

  }

}

Location: Server.java

Content: 

/** 

 * Sets the name of the web page served when no page is specified.

 * @param file the name of the web page served when no page is specified

 */

public void setDefaultWebPage(String file){

  checkRunning(false);

  printWithThread("setDefaultWebPage(" + file + ")");

  if (serverProtocol != ServerConstants.SC_PROTOCOL_HTTP) {

    return;

  }

  serverProperties.setProperty(ServerProperties.sc_key_web_default_page,file);

}

Location: Server.java

Content: 

/** 

 * Sets the PrintWriter to which server errors are logged. <p> Setting this attribute to null disables server error logging

 * @param pw the PrintWriter to which server messages are logged

 */

public void setErrWriter(PrintWriter pw){

  errWriter=pw;

}

Location: Server.java

Content: 

/** 

 * Sets the PrintWriter to which server messages are logged. <p> Setting this attribute to null disables server message logging

 * @param pw the PrintWriter to which server messages are logged

 */

public void setLogWriter(PrintWriter pw){

  logWriter=pw;

}

Location: Server.java

Content: 

/** 

 * Sets whether this server calls System.exit() when shutdown.

 * @param noExit if true, System.exit() will not be called.

 */

public void setNoSystemExit(boolean noExit){

  printWithThread("setNoSystemExit(" + noExit + ")");

  serverProperties.setProperty(ServerProperties.sc_key_no_system_exit,noExit);

}

Location: Server.java

Content: 

/** 

 * Sets the server listen port.

 * @param port the port at which this server listens

 */

public void setPort(int port){

  checkRunning(false);

  printWithThread("setPort(" + port + ")");

  serverProperties.setProperty(ServerProperties.sc_key_port,port);

}

Location: Server.java

Content: 

/** 

 * Sets server properties using the specified properties object

 * @param props The object containing properties to set

 * @throws ServerAcl.AclFormatException ACL list was requested but problem loading ACL.

 * @throws IOException ACL list was requested but I/O problem loading ACL.

 */

public void setProperties(HsqlProperties props) throws IOException, ServerAcl.AclFormatException {

  if (!isNotRunning()) {

    checkRunning(false);

  }

  if (props != null) {

    props.validate();

    String[] errors=props.getErrorKeys();

    if (errors.length > 0) {

      throw Error.error(ErrorCode.SERVER_NO_DATABASE,errors[0]);

    }

    serverProperties.addProperties(props);

  }

  maxConnections=serverProperties.getIntegerProperty(ServerProperties.sc_key_max_connections,16);

  JavaSystem.setLogToSystem(isTrace());

  isSilent=serverProperties.isPropertyTrue(ServerProperties.sc_key_silent);

  isRemoteOpen=serverProperties.isPropertyTrue(ServerProperties.sc_key_remote_open_db);

  isDaemon=serverProperties.isPropertyTrue(ServerProperties.sc_key_daemon);

  String aclFilepath=serverProperties.getProperty(ServerProperties.sc_key_acl);

  if (aclFilepath != null) {

    acl=new ServerAcl(new File(aclFilepath));

    if (logWriter != null && !isSilent) {

      acl.setPrintWriter(logWriter);

    }

  }

}

Location: Server.java

Content: 

/** 

 * Sets whether this server restarts on shutdown.

 * @param restart if true, this server restarts on shutdown

 */

public void setRestartOnShutdown(boolean restart){

  printWithThread("setRestartOnShutdown(" + restart + ")");

  serverProperties.setProperty(ServerProperties.sc_key_autorestart_server,restart);

}

Location: Server.java

Content: 

/** 

 * Sets this Server's last encountered error state.

 * @param t The new value for the server error

 */

protected void setServerError(Throwable t){

  serverError=t;

}

Location: Server.java

Content: 

/** 

 * Sets silent mode operation

 * @param silent if true, then silent mode, else trace messagesare to be printed

 */

public void setSilent(boolean silent){

  serverProperties.setProperty(ServerProperties.sc_key_silent,silent);

  isSilent=silent;

  printWithThread("setSilent(" + silent + ")");

}

Location: Server.java

Content: 

/** 

 * Sets the server state value.

 * @param state the new value

 */

protected synchronized void setState(int state){

  serverState=state;

}

Location: Server.java

Content: 

/** 

 * Sets whether to use secure sockets

 * @param tls true for secure sockets, else false

 * @throws HsqlException if this server is running

 */

public void setTls(boolean tls){

  checkRunning(false);

  printWithThread("setTls(" + tls + ")");

  serverProperties.setProperty(ServerProperties.sc_key_tls,tls);

}

Location: Server.java

Content: 

/** 

 * Sets whether trace messages go to System.out or the DriverManger PrintStream/PrintWriter, if any.

 * @param trace if true, route JDBC trace messages to System.out

 */

public void setTrace(boolean trace){

  printWithThread("setTrace(" + trace + ")");

  serverProperties.setProperty(ServerProperties.sc_key_trace,trace);

  JavaSystem.setLogToSystem(trace);

}

Location: Server.java

Content: 

/** 

 * Sets the path of the root directory from which web content is served.

 * @param root the root (context) directory from which web contentis served

 */

public void setWebRoot(String root){

  checkRunning(false);

  root=(new File(root)).getAbsolutePath();

  printWithThread("setWebRoot(" + root + ")");

  if (serverProtocol != ServerConstants.SC_PROTOCOL_HTTP) {

    return;

  }

  serverProperties.setProperty(ServerProperties.sc_key_web_root,root);

}

Location: Server.java

Content: 

/** 

 * External method to shut down this server.

 */

public void shutdown(){

  shutdown(false);

}

Location: Server.java

Content: 

/** 

 * Shuts down all the database served by this server. As a consequence, this server and any other server that is serving a subset of the databases will be shutdown, unless the server was started with server.remote_open property. The shutdownMode must be one of: <ul> <li>org.hsqldb.Database.CLOSEMODE_IMMEDIATELY <li>org.hsqldb.Database.CLOSEMODE_NORMAL <li>org.hsqldb.Database.CLOSEMODE_COMPACT <li>org.hsqldb.Database.CLOSEMODE_SCRIPT </ul>

 * @param shutdownMode a value between 0-4, usually 0 or 1.

 */

public void shutdownCatalogs(int shutdownMode){

  DatabaseManager.shutdownDatabases(this,shutdownMode);

}

Location: Server.java

Content: 

/** 

 * Shuts down this server and all the database served by this server. As a consequence, any other server that is serving a subset of the databases will be shutdown, unless the server was started with server.remote_open property. The shutdownMode must be one of: <ul> <li>org.hsqldb.Database.CLOSEMODE_IMMEDIATELY <li>org.hsqldb.Database.CLOSEMODE_NORMAL <li>org.hsqldb.Database.CLOSEMODE_COMPACT <li>org.hsqldb.Database.CLOSEMODE_SCRIPT </ul>

 * @param shutdownMode a value between 0-4, usually 0 or 1.

 */

public void shutdownWithCatalogs(int shutdownMode){

  isShuttingDown=true;

  DatabaseManager.shutdownDatabases(this,shutdownMode);

  shutdown(false);

  isShuttingDown=false;

}

Location: Server.java

Content: 

/** 

 * Shuts down this server.

 * @param error true if shutdown is in response to an errorstate, else false

 */

protected synchronized void shutdown(boolean error){

  if (serverState == ServerConstants.SERVER_STATE_SHUTDOWN) {

    return;

  }

  StopWatch sw;

  printWithThread("shutdown() entered");

  sw=new StopWatch();

  print("Initiating shutdown sequence...");

  releaseServerSocket();

  DatabaseManager.deRegisterServer(this);

  if (dbPath != null) {

    for (int i=0; i < dbPath.length; i++) {

      releaseDatabase(dbID[i]);

    }

  }

  if (serverConnectionThreadGroup != null) {

    if (!serverConnectionThreadGroup.isDestroyed()) {

      int count=serverConnectionThreadGroup.activeCount();

      for (int i=0; serverConnectionThreadGroup.activeCount() > 0 && i < count; i++) {

        try {

          Thread.sleep(100);

        }

 catch (        Exception e) {

        }

      }

      try {

        serverConnectionThreadGroup.destroy();

        printWithThread(serverConnectionThreadGroup.getName() + " destroyed");

      }

 catch (      Throwable t) {

        printWithThread(serverConnectionThreadGroup.getName() + " not destroyed");

        printWithThread(t.toString());

      }

    }

    serverConnectionThreadGroup=null;

  }

  serverThread=null;

  setState(ServerConstants.SERVER_STATE_SHUTDOWN);

  print(sw.elapsedTimeToMessage("Shutdown sequence completed"));

  if (isNoSystemExit()) {

    printWithTimestamp("SHUTDOWN : System.exit() was not called");

    printWithThread("shutdown() exited");

  }

 else {

    printWithTimestamp("SHUTDOWN : System.exit() is called next");

    printWithThread("shutdown() exiting...");

    try {

      System.exit(0);

    }

 catch (    Throwable t) {

      printWithThread(t.toString());

    }

  }

}

