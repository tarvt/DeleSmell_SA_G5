Location: JDBCCallableStatement.java

Content: 

/** 

 * Retrieves the parameter index corresponding to the given parameter name. <p>

 * @param parameterName to look up

 * @throws SQLException if not found

 * @return index for name

 */

int findParameterIndex(String parameterName) throws SQLException {

  if (isClosed || connection.isClosed) {

    checkClosed();

  }

  if (parameterName == null) {

    throw JDBCUtil.nullArgument();

  }

  int index=parameterNameMap.get(parameterName,-1);

  if (index >= 0) {

    return index + 1;

  }

  index=parameterNameMap.get(parameterName.toUpperCase(Locale.ENGLISH),-1);

  if (index >= 0) {

    return index + 1;

  }

  throw JDBCUtil.sqlException(ErrorCode.JDBC_COLUMN_NOT_FOUND,parameterName);

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Constructs a new JDBCCallableStatement with the specified connection and result type.

 * @param c the connection on which this statement will execute

 * @param sql the SQL statement this object represents

 * @param resultSetType the type of result this statement will produce

 * @param resultSetConcurrency (updatability)

 * @param resultSetHoldability (validity beyond commit)

 * @throws HsqlException if the statement is not accepted by the database

 * @throws SQLException if preprocessing by driver fails

 */

public JDBCCallableStatement(JDBCConnection c,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability) throws HsqlException, SQLException {

  super(c,sql,resultSetType,resultSetConcurrency,resultSetHoldability,ResultConstants.RETURN_NO_GENERATED_KEYS,null,null);

  String[] names;

  String name;

  parameterNameMap=new IntValueHashMap();

  if (parameterMetaData != null) {

    names=parameterMetaData.columnLabels;

    for (int i=0; i < names.length; i++) {

      name=names[i];

      if (name == null || name.length() == 0) {

        continue;

      }

      parameterNameMap.put(name,i);

    }

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Registers the OUT parameter in ordinal position <code>parameterIndex</code> to the JDBC type <code>sqlType</code>.  All OUT parameters must be registered before a stored procedure is executed. <p> The JDBC type specified by <code>sqlType</code> for an OUT parameter determines the Java type that must be used in the <code>get</code> method to read the value of that parameter. <p> If the JDBC type expected to be returned to this output parameter is specific to this particular database, <code>sqlType</code> should be <code>java.sql.Types.OTHER</code>.  The method {@link #getObject} retrieves the value.<!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. This method can be called after a PrepareCall method. HSQLDB has already determined which parameters are OUT or INOUT parameters, therefore this method only checks and throws an exception if the parameter is not of the correct form. The data type argument is ignored<p> The <code>get</code> method to read the value of the parameter is determined by the engine based on the data type of the parameter. Furthermore, HSQLDB supports multiple OUT and INOUT parameters for stored procedures.<p> </div> <!-- end release-specific documentation -->

 * @param parameterIndex the first parameter is 1, the second is 2,and so on

 * @param sqlType the JDBC type code defined by <code>java.sql.Types</code>.If the parameter is of JDBC type <code>NUMERIC</code> or <code>DECIMAL</code>, the version of <code>registerOutParameter</code> that accepts a scale value should be used.

 * @exception SQLException JDBC 4.1 [if the parameterIndex is not valid;]if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>sqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type

 * @see java.sql.Types

 */

public void registerOutParameter(int parameterIndex,int sqlType) throws SQLException {

  writeLock.lock();

  try {

    checkGetParameterIndex(parameterIndex);

    if (parameterModes[--parameterIndex] == SchemaObject.ParameterModes.PARAM_IN) {

      throw JDBCUtil.invalidArgument();

    }

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Registers the parameter in ordinal position <code>parameterIndex</code> to be of JDBC type <code>sqlType</code>.  (JDBC4 clarification:) All OUT parameters must be registered before a stored procedure is executed. <p> The JDBC type specified by <code>sqlType</code> for an OUT parameter determines the Java type that must be used in the <code>get</code> method to read the value of that parameter. <p> This version of <code>registerOutParameter</code> should be used when the parameter is of JDBC type <code>NUMERIC</code> or <code>DECIMAL</code>. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterIndex the first parameter is 1, the second is 2,and so on

 * @param sqlType the SQL type code defined by <code>java.sql.Types</code>.

 * @param scale the desired number of digits to the right of thedecimal point.  It must be greater than or equal to zero.

 * @exception SQLException JDBC 4.1[if the parameterIndex is not valid;]if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>sqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type

 * @see java.sql.Types

 */

public void registerOutParameter(int parameterIndex,int sqlType,int scale) throws SQLException {

  writeLock.lock();

  try {

    registerOutParameter(parameterIndex,sqlType);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Registers the designated output parameter. This version of the method <code>registerOutParameter</code> should be used for a user-defined or <code>REF</code> output parameter.  Examples of user-defined types include: <code>STRUCT</code>, <code>DISTINCT</code>, <code>JAVA_OBJECT</code>, and named array types. <p> All OUT parameters must be registered before a stored procedure is executed. <p>  For a user-defined parameter, the fully-qualified SQL type name of the parameter should also be given, while a <code>REF</code> parameter requires that the fully-qualified type name of the referenced type be given.  A JDBC driver that does not need the type code and type name information may ignore it.   To be portable, however, applications should always provide these values for user-defined and <code>REF</code> parameters. Although it is intended for user-defined and <code>REF</code> parameters, this method may be used to register a parameter of any JDBC type. If the parameter does not have a user-defined or <code>REF</code> type, the <i>typeName</i> parameter is ignored. <P><B>Note:</B> When reading the value of an out parameter, you must use the getter method whose Java type corresponds to the parameter's registered SQL type. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterIndex the first parameter is 1, the second is 2,...

 * @param sqlType a value from {@link java.sql.Types}

 * @param typeName the fully-qualified name of an SQL structured type

 * @exception SQLException  JDBC 4.1[if the parameterIndex is not valid;]if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>sqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type

 * @see java.sql.Types

 * @since JDK 1.2

 */

public void registerOutParameter(int parameterIndex,int sqlType,String typeName) throws SQLException {

  readLock.lock();

  try {

    registerOutParameter(parameterIndex,sqlType);

  }

  finally {

    readLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Registers the OUT parameter named <code>parameterName</code> to the JDBC type <code>sqlType</code>.  All OUT parameters must be registered before a stored procedure is executed. <p> The JDBC type specified by <code>sqlType</code> for an OUT parameter determines the Java type that must be used in the <code>get</code> method to read the value of that parameter. <p> If the JDBC type expected to be returned to this output parameter is specific to this particular database, <code>sqlType</code> should be <code>java.sql.Types.OTHER</code>.  The method {@link #getObject} retrieves the value.<!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param sqlType the JDBC type code defined by <code>java.sql.Types</code>.If the parameter is of JDBC type <code>NUMERIC</code> or <code>DECIMAL</code>, the version of <code>registerOutParameter</code> that accepts a scale value should be used.

 * @exception SQLException JDBC 41.[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>sqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type or if the JDBC driver does not support this method

 * @since JDK 1.4, HSQL 1.7.0

 * @see java.sql.Types

 */

public void registerOutParameter(String parameterName,int sqlType) throws SQLException {

  readLock.lock();

  try {

    registerOutParameter(findParameterIndex(parameterName),sqlType);

  }

  finally {

    readLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Registers the parameter named <code>parameterName</code> to be of JDBC type <code>sqlType</code>.  (JDBC4 clarification:) All OUT parameters must be registered before a stored procedure is executed. <p> The JDBC type specified by <code>sqlType</code> for an OUT parameter determines the Java type that must be used in the <code>get</code> method to read the value of that parameter. <p> This version of <code>registerOutParameter</code> should be used when the parameter is of JDBC type <code>NUMERIC</code> or <code>DECIMAL</code>. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param sqlType SQL type code defined by <code>java.sql.Types</code>.

 * @param scale the desired number of digits to the right of thedecimal point.  It must be greater than or equal to zero.

 * @exception SQLException JDBC 41.[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>sqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type or if the JDBC driver does not support this method

 * @since JDK 1.4, HSQLDB 1.7.0

 * @see java.sql.Types

 */

public void registerOutParameter(String parameterName,int sqlType,int scale) throws SQLException {

  readLock.lock();

  try {

    registerOutParameter(findParameterIndex(parameterName),sqlType);

  }

  finally {

    readLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Registers the designated output parameter.  This version of the method <code>registerOutParameter</code> should be used for a user-named or REF output parameter.  Examples of user-named types include: STRUCT, DISTINCT, JAVA_OBJECT, and named array types. <p> (JDBC4 clarification:)<p> All OUT parameters must be registered before a stored procedure is executed. <p> For a user-named parameter the fully-qualified SQL type name of the parameter should also be given, while a REF parameter requires that the fully-qualified type name of the referenced type be given.  A JDBC driver that does not need the type code and type name information may ignore it.   To be portable, however, applications should always provide these values for user-named and REF parameters. Although it is intended for user-named and REF parameters, this method may be used to register a parameter of any JDBC type. If the parameter does not have a user-named or REF type, the typeName parameter is ignored. <P><B>Note:</B> When reading the value of an out parameter, you must use the <code>getXXX</code> method whose Java type XXX corresponds to the parameter's registered SQL type. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param sqlType a value from {@link java.sql.Types}

 * @param typeName the fully-qualified name of an SQL structured type

 * @exception SQLException JDBC 41.[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>sqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type or if the JDBC driver does not support this method

 * @see java.sql.Types

 * @since JDK 1.4, HSQL 1.7.0

 */

public void registerOutParameter(String parameterName,int sqlType,String typeName) throws SQLException {

  readLock.lock();

  try {

    registerOutParameter(findParameterIndex(parameterName),sqlType);

  }

  finally {

    readLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given input stream. When a very large ASCII value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a <code>java.io.InputStream</code>. Data will be read from the stream as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from ASCII to the database char format. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface. <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of <code>setAsciiStream</code> which takes a length parameter.

 * @param parameterName the name of the parameter

 * @param x the Java input stream that contains the ASCII parameter value

 * @exception SQLException if parameterName does not correspond to a namedparameter; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setAsciiStream(String parameterName,java.io.InputStream x) throws SQLException {

  writeLock.lock();

  try {

    super.setAsciiStream(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very large ASCII value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a <code>java.io.InputStream</code>. Data will be read from the stream as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from ASCII to the database char format. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the Java input stream that contains the ASCII parameter value

 * @param length the number of bytes in the stream

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setAsciiStream(String parameterName,java.io.InputStream x,int length) throws SQLException {

  writeLock.lock();

  try {

    setAsciiStream(findParameterIndex(parameterName),x,length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very large ASCII value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a <code>java.io.InputStream</code>. Data will be read from the stream as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from ASCII to the database char format. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

 * @param parameterName the name of the parameter

 * @param x the Java input stream that contains the ASCII parameter value

 * @param length the number of bytes in the stream

 * @exception SQLException if parameterName does not correspond to a namedparameter; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setAsciiStream(String parameterName,java.io.InputStream x,long length) throws SQLException {

  writeLock.lock();

  try {

    if (length > Integer.MAX_VALUE) {

      String msg="Maximum ASCII input octet length exceeded: " + length;

      throw JDBCUtil.sqlException(ErrorCode.JDBC_INPUTSTREAM_ERROR,msg);

    }

    this.setAsciiStream(parameterName,x,(int)length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.math.BigDecimal</code> value. The driver converts this to an SQL <code>NUMERIC</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getBigDecimal

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setBigDecimal(String parameterName,BigDecimal x) throws SQLException {

  writeLock.lock();

  try {

    setBigDecimal(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given input stream. When a very large binary value is input to a <code>LONGVARBINARY</code> parameter, it may be more practical to send it via a <code>java.io.InputStream</code> object. The data will be read from the stream as needed until end-of-file is reached. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface. <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of <code>setBinaryStream</code> which takes a length parameter.

 * @param parameterName the name of the parameter

 * @param x the java input stream which contains the binary parameter value

 * @exception SQLException if parameterName does not correspond to a namedparameter; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setBinaryStream(String parameterName,java.io.InputStream x) throws SQLException {

  writeLock.lock();

  try {

    super.setBinaryStream(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very large binary value is input to a <code>LONGVARBINARY</code> parameter, it may be more practical to send it via a <code>java.io.InputStream</code> object. The data will be read from the stream as needed until end-of-file is reached. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the java input stream which contains the binary parameter value

 * @param length the number of bytes in the stream

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setBinaryStream(String parameterName,java.io.InputStream x,int length) throws SQLException {

  writeLock.lock();

  try {

    setBinaryStream(findParameterIndex(parameterName),x,length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very large binary value is input to a <code>LONGVARBINARY</code> parameter, it may be more practical to send it via a <code>java.io.InputStream</code> object. The data will be read from the stream as needed until end-of-file is reached. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

 * @param parameterName the name of the parameter

 * @param x the java input stream which contains the binary parameter value

 * @param length the number of bytes in the stream

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setBinaryStream(String parameterName,java.io.InputStream x,long length) throws SQLException {

  writeLock.lock();

  try {

    if (length > Integer.MAX_VALUE) {

      String msg="Maximum Binary input octet length exceeded: " + length;

      throw JDBCUtil.sqlException(ErrorCode.JDBC_INPUTSTREAM_ERROR,msg);

    }

    setBinaryStream(parameterName,x,(int)length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given <code>java.sql.Blob</code> object. The driver converts this to an SQL <code>BLOB</code> value when it sends it to the database.

 * @param parameterName the name of the parameter

 * @param x a <code>Blob</code> object that maps an SQL <code>BLOB</code> value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setBlob(String parameterName,Blob x) throws SQLException {

  writeLock.lock();

  try {

    super.setBlob(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>InputStream</code> object. This method differs from the <code>setBinaryStream (int, InputStream)</code> method because it informs the driver that the parameter value should be sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code> <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of <code>setBlob</code> which takes a length parameter.

 * @param parameterName the name of the parameter

 * @param inputStream An object that contains the data to set the parametervalue to.

 * @throws SQLException if parameterName does not correspond to a namedparameter; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this methodJDK 1.6, HSQLDB 2.0

 */

public void setBlob(String parameterName,InputStream inputStream) throws SQLException {

  writeLock.lock();

  try {

    super.setBlob(findParameterIndex(parameterName),inputStream);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>InputStream</code> object.  The <code>inputstream</code> must contain  the number of characters specified by length, otherwise a <code>SQLException</code> will be generated when the <code>CallableStatement</code> is executed. This method differs from the <code>setBinaryStream (int, InputStream, int)</code> method because it informs the driver that the parameter value should be sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>

 * @param parameterName the name of the parameter to be setthe second is 2, ...

 * @param inputStream An object that contains the data to set the parametervalue to.

 * @param length the number of bytes in the parameter data.

 * @throws SQLException  if parameterName does not correspond to a namedparameter; if the length specified is less than zero; if the number of bytes in the input stream does not match the specified length; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setBlob(String parameterName,InputStream inputStream,long length) throws SQLException {

  writeLock.lock();

  try {

    super.setBlob(findParameterIndex(parameterName),inputStream,length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>boolean</code> value. <p>(JDBC4 clarification:)<p> The driver converts this to an SQL <code>BIT</code> or <code>BOOLEAN</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @see #getBoolean

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getBoolean

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setBoolean(String parameterName,boolean x) throws SQLException {

  writeLock.lock();

  try {

    setBoolean(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java array of bytes. The driver converts this to an SQL <code>VARBINARY</code> or <code>LONGVARBINARY</code> (depending on the argument's size relative to the driver's limits on <code>VARBINARY</code> values) when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getBytes

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setBytes(String parameterName,byte[] x) throws SQLException {

  writeLock.lock();

  try {

    setBytes(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>byte</code> value. The driver converts this to an SQL <code>TINYINT</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getByte

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setByte(String parameterName,byte x) throws SQLException {

  writeLock.lock();

  try {

    setByte(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given <code>Reader</code> object. When a very large UNICODE value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a <code>java.io.Reader</code> object. The data will be read from the stream as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from UNICODE to the database char format. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface. <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of <code>setCharacterStream</code> which takes a length parameter.

 * @param parameterName the name of the parameter

 * @param reader the <code>java.io.Reader</code> object that contains theUnicode data

 * @exception SQLException if parameterName does not correspond to a namedparameter; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this methodJDK 1.6, HSQLDB 2.0

 */

public void setCharacterStream(String parameterName,java.io.Reader reader) throws SQLException {

  writeLock.lock();

  try {

    super.setCharacterStream(findParameterIndex(parameterName),reader);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>Reader</code> object, which is the given number of characters long. When a very large UNICODE value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a <code>java.io.Reader</code> object. The data will be read from the stream as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from UNICODE to the database char format. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param reader the <code>java.io.Reader</code> object thatcontains the UNICODE data used as the designated parameter

 * @param length the number of characters in the stream

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setCharacterStream(String parameterName,java.io.Reader reader,int length) throws SQLException {

  writeLock.lock();

  try {

    setCharacterStream(findParameterIndex(parameterName),reader,length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given <code>Reader</code> object, which is the given number of characters long. When a very large UNICODE value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a <code>java.io.Reader</code> object. The data will be read from the stream as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from UNICODE to the database char format. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

 * @param parameterName the name of the parameter

 * @param reader the <code>java.io.Reader</code> object thatcontains the UNICODE data used as the designated parameter

 * @param length the number of characters in the stream

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setCharacterStream(String parameterName,java.io.Reader reader,long length) throws SQLException {

  writeLock.lock();

  try {

    if (length > Integer.MAX_VALUE) {

      String msg="Maximum character input length exceeded: " + length;

      throw JDBCUtil.sqlException(ErrorCode.JDBC_INPUTSTREAM_ERROR,msg);

    }

    setCharacterStream(parameterName,reader,(int)length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given <code>java.sql.Clob</code> object. The driver converts this to an SQL <code>CLOB</code> value when it sends it to the database.

 * @param parameterName the name of the parameter

 * @param x a <code>Clob</code> object that maps an SQL <code>CLOB</code> value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setClob(String parameterName,Clob x) throws SQLException {

  writeLock.lock();

  try {

    super.setClob(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>Reader</code> object. This method differs from the <code>setCharacterStream (int, Reader)</code> method because it informs the driver that the parameter value should be sent to the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code> <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of <code>setClob</code> which takes a length parameter.

 * @param parameterName the name of the parameter

 * @param reader An object that contains the data to set the parameter value to.

 * @throws SQLException if parameterName does not correspond to a namedparameter; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this methodJDK 1.6, HSQLDB 2.0

 */

public void setClob(String parameterName,Reader reader) throws SQLException {

  writeLock.lock();

  try {

    super.setClob(findParameterIndex(parameterName),reader);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>Reader</code> object.  The <code>reader</code> must contain  the number of characters specified by length otherwise a <code>SQLException</code> will be generated when the <code>CallableStatement</code> is executed. This method differs from the <code>setCharacterStream (int, Reader, int)</code> method because it informs the driver that the parameter value should be sent to the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>

 * @param parameterName the name of the parameter to be set

 * @param reader An object that contains the data to set the parameter value to.

 * @param length the number of characters in the parameter data.

 * @throws SQLException if parameterName does not correspond to a namedparameter; if the length specified is less than zero; a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setClob(String parameterName,Reader reader,long length) throws SQLException {

  writeLock.lock();

  try {

    super.setClob(findParameterIndex(parameterName),reader,length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.sql.Date</code> value (JDBC4 clarification:)<p> using the default time zone of the virtual machine that is running the application. The driver converts this to an SQL <code>DATE</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getDate

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setDate(String parameterName,Date x) throws SQLException {

  writeLock.lock();

  try {

    setDate(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.sql.Date</code> value, using the given <code>Calendar</code> object.  The driver uses the <code>Calendar</code> object to construct an SQL <code>DATE</code> value, which the driver then sends to the database.  With a a <code>Calendar</code> object, the driver can calculate the date taking into account a custom timezone.  If no <code>Calendar</code> object is specified, the driver uses the default timezone, which is that of the virtual machine running the application. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @param cal the <code>Calendar</code> object the driver will useto construct the date

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getDate

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setDate(String parameterName,Date x,Calendar cal) throws SQLException {

  writeLock.lock();

  try {

    setDate(findParameterIndex(parameterName),x,cal);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>double</code> value. The driver converts this to an SQL <code>DOUBLE</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getDouble

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setDouble(String parameterName,double x) throws SQLException {

  writeLock.lock();

  try {

    setDouble(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>float</code> value. The driver converts this to an SQL <code>FLOAT</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getFloat

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setFloat(String parameterName,float x) throws SQLException {

  writeLock.lock();

  try {

    setFloat(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>int</code> value. The driver converts this to an SQL <code>INTEGER</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getInt

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setInt(String parameterName,int x) throws SQLException {

  writeLock.lock();

  try {

    setInt(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>long</code> value. The driver converts this to an SQL <code>BIGINT</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getLong

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setLong(String parameterName,long x) throws SQLException {

  writeLock.lock();

  try {

    setLong(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>Reader</code> object. The <code>Reader</code> reads the data till end-of-file is reached. The driver does the necessary conversion from Java character format to the national character set in the database. <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that implements the standard interface. <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of <code>setNCharacterStream</code> which takes a length parameter.

 * @param parameterName the name of the parameter

 * @param value the parameter value

 * @throws SQLException if parameterName does not correspond to a namedparameter; if the driver does not support national character sets;  if the driver can detect that a data conversion error could occur; if a database access error occurs; or this method is called on a closed <code>CallableStatement</code>

 * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this methodJDK 1.6, HSQLDB 2.0

 */

public void setNCharacterStream(String parameterName,Reader value) throws SQLException {

  writeLock.lock();

  try {

    super.setNCharacterStream(findParameterIndex(parameterName),value);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>Reader</code> object. The <code>Reader</code> reads the data till end-of-file is reached. The driver does the necessary conversion from Java character format to the national character set in the database.

 * @param parameterName the name of the parameter to be set

 * @param value the parameter value

 * @param length the number of characters in the parameter data.

 * @throws SQLException  JDBC 4.1[if parameterName does not correspond to a namedparameter;] if the driver does not support national character sets;  if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setNCharacterStream(String parameterName,Reader value,long length) throws SQLException {

  writeLock.lock();

  try {

    super.setNCharacterStream(findParameterIndex(parameterName),value,length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>java.sql.NClob</code> object. The object implements the <code>java.sql.NClob</code> interface. This <code>NClob</code> object maps to a SQL <code>NCLOB</code>.

 * @param parameterName the name of the parameter to be set

 * @param value the parameter value

 * @throws SQLException  JDBC 4.1[if parameterName does not correspond to a namedparameter;] if the driver does not support national character sets;  if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setNClob(String parameterName,NClob value) throws SQLException {

  writeLock.lock();

  try {

    super.setNClob(findParameterIndex(parameterName),value);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>Reader</code> object. This method differs from the <code>setCharacterStream (int, Reader)</code> method because it informs the driver that the parameter value should be sent to the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code> <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a version of <code>setNClob</code> which takes a length parameter.

 * @param parameterName the name of the parameter

 * @param reader An object that contains the data to set the parameter value to.

 * @throws SQLException if parameterName does not correspond to a namedparameter; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur;  if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this methodJDK 1.6, HSQLDB 2.0

 */

public void setNClob(String parameterName,Reader reader) throws SQLException {

  writeLock.lock();

  try {

    super.setNClob(findParameterIndex(parameterName),reader);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to a <code>Reader</code> object.  The <code>reader</code> must contain  the number of characters specified by length otherwise a <code>SQLException</code> will be generated when the <code>CallableStatement</code> is executed. This method differs from the <code>setCharacterStream (int, Reader, int)</code> method because it informs the driver that the parameter value should be sent to the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code>

 * @param parameterName the name of the parameter to be set

 * @param reader An object that contains the data to set the parameter value to.

 * @param length the number of characters in the parameter data.

 * @throws SQLException if parameterName does not correspond to a namedparameter; if the length specified is less than zero; if the driver does not support national character sets;  if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setNClob(String parameterName,Reader reader,long length) throws SQLException {

  writeLock.lock();

  try {

    super.setNClob(findParameterIndex(parameterName),reader,length);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given <code>String</code> object. The driver converts this to a SQL <code>NCHAR</code> or <code>NVARCHAR</code> or <code>LONGNVARCHAR</code>

 * @param parameterName the name of the parameter to be set

 * @param value the parameter value

 * @throws SQLException  JDBC 4.1[if parameterName does not correspond to a namedparameter;] if the driver does not support national character sets;  if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setNString(String parameterName,String value) throws SQLException {

  writeLock.lock();

  try {

    super.setNString(findParameterIndex(parameterName),value);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to SQL <code>NULL</code>. <P><B>Note:</B> You must specify the parameter's SQL type. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param sqlType the SQL type code defined in <code>java.sql.Types</code>

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setNull(String parameterName,int sqlType) throws SQLException {

  writeLock.lock();

  try {

    setNull(findParameterIndex(parameterName),sqlType);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to SQL <code>NULL</code>. This version of the method <code>setNull</code> should be used for user-defined types and REF type parameters.  Examples of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and named array types. <P><B>Note:</B> To be portable, applications must give the SQL type code and the fully-qualified SQL type name when specifying a NULL user-defined or REF parameter.  In the case of a user-defined type the name is the type name of the parameter itself.  For a REF parameter, the name is the type name of the referenced type.  If a JDBC driver does not need the type code or type name information, it may ignore it. Although it is intended for user-defined and Ref parameters, this method may be used to set a null parameter of any JDBC type. If the parameter does not have a user-defined or REF type, the given typeName is ignored. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param sqlType a value from <code>java.sql.Types</code>

 * @param typeName the fully-qualified name of an SQL user-defined type;ignored if the parameter is not a user-defined type or SQL <code>REF</code> value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setNull(String parameterName,int sqlType,String typeName) throws SQLException {

  writeLock.lock();

  try {

    setNull(findParameterIndex(parameterName),sqlType,typeName);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the value of the designated parameter with the given object. The second parameter must be of type <code>Object</code>; therefore, the <code>java.lang</code> equivalent objects should be used for built-in types. <p>The JDBC specification specifies a standard mapping from Java <code>Object</code> types to SQL types.  The given argument will be converted to the corresponding SQL type before being sent to the database. <p>Note that this method may be used to pass datatabase- specific abstract data types, by using a driver-specific Java type. If the object is of a class implementing the interface <code>SQLData</code>, the JDBC driver should call the method <code>SQLData.writeSQL</code> to write it to the SQL data stream. If, on the other hand, the object is of a class implementing <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>, <code>Struct</code>, <code>java.net.URL</code>, or <code>Array</code>, the driver should pass it to the database as a value of the corresponding SQL type. <P> This method throws an exception if there is an ambiguity, for example, if the object is of a class implementing more than one of the interfaces named above. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the object containing the input parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs, this method is called on a closed <code>CallableStatement</code> or if the given <code>Object</code> parameter is ambiguous

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getObject

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setObject(String parameterName,Object x) throws SQLException {

  writeLock.lock();

  try {

    setObject(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the value of the designated parameter with the given object. This method is like the method <code>setObject</code> above, except that it assumes a scale of zero. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the object containing the input parameter value

 * @param targetSqlType the SQL type (as defined in java.sql.Types) to besent to the database

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>targetSqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type

 * @see #getObject

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setObject(String parameterName,Object x,int targetSqlType) throws SQLException {

  writeLock.lock();

  try {

    setObject(findParameterIndex(parameterName),x,targetSqlType);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the value of the designated parameter with the given object. The second argument must be an object type; for integral values, the <code>java.lang</code> equivalent objects should be used. <p>The given Java object will be converted to the given targetSqlType before being sent to the database. If the object has a custom mapping (is of a class implementing the interface <code>SQLData</code>), the JDBC driver should call the method <code>SQLData.writeSQL</code> to write it to the SQL data stream. If, on the other hand, the object is of a class implementing <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>, <code>Struct</code>, <code>java.net.URL</code>, or <code>Array</code>, the driver should pass it to the database as a value of the corresponding SQL type. <P> Note that this method may be used to pass database- specific abstract data types. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the object containing the input parameter value

 * @param targetSqlType the SQL type (as defined in java.sql.Types) to besent to the database. The scale argument may further qualify this type.

 * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,this is the number of digits after the decimal point.  For all other types, this value will be ignored.

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if <code>targetSqlType</code> isa <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>, <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code> or  <code>STRUCT</code> data type and the JDBC driver does not support this data type

 * @see java.sql.Types

 * @see #getObject

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setObject(String parameterName,Object x,int targetSqlType,int scale) throws SQLException {

  writeLock.lock();

  try {

    setObject(findParameterIndex(parameterName),x,targetSqlType,scale);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.sql.RowId</code> object. The driver converts this to a SQL <code>ROWID</code> when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @throws SQLException  JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setRowId(String parameterName,RowId x) throws SQLException {

  writeLock.lock();

  try {

    super.setRowId(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>short</code> value. The driver converts this to an SQL <code>SMALLINT</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getShort

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setShort(String parameterName,short x) throws SQLException {

  writeLock.lock();

  try {

    setShort(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * Sets the designated parameter to the given <code>java.sql.SQLXML</code> object. The driver converts this to an <code>SQL XML</code> value when it sends it to the database.

 * @param parameterName the name of the parameter

 * @param xmlObject a <code>SQLXML</code> object that maps an <code>SQL XML</code> value

 * @throws SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs; this method is called on a closed <code>CallableStatement</code> or the <code>java.xml.transform.Result</code>, <code>Writer</code> or <code>OutputStream</code> has not been closed for the <code>SQLXML</code> object

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @since JDK 1.6, HSQLDB 2.0

 */

public void setSQLXML(String parameterName,SQLXML xmlObject) throws SQLException {

  writeLock.lock();

  try {

    super.setSQLXML(findParameterIndex(parameterName),xmlObject);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given Java <code>String</code> value. The driver converts this to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value (depending on the argument's size relative to the driver's limits on <code>VARCHAR</code> values) when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getString

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setString(String parameterName,String x) throws SQLException {

  writeLock.lock();

  try {

    setString(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.sql.Timestamp</code> value. The driver converts this to an SQL <code>TIMESTAMP</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getTimestamp

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setTimestamp(String parameterName,Timestamp x) throws SQLException {

  writeLock.lock();

  try {

    setTimestamp(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.sql.Timestamp</code> value, using the given <code>Calendar</code> object.  The driver uses the <code>Calendar</code> object to construct an SQL <code>TIMESTAMP</code> value, which the driver then sends to the database.  With a a <code>Calendar</code> object, the driver can calculate the timestamp taking into account a custom timezone.  If no <code>Calendar</code> object is specified, the driver uses the default timezone, which is that of the virtual machine running the application. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @param cal the <code>Calendar</code> object the driver will useto construct the timestamp

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getTimestamp

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setTimestamp(String parameterName,Timestamp x,Calendar cal) throws SQLException {

  writeLock.lock();

  try {

    setTimestamp(findParameterIndex(parameterName),x,cal);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.sql.Time</code> value. The driver converts this to an SQL <code>TIME</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getTime

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setTime(String parameterName,Time x) throws SQLException {

  writeLock.lock();

  try {

    setTime(findParameterIndex(parameterName),x);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.sql.Time</code> value, using the given <code>Calendar</code> object.  The driver uses the <code>Calendar</code> object to construct an SQL <code>TIME</code> value, which the driver then sends to the database.  With a a <code>Calendar</code> object, the driver can calculate the time taking into account a custom timezone.  If no <code>Calendar</code> object is specified, the driver uses the default timezone, which is that of the virtual machine running the application. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB supports this feature. <p> </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param x the parameter value

 * @param cal the <code>Calendar</code> object the driver will useto construct the time

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs or this method is called on a closed <code>CallableStatement</code>

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getTime

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setTime(String parameterName,Time x,Calendar cal) throws SQLException {

  writeLock.lock();

  try {

    setTime(findParameterIndex(parameterName),x,cal);

  }

  finally {

    writeLock.unlock();

  }

}

Location: JDBCCallableStatement.java

Content: 

/** 

 * <!-- start generic documentation --> Sets the designated parameter to the given <code>java.net.URL</code> object. The driver converts this to an SQL <code>DATALINK</code> value when it sends it to the database. <!-- end generic documentation --> <!-- start release-specific documentation --> <div class="ReleaseSpecificDocumentation"> <h3>HSQLDB-Specific Information:</h3> <p> HSQLDB does not yet support this feature. <p> Calling this method always throws an <code>SQLException</code>. </div> <!-- end release-specific documentation -->

 * @param parameterName the name of the parameter

 * @param val the parameter value

 * @exception SQLException JDBC 4.1[if parameterName does not correspond to a namedparameter;] if a database access error occurs, this method is called on a closed <code>CallableStatement</code>, or if a URL is malformed

 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method

 * @see #getURL

 * @since JDK 1.4, HSQLDB 1.7.0

 */

public void setURL(String parameterName,java.net.URL val) throws SQLException {

  setURL(findParameterIndex(parameterName),val);

}

