Location: Session.java

Content: 

/** 

 * Adds a delete action to the row and the transaction manager.

 * @param table the table of the row

 * @param row the deleted row

 * @throws HsqlException

 */

public void addDeleteAction(Table table,PersistentStore store,Row row,int[] colMap){

  if (abortTransaction) {

    throw Error.error(ErrorCode.X_40001);

  }

  if (abortAction) {

    throw Error.error(ErrorCode.X_40502);

  }

  database.txManager.addDeleteAction(this,table,store,row,colMap);

}

Location: Session.java

Content: 

void addInsertAction(Table table,PersistentStore store,Row row,int[] changedColumns){

  database.txManager.addInsertAction(this,table,store,row,changedColumns);

  if (abortTransaction) {

    throw Error.error(ErrorCode.X_40001);

  }

  if (abortAction) {

    throw Error.error(ErrorCode.X_40502);

  }

}

Location: Session.java

Content: 

public void addWarning(HsqlException warning){

  if (sqlWarnings == null) {

    sqlWarnings=new HsqlDeque();

  }

  if (sqlWarnings.size() > 9) {

    sqlWarnings.removeFirst();

  }

  int index=sqlWarnings.indexOf(warning);

  if (index >= 0) {

    sqlWarnings.remove(index);

  }

  sqlWarnings.add(warning);

}

Location: Session.java

Content: 

public void allocateResultLob(ResultLob result,InputStream inputStream){

  sessionData.allocateLobForResult(result,inputStream);

}

Location: Session.java

Content: 

static void appendIsolationSQL(StringBuffer sb,int isolationLevel){

  sb.append(Tokens.T_ISOLATION).append(' ');

  sb.append(Tokens.T_LEVEL).append(' ');

  sb.append(getIsolationString(isolationLevel));

}

Location: Session.java

Content: 

public void beginAction(Statement cs){

  actionIndex=rowActionList.size();

  database.txManager.beginAction(this,cs);

  database.txManager.beginActionResume(this);

}

Location: Session.java

Content: 

public Result cancel(Result result){

  if (result.getType() == ResultConstants.SQLCANCEL) {

    if (result.getSessionRandomID() == randomId) {

      database.txManager.resetSession(null,this,TransactionManager.resetSessionAbort);

    }

  }

  return Result.updateZeroResult;

}

Location: Session.java

Content: 

/** 

 * This is used for creating new database objects such as tables.

 * @throws HsqlException

 */

void checkDDLWrite(){

  if (isProcessingScript || isProcessingLog) {

    return;

  }

  checkReadWrite();

}

Location: Session.java

Content: 

/** 

 * This is used for reading - writing to existing tables.

 * @throws HsqlException

 */

void checkReadWrite(){

  if (sessionContext.isReadOnly.booleanValue() || isReadOnlyIsolation) {

    throw Error.error(ErrorCode.X_25006);

  }

}

Location: Session.java

Content: 

public void closeNavigator(long id){

  readLock.lock();

  try {

    sessionData.closeNavigator(id);

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Commits any uncommitted transaction this Session may have open

 * @throws HsqlException

 */

public void commit(boolean chain){

  writeLock.lock();

  try {

    if (isClosed) {

      return;

    }

    if (sessionContext.depth > 0) {

      return;

    }

    if (isTransaction) {

      if (!database.txManager.commitTransaction(this)) {

        rollbackNoCheck(chain);

        throw Error.error(ErrorCode.X_40001);

      }

    }

 else {

      hongshuai();

      HashMap map=sessionData.sequenceUpdateMap;

      if (map == null || map.isEmpty()) {

        return;

      }

      Iterator it=map.keySet().iterator();

      for (int i=0, size=map.size(); i < size; i++) {

        NumberSequence sequence=(NumberSequence)it.next();

        database.logger.writeSequenceStatement(this,sequence);

      }

      sessionData.sequenceUpdateMap.clear();

    }

    endTransaction(true,chain);

    if (database != null && !sessionUser.isSystem() && database.logger.needsCheckpointReset()) {

      database.checkpointRunner.start();

    }

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

public Statement compileStatement(String sql){

  parser.reset(this,sql);

  Statement cs=parser.compileStatement(ResultProperties.defaultPropsValue);

  cs.setCompileTimestamp(Long.MAX_VALUE);

  return cs;

}

Location: Session.java

Content: 

public Statement compileStatement(String sql,int props){

  parser.reset(this,sql);

  Statement cs=parser.compileStatement(props);

  return cs;

}

Location: Session.java

Content: 

public BlobDataID createBlob(long length){

  long lobID=database.lobManager.createBlob(this,length);

  if (lobID == 0) {

    throw Error.error(ErrorCode.X_0F502);

  }

  sessionData.registerNewLob(lobID);

  return new BlobDataID(lobID);

}

Location: Session.java

Content: 

public ClobDataID createClob(long length){

  long lobID=database.lobManager.createClob(this,length);

  if (lobID == 0) {

    throw Error.error(ErrorCode.X_0F502);

  }

  sessionData.registerNewLob(lobID);

  return new ClobDataID(lobID);

}

Location: Session.java

Content: 

public void endAction(Result result){

  abortAction=false;

  sessionData.persistentStoreCollection.clearStatementTables();

  if (result.mode == ResultConstants.ERROR) {

    sessionData.persistentStoreCollection.clearResultTables(actionTimestamp);

    database.txManager.rollbackAction(this);

  }

 else {

    sessionContext.diagnosticsVariables[ExpressionColumn.idx_row_count]=result.mode == ResultConstants.UPDATECOUNT ? Integer.valueOf(result.getUpdateCount()) : ValuePool.INTEGER_0;

    database.txManager.completeActions(this);

  }

}

Location: Session.java

Content: 

private void endTransaction(boolean commit,boolean chain){

  abortTransaction=false;

  sessionContext.resetStack();

  sessionContext.savepoints.clear();

  sessionContext.savepointTimestamps.clear();

  rowActionList.clear();

  sessionData.persistentStoreCollection.clearTransactionTables();

  sessionData.closeAllTransactionNavigators();

  sessionData.clearLobOps();

  if (!chain) {

    sessionContext.isReadOnly=isReadOnlyDefault ? Boolean.TRUE : Boolean.FALSE;

    setIsolation(isolationLevelDefault);

  }

  if (database.logger.getSqlEventLogLevel() > 0) {

    Statement endTX=commit ? StatementSession.commitNoChainStatement : StatementSession.rollbackNoChainStatement;

    database.logger.logStatementEvent(this,endTX,null,Result.updateZeroResult,SimpleLog.LOG_ERROR);

  }

}

Location: Session.java

Content: 

private Result executeCompiledBatchStatement(Result cmd){

  long csid;

  Statement cs;

  int[] updateCounts;

  int count;

  cs=cmd.statement;

  if (cs == null || cs.compileTimestamp < database.schemaManager.schemaChangeTimestamp) {

    csid=cmd.getStatementID();

    cs=statementManager.getStatement(this,csid);

    if (cs == null) {

      return Result.newErrorResult(Error.error(ErrorCode.X_07502));

    }

  }

  count=0;

  RowSetNavigator nav=cmd.initialiseNavigator();

  updateCounts=new int[nav.getSize()];

  Result generatedResult=null;

  if (cs.hasGeneratedColumns()) {

    generatedResult=Result.newGeneratedDataResult(cs.generatedResultMetaData());

  }

  Result error=null;

  while (nav.next()) {

    Object[] pvals=nav.getCurrent();

    Result in=executeCompiledStatement(cs,pvals,cmd.queryTimeout);

    if (in.isUpdateCount()) {

      if (cs.hasGeneratedColumns()) {

        RowSetNavigator navgen=in.getChainedResult().getNavigator();

        while (navgen.next()) {

          Object[] generatedRow=navgen.getCurrent();

          generatedResult.getNavigator().add(generatedRow);

        }

      }

      updateCounts[count++]=in.getUpdateCount();

    }

 else     if (in.isData()) {

      updateCounts[count++]=ResultConstants.SUCCESS_NO_INFO;

    }

 else     if (in.mode == ResultConstants.CALL_RESPONSE) {

      updateCounts[count++]=ResultConstants.SUCCESS_NO_INFO;

    }

 else     if (in.mode == ResultConstants.ERROR) {

      updateCounts=ArrayUtil.arraySlice(updateCounts,0,count);

      error=in;

      break;

    }

 else {

      throw Error.runtimeError(ErrorCode.U_S0500,"Session");

    }

  }

  return Result.newBatchedExecuteResponse(updateCounts,generatedResult,error);

}

Location: Session.java

Content: 

public Result executeCompiledStatement(Statement cs,Object[] pvals,int timeout){

  Result r;

  if (abortTransaction) {

    return handleAbortTransaction();

  }

  if (sessionContext.depth > 0) {

    if (sessionContext.noSQL.booleanValue() || cs.isAutoCommitStatement()) {

      return Result.newErrorResult(Error.error(ErrorCode.X_46000));

    }

  }

  if (cs.isAutoCommitStatement()) {

    if (isReadOnly()) {

      return Result.newErrorResult(Error.error(ErrorCode.X_25006));

    }

    try {

      commit(false);

    }

 catch (    HsqlException e) {

      database.logger.logInfoEvent("Exception at commit");

    }

  }

  sessionContext.currentStatement=cs;

  boolean isTX=cs.isTransactionStatement();

  if (!isTX) {

    actionTimestamp=database.txManager.getNextGlobalChangeTimestamp();

    sessionContext.setDynamicArguments(pvals);

    if (database.logger.getSqlEventLogLevel() >= SimpleLog.LOG_NORMAL) {

      database.logger.logStatementEvent(this,cs,pvals,Result.updateZeroResult,SimpleLog.LOG_NORMAL);

    }

    r=cs.execute(this);

    sessionContext.currentStatement=null;

    return r;

  }

  repeatLoop:   while (true) {

    actionIndex=rowActionList.size();

    database.txManager.beginAction(this,cs);

    if (redoAction) {

      redoAction=false;

      continue;

    }

    cs=sessionContext.currentStatement;

    if (cs == null) {

      return Result.newErrorResult(Error.error(ErrorCode.X_07502));

    }

    if (abortTransaction) {

      return handleAbortTransaction();

    }

    timeoutManager.startTimeout(timeout);

    while (true) {

      try {

        latch.await();

      }

 catch (      InterruptedException e) {

        Thread.interrupted();

        continue;

      }

      break;

    }

    if (abortAction) {

      r=Result.newErrorResult(Error.error(ErrorCode.X_40502));

      endAction(r);

      break repeatLoop;

    }

    if (abortTransaction) {

      return handleAbortTransaction();

    }

    database.txManager.beginActionResume(this);

    timeoutManager.resumeTimeout();

    sessionContext.setDynamicArguments(pvals);

    r=cs.execute(this);

    if (database.logger.getSqlEventLogLevel() >= SimpleLog.LOG_NORMAL) {

      database.logger.logStatementEvent(this,cs,pvals,r,SimpleLog.LOG_NORMAL);

    }

    endAction(r);

    if (abortTransaction) {

      break repeatLoop;

    }

    if (redoAction) {

      redoAction=false;

      while (true) {

        try {

          latch.await();

        }

 catch (        InterruptedException e) {

          Thread.interrupted();

          continue;

        }

        break;

      }

    }

 else {

      break repeatLoop;

    }

  }

  if (abortTransaction) {

    return handleAbortTransaction();

  }

  if (sessionContext.depth == 0 && (sessionContext.isAutoCommit.booleanValue() || cs.isAutoCommitStatement())) {

    try {

      if (r.mode == ResultConstants.ERROR) {

        rollbackNoCheck(false);

      }

 else {

        commit(false);

      }

    }

 catch (    Exception e) {

      sessionContext.currentStatement=null;

      return Result.newErrorResult(Error.error(ErrorCode.X_40001,e));

    }

  }

  sessionContext.currentStatement=null;

  return r;

}

Location: Session.java

Content: 

private Result executeDirectBatchStatement(Result cmd){

  int[] updateCounts;

  int count;

  count=0;

  RowSetNavigator nav=cmd.initialiseNavigator();

  updateCounts=new int[nav.getSize()];

  Result error=null;

  while (nav.next()) {

    Result in;

    Object[] data=nav.getCurrent();

    String sql=(String)data[0];

    try {

      Statement cs=compileStatement(sql);

      in=executeCompiledStatement(cs,ValuePool.emptyObjectArray,cmd.queryTimeout);

    }

 catch (    Throwable t) {

      in=Result.newErrorResult(t);

    }

    if (in.isUpdateCount()) {

      updateCounts[count++]=in.getUpdateCount();

    }

 else     if (in.isData()) {

      updateCounts[count++]=ResultConstants.SUCCESS_NO_INFO;

    }

 else     if (in.mode == ResultConstants.CALL_RESPONSE) {

      updateCounts[count++]=ResultConstants.SUCCESS_NO_INFO;

    }

 else     if (in.mode == ResultConstants.ERROR) {

      updateCounts=ArrayUtil.arraySlice(updateCounts,0,count);

      error=in;

      break;

    }

 else {

      throw Error.runtimeError(ErrorCode.U_S0500,"Session");

    }

  }

  return Result.newBatchedExecuteResponse(updateCounts,null,error);

}

Location: Session.java

Content: 

public Result executeDirectStatement(Result cmd){

  String sql=cmd.getMainString();

  HsqlArrayList list;

  int maxRows=cmd.getUpdateCount();

  if (maxRows == -1) {

    sessionContext.currentMaxRows=0;

  }

 else   if (sessionMaxRows == 0) {

    sessionContext.currentMaxRows=maxRows;

  }

 else {

    sessionContext.currentMaxRows=sessionMaxRows;

    sessionMaxRows=0;

  }

  try {

    list=parser.compileStatements(sql,cmd);

  }

 catch (  Throwable e) {

    return Result.newErrorResult(e);

  }

  Result result=null;

  boolean recompile=false;

  HsqlName originalSchema=getCurrentSchemaHsqlName();

  for (int i=0; i < list.size(); i++) {

    Statement cs=(Statement)list.get(i);

    if (i > 0) {

      if (cs.getCompileTimestamp() > database.txManager.getGlobalChangeTimestamp()) {

        recompile=true;

      }

      if (cs.getSchemaName() != null && cs.getSchemaName() != originalSchema) {

        recompile=true;

      }

    }

    if (recompile) {

      cs=compileStatement(cs.getSQL(),cmd.getExecuteProperties());

    }

    cs.setGeneratedColumnInfo(cmd.getGeneratedResultType(),cmd.getGeneratedResultMetaData());

    result=executeCompiledStatement(cs,ValuePool.emptyObjectArray,cmd.queryTimeout);

    if (result.mode == ResultConstants.ERROR) {

      break;

    }

  }

  return result;

}

Location: Session.java

Content: 

public Result executeDirectStatement(String sql){

  try {

    Statement cs=compileStatement(sql);

    Result result=executeCompiledStatement(cs,ValuePool.emptyObjectArray,0);

    return result;

  }

 catch (  HsqlException e) {

    return Result.newErrorResult(e);

  }

}

Location: Session.java

Content: 

/** 

 * Retrieves the result of inserting, updating or deleting a row from an updatable result.

 * @return the result of executing the statement

 */

private Result executeResultUpdate(Result cmd){

  long id=cmd.getResultId();

  int actionType=cmd.getActionType();

  Result result=sessionData.getDataResult(id);

  if (result == null) {

    return Result.newErrorResult(Error.error(ErrorCode.X_24501));

  }

  Object[] pvals=(Object[])cmd.valueData;

  Type[] types=cmd.metaData.columnTypes;

  StatementQuery statement=(StatementQuery)result.getStatement();

  sessionContext.rowUpdateStatement.setRowActionProperties(result,actionType,statement,types);

  Result resultOut=executeCompiledStatement(sessionContext.rowUpdateStatement,pvals,cmd.queryTimeout);

  return resultOut;

}

Location: Session.java

Content: 

/** 

 * Executes the command encapsulated by the cmd argument.

 * @param cmd the command to execute

 * @return the result of executing the command

 */

public Result execute(Result cmd){

  writeLock.lock();

  try {

    if (isClosed) {

      return Result.newErrorResult(Error.error(ErrorCode.X_08503));

    }

    sessionContext.currentMaxRows=0;

    isBatch=false;

    JavaSystem.gc();

switch (cmd.mode) {

case ResultConstants.LARGE_OBJECT_OP:

{

        return performLOBOperation((ResultLob)cmd);

      }

case ResultConstants.EXECUTE:

{

      int maxRows=cmd.getUpdateCount();

      if (maxRows == -1) {

        sessionContext.currentMaxRows=0;

      }

 else {

        sessionContext.currentMaxRows=maxRows;

      }

      Statement cs=cmd.statement;

      if (cs == null || cs.compileTimestamp < database.schemaManager.schemaChangeTimestamp) {

        long csid=cmd.getStatementID();

        cs=statementManager.getStatement(this,csid);

        cmd.setStatement(cs);

        if (cs == null) {

          return Result.newErrorResult(Error.error(ErrorCode.X_07502));

        }

      }

      Object[] pvals=(Object[])cmd.valueData;

      Result result=executeCompiledStatement(cs,pvals,cmd.queryTimeout);

      result=performPostExecute(cmd,result);

      return result;

    }

case ResultConstants.BATCHEXECUTE:

{

    isBatch=true;

    Result result=executeCompiledBatchStatement(cmd);

    result=performPostExecute(cmd,result);

    return result;

  }

case ResultConstants.EXECDIRECT:

{

  Result result=executeDirectStatement(cmd);

  result=performPostExecute(cmd,result);

  return result;

}

case ResultConstants.BATCHEXECDIRECT:

{

isBatch=true;

Result result=executeDirectBatchStatement(cmd);

result=performPostExecute(cmd,result);

return result;

}

case ResultConstants.PREPARE:

{

Statement cs;

try {

cs=statementManager.compile(this,cmd);

}

 catch (Throwable t) {

String errorString=cmd.getMainString();

return Result.newErrorResult(t,errorString);

}

Result result=Result.newPrepareResponse(cs);

if (cs.getType() == StatementTypes.SELECT_CURSOR || cs.getType() == StatementTypes.CALL) {

sessionData.setResultSetProperties(cmd,result);

}

result=performPostExecute(cmd,result);

return result;

}

case ResultConstants.CLOSE_RESULT:

{

closeNavigator(cmd.getResultId());

return Result.updateZeroResult;

}

case ResultConstants.UPDATE_RESULT:

{

Result result=this.executeResultUpdate(cmd);

result=performPostExecute(cmd,result);

return result;

}

case ResultConstants.FREESTMT:

{

statementManager.freeStatement(cmd.getStatementID());

return Result.updateZeroResult;

}

case ResultConstants.GETSESSIONATTR:

{

int id=cmd.getStatementType();

return getAttributesResult(id);

}

case ResultConstants.SETSESSIONATTR:

{

return setAttributes(cmd);

}

case ResultConstants.ENDTRAN:

{

switch (cmd.getActionType()) {

case ResultConstants.TX_COMMIT:

try {

commit(false);

}

 catch (Throwable t) {

return Result.newErrorResult(t);

}

break;

case ResultConstants.TX_COMMIT_AND_CHAIN:

try {

commit(true);

}

 catch (Throwable t) {

return Result.newErrorResult(t);

}

break;

case ResultConstants.TX_ROLLBACK:

rollback(false);

break;

case ResultConstants.TX_ROLLBACK_AND_CHAIN:

rollback(true);

break;

case ResultConstants.TX_SAVEPOINT_NAME_RELEASE:

try {

String name=cmd.getMainString();

releaseSavepoint(name);

}

 catch (Throwable t) {

return Result.newErrorResult(t);

}

break;

case ResultConstants.TX_SAVEPOINT_NAME_ROLLBACK:

try {

rollbackToSavepoint(cmd.getMainString());

}

 catch (Throwable t) {

return Result.newErrorResult(t);

}

break;

case ResultConstants.PREPARECOMMIT:

try {

prepareCommit();

}

 catch (Throwable t) {

return Result.newErrorResult(t);

}

break;

}

return Result.updateZeroResult;

}

case ResultConstants.SETCONNECTATTR:

{

switch (cmd.getConnectionAttrType()) {

case ResultConstants.SQL_ATTR_SAVEPOINT_NAME:

try {

savepoint(cmd.getMainString());

}

 catch (Throwable t) {

return Result.newErrorResult(t);

}

}

return Result.updateZeroResult;

}

case ResultConstants.REQUESTDATA:

{

return sessionData.getDataResultSlice(cmd.getResultId(),cmd.getUpdateCount(),cmd.getFetchSize());

}

case ResultConstants.DISCONNECT:

{

close();

return Result.updateZeroResult;

}

default :

{

return Result.newErrorResult(Error.runtimeError(ErrorCode.U_S0500,"Session"));

}

}

}

  finally {

writeLock.unlock();

}

}

Location: Session.java

Content: 

public long getActionTimestamp(){

  return actionTimestamp;

}

Location: Session.java

Content: 

public HsqlException[] getAndClearWarnings(){

  if (sqlWarnings == null) {

    return HsqlException.emptyArray;

  }

  HsqlException[] array=new HsqlException[sqlWarnings.size()];

  sqlWarnings.toArray(array);

  sqlWarnings.clear();

  return array;

}

Location: Session.java

Content: 

private Result getAttributesResult(int id){

  Result r=Result.newSessionAttributesResult();

  Object[] data=r.getSingleRowData();

  data[SessionInterface.INFO_ID]=ValuePool.getInt(id);

switch (id) {

case SessionInterface.INFO_ISOLATION:

    data[SessionInterface.INFO_INTEGER]=ValuePool.getInt(isolationLevel);

  break;

case SessionInterface.INFO_AUTOCOMMIT:

data[SessionInterface.INFO_BOOLEAN]=sessionContext.isAutoCommit;

break;

case SessionInterface.INFO_CONNECTION_READONLY:

data[SessionInterface.INFO_BOOLEAN]=sessionContext.isReadOnly;

break;

case SessionInterface.INFO_CATALOG:

data[SessionInterface.INFO_VARCHAR]=database.getCatalogName().name;

break;

}

return r;

}

Location: Session.java

Content: 

public Object getAttribute(int id){

  readLock.lock();

  try {

switch (id) {

case SessionInterface.INFO_ISOLATION:

      return ValuePool.getInt(isolationLevel);

case SessionInterface.INFO_AUTOCOMMIT:

    return sessionContext.isAutoCommit;

case SessionInterface.INFO_CONNECTION_READONLY:

  return isReadOnlyDefault ? Boolean.TRUE : Boolean.FALSE;

case SessionInterface.INFO_CATALOG:

return database.getCatalogName().name;

}

return null;

}

  finally {

readLock.unlock();

}

}

Location: Session.java

Content: 

public Calendar getCalendar(){

  if (calendar == null) {

    if (zoneString == null) {

      calendar=new GregorianCalendar();

    }

 else {

      TimeZone zone=TimeZone.getTimeZone(zoneString);

      calendar=new GregorianCalendar(zone);

    }

  }

  return calendar;

}

Location: Session.java

Content: 

public Calendar getCalendarGMT(){

  if (calendarGMT == null) {

    calendarGMT=new GregorianCalendar(TimeZone.getTimeZone("GMT"));

  }

  return calendarGMT;

}

Location: Session.java

Content: 

public HsqlProperties getClientProperties(){

  if (clientProperties == null) {

    clientProperties=new HsqlProperties();

    clientProperties.setProperty(HsqlDatabaseProperties.jdbc_translate_tti_types,database.sqlTranslateTTI);

    clientProperties.setProperty(HsqlDatabaseProperties.sql_live_object,database.sqlLiveObject);

  }

  return clientProperties;

}

Location: Session.java

Content: 

public TypedComparator getComparator(){

  return typedComparator;

}

Location: Session.java

Content: 

/** 

 * Getter for connectTime attribute.

 * @return the value

 */

public long getConnectTime(){

  return connectTime;

}

Location: Session.java

Content: 

/** 

 * Returns the current date, unchanged for the duration of the current execution unit (statement).<p> SQL standards require that CURRENT_DATE, CURRENT_TIME and CURRENT_TIMESTAMP are all evaluated at the same point of time in the duration of each SQL statement, no matter how long the SQL statement takes to complete.<p> When this method or a corresponding method for CURRENT_TIME or CURRENT_TIMESTAMP is first called in the scope of a system change number, currentMillis is set to the current system time. All further CURRENT_XXXX calls in this scope will use this millisecond value. (fredt@users)

 */

public TimestampData getCurrentDate(){

  readLock.lock();

  try {

    resetCurrentTimestamp();

    if (currentDate == null) {

      currentDate=(TimestampData)Type.SQL_DATE.getValue(currentMillis / 1000,0,getZoneSeconds());

    }

    return currentDate;

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

public HsqlName getCurrentSchemaHsqlName(){

  return currentSchema;

}

Location: Session.java

Content: 

/** 

 * Returns the current timestamp, unchanged for the duration of the current execution unit (statement)

 */

TimestampData getCurrentTimestamp(boolean withZone){

  readLock.lock();

  try {

    resetCurrentTimestamp();

    if (withZone) {

      if (currentTimestamp == null) {

        int nanos=(int)(currentMillis % 1000) * 1000000;

        currentTimestamp=new TimestampData((currentMillis / 1000),nanos,getZoneSeconds());

      }

      return currentTimestamp;

    }

 else {

      if (localTimestamp == null) {

        int nanos=(int)(currentMillis % 1000) * 1000000;

        localTimestamp=new TimestampData(currentMillis / 1000 + getZoneSeconds(),nanos,0);

      }

      return localTimestamp;

    }

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Returns the current time, unchanged for the duration of the current execution unit (statement)

 */

TimeData getCurrentTime(boolean withZone){

  readLock.lock();

  try {

    resetCurrentTimestamp();

    if (withZone) {

      if (currentTime == null) {

        int seconds=(int)(HsqlDateTime.getNormalisedTime(getCalendarGMT(),currentMillis)) / 1000;

        int nanos=(int)(currentMillis % 1000) * 1000000;

        currentTime=new TimeData(seconds,nanos,getZoneSeconds());

      }

      return currentTime;

    }

 else {

      if (localTime == null) {

        int seconds=(int)(HsqlDateTime.getNormalisedTime(getCalendarGMT(),currentMillis + getZoneSeconds() * 1000L)) / 1000;

        int nanos=(int)(currentMillis % 1000) * 1000000;

        localTime=new TimeData(seconds,nanos,0);

      }

      return localTime;

    }

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

public String getDatabaseUniqueName(){

  return database.getNameString();

}

Location: Session.java

Content: 

/** 

 * Retrieves an internal Connection object equivalent to the one that created this Session.

 * @return  internal connection.

 */

JDBCConnection getInternalConnection(){

  if (intConnection == null) {

    intConnection=new JDBCConnection(this);

  }

  JDBCDriver.driverInstance.threadConnection.set(intConnection);

  return intConnection;

}

Location: Session.java

Content: 

public String getInternalConnectionURL(){

  return DatabaseURL.S_URL_PREFIX + database.getURI();

}

Location: Session.java

Content: 

public int getIsolation(){

  readLock.lock();

  try {

    return isolationLevel;

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

static String getIsolationString(int isolationLevel){

switch (isolationLevel) {

case SessionInterface.TX_READ_UNCOMMITTED:

case SessionInterface.TX_READ_COMMITTED:

    StringBuffer sb=new StringBuffer();

  sb.append(Tokens.T_READ).append(' ');

sb.append(Tokens.T_COMMITTED);

return sb.toString();

case SessionInterface.TX_REPEATABLE_READ:

case SessionInterface.TX_SERIALIZABLE:

default :

return Tokens.T_SERIALIZABLE;

}

}

Location: Session.java

Content: 

/** 

 * Getter for iLastIdentity attribute.

 * @return the current value

 */

public Number getLastIdentity(){

  return sessionContext.lastIdentity;

}

Location: Session.java

Content: 

public HsqlException getLastWarning(){

  if (sqlWarnings == null || sqlWarnings.size() == 0) {

    return null;

  }

  return (HsqlException)sqlWarnings.getLast();

}

Location: Session.java

Content: 

public int getRandomId(){

  return randomId;

}

Location: Session.java

Content: 

public int getResultMemoryRowCount(){

  return resultMaxMemoryRows;

}

Location: Session.java

Content: 

public Grantee getRole(){

  return role;

}

Location: Session.java

Content: 

public HsqlArrayList getRowActionList(){

  return rowActionList;

}

Location: Session.java

Content: 

public RowSetNavigatorClient getRows(long navigatorId,int offset,int blockSize){

  return sessionData.getRowSetSlice(navigatorId,offset,blockSize);

}

Location: Session.java

Content: 

public Scanner getScanner(){

  if (secondaryScanner == null) {

    secondaryScanner=new Scanner();

  }

  return secondaryScanner;

}

Location: Session.java

Content: 

/** 

 * If schemaName is null, return the current schema name, else return the HsqlName object for the schema. If schemaName does not exist, throw.

 */

HsqlName getSchemaHsqlName(String name){

  return name == null ? currentSchema : database.schemaManager.getSchemaHsqlName(name);

}

Location: Session.java

Content: 

/** 

 * Same as above, but return string

 */

public String getSchemaName(String name){

  return name == null ? currentSchema.name : database.schemaManager.getSchemaName(name);

}

Location: Session.java

Content: 

String getSessionIsolationSQL(){

  StringBuffer sb=new StringBuffer();

  sb.append(Tokens.T_SET).append(' ').append(Tokens.T_SESSION);

  sb.append(' ').append(Tokens.T_CHARACTERISTICS).append(' ');

  sb.append(Tokens.T_AS).append(' ').append(Tokens.T_TRANSACTION).append(' ');

  appendIsolationSQL(sb,isolationLevelDefault);

  return sb.toString();

}

Location: Session.java

Content: 

String getSetSchemaStatement(){

  return "SET SCHEMA " + currentSchema.statementName;

}

Location: Session.java

Content: 

public SimpleDateFormat getSimpleDateFormatGMT(){

  if (simpleDateFormatGMT == null) {

    simpleDateFormatGMT=new SimpleDateFormat("MMMM",Locale.ENGLISH);

    simpleDateFormatGMT.setCalendar(getCalendarGMT());

  }

  return simpleDateFormatGMT;

}

Location: Session.java

Content: 

String getStartTransactionSQL(){

  StringBuffer sb=new StringBuffer();

  sb.append(Tokens.T_START).append(' ').append(Tokens.T_TRANSACTION);

  if (isolationLevel != isolationLevelDefault) {

    sb.append(' ');

    appendIsolationSQL(sb,isolationLevel);

  }

  return sb.toString();

}

Location: Session.java

Content: 

TimestampData getSystemTimestamp(boolean withZone){

  readLock.lock();

  try {

    long millis=System.currentTimeMillis();

    long seconds=millis / 1000;

    int nanos=(int)(millis % 1000) * 1000000;

    TimeZone zone=TimeZone.getDefault();

    int offset=zone.getOffset(millis) / 1000;

    if (!withZone) {

      seconds+=offset;

      offset=0;

    }

    return new TimestampData(seconds,nanos,offset);

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

String getTransactionIsolationSQL(){

  StringBuffer sb=new StringBuffer();

  sb.append(Tokens.T_SET).append(' ').append(Tokens.T_TRANSACTION);

  sb.append(' ');

  appendIsolationSQL(sb,isolationLevel);

  return sb.toString();

}

Location: Session.java

Content: 

/** 

 * Count of actions in current transaction.

 * @return the current value

 */

public int getTransactionSize(){

  return rowActionList.size();

}

Location: Session.java

Content: 

public long getTransactionTimestamp(){

  return transactionTimestamp;

}

Location: Session.java

Content: 

public int getZoneSeconds(){

  return timeZoneSeconds;

}

Location: Session.java

Content: 

private Result handleAbortTransaction(){

  rollbackNoCheck(false);

  sessionContext.currentStatement=null;

  return Result.newErrorResult(Error.error(ErrorCode.X_40001));

}

Location: Session.java

Content: 

/** 

 * Getter for autoCommit attribute.

 * @return the current value

 */

public boolean isAutoCommit(){

  writeLock.lock();

  try {

    return sessionContext.isAutoCommit.booleanValue();

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

public boolean isIgnorecase(){

  return ignoreCase;

}

Location: Session.java

Content: 

public boolean isInMidTransaction(){

  return isTransaction;

}

Location: Session.java

Content: 

public boolean isProcessingLog(){

  return isProcessingLog;

}

Location: Session.java

Content: 

public boolean isProcessingScript(){

  return isProcessingScript;

}

Location: Session.java

Content: 

public boolean isReadOnlyDefault(){

  writeLock.lock();

  try {

    return isReadOnlyDefault;

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

void logSequences(){

  HashMap map=sessionData.sequenceUpdateMap;

  if (map == null || map.isEmpty()) {

    return;

  }

  Iterator it=map.keySet().iterator();

  for (int i=0, size=map.size(); i < size; i++) {

    NumberSequence sequence=(NumberSequence)it.next();

    database.logger.writeSequenceStatement(this,sequence);

  }

  sessionData.sequenceUpdateMap.clear();

}

Location: Session.java

Content: 

Result performLOBOperation(ResultLob cmd){

  long id=cmd.getLobID();

  int operation=cmd.getSubType();

switch (operation) {

case ResultLob.LobResultTypes.REQUEST_GET_LOB:

{

      return database.lobManager.getLob(id,cmd.getOffset(),cmd.getBlockLength());

    }

case ResultLob.LobResultTypes.REQUEST_GET_LENGTH:

{

    return database.lobManager.getLength(id);

  }

case ResultLob.LobResultTypes.REQUEST_GET_BYTES:

{

  return database.lobManager.getBytes(id,cmd.getOffset(),(int)cmd.getBlockLength());

}

case ResultLob.LobResultTypes.REQUEST_SET_BYTES:

{

return database.lobManager.setBytes(id,cmd.getOffset(),cmd.getByteArray(),(int)cmd.getBlockLength());

}

case ResultLob.LobResultTypes.REQUEST_GET_CHARS:

{

return database.lobManager.getChars(id,cmd.getOffset(),(int)cmd.getBlockLength());

}

case ResultLob.LobResultTypes.REQUEST_SET_CHARS:

{

return database.lobManager.setChars(id,cmd.getOffset(),cmd.getCharArray(),(int)cmd.getBlockLength());

}

case ResultLob.LobResultTypes.REQUEST_TRUNCATE:

{

return database.lobManager.truncate(id,cmd.getOffset());

}

case ResultLob.LobResultTypes.REQUEST_DUPLICATE_LOB:

{

return database.lobManager.createDuplicateLob(id);

}

case ResultLob.LobResultTypes.REQUEST_CREATE_BYTES:

case ResultLob.LobResultTypes.REQUEST_CREATE_CHARS:

case ResultLob.LobResultTypes.REQUEST_GET_BYTE_PATTERN_POSITION:

case ResultLob.LobResultTypes.REQUEST_GET_CHAR_PATTERN_POSITION:

{

throw Error.error(ErrorCode.X_0A501);

}

default :

{

throw Error.runtimeError(ErrorCode.U_S0500,"Session");

}

}

}

Location: Session.java

Content: 

private Result performPostExecute(Result command,Result result){

  if (result.mode == ResultConstants.DATA) {

    result=sessionData.getDataResultHead(command,result,isNetwork);

  }

  if (sqlWarnings != null && sqlWarnings.size() > 0) {

    if (result.mode == ResultConstants.UPDATECOUNT) {

      result=new Result(ResultConstants.UPDATECOUNT,result.getUpdateCount());

    }

    HsqlException[] warnings=getAndClearWarnings();

    result.addWarnings(warnings);

  }

  return result;

}

Location: Session.java

Content: 

/** 

 * @todo - fredt - for two phased pre-commit - after this call, furtherstate changing calls should fail

 */

public void prepareCommit(){

  writeLock.lock();

  try {

    if (isClosed) {

      throw Error.error(ErrorCode.X_08003);

    }

    if (!database.txManager.prepareCommitActions(this)) {

      rollbackNoCheck(false);

      throw Error.error(ErrorCode.X_40001);

    }

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

public double random(){

  return randomGenerator.nextDouble();

}

Location: Session.java

Content: 

public double random(long seed){

  if (this.seed != seed) {

    randomGenerator.setSeed(seed);

    this.seed=seed;

  }

  return randomGenerator.nextDouble();

}

Location: Session.java

Content: 

public void registerResultLobs(Result result){

  sessionData.registerLobForResult(result);

}

Location: Session.java

Content: 

void releaseInternalConnection(){

  if (sessionContext.depth == 0) {

    JDBCDriver.driverInstance.threadConnection.set(null);

  }

}

Location: Session.java

Content: 

/** 

 * Releases a savepoint

 * @param name name of savepoint

 * @throws HsqlException if name does not correspond to a savepoint

 */

public void releaseSavepoint(String name){

  readLock.lock();

  try {

    int index=sessionContext.savepoints.getIndex(name);

    if (index < 0) {

      throw Error.error(ErrorCode.X_3B001,name);

    }

    while (sessionContext.savepoints.size() > index) {

      sessionContext.savepoints.remove(sessionContext.savepoints.size() - 1);

      sessionContext.savepointTimestamps.removeLast();

    }

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

private void resetCurrentTimestamp(){

  if (currentTimestampSCN != actionTimestamp) {

    currentTimestampSCN=actionTimestamp;

    currentMillis=System.currentTimeMillis();

    currentDate=null;

    currentTimestamp=null;

    localTimestamp=null;

    currentTime=null;

    localTime=null;

  }

}

Location: Session.java

Content: 

void resetSchema(){

  loggedSchema=null;

  currentSchema=user.getInitialOrDefaultSchema();

}

Location: Session.java

Content: 

/** 

 * Clear structures and reset variables to original. For JDBC use only. Note: sets autocommit true

 */

public void resetSession(){

  writeLock.lock();

  try {

    if (isClosed) {

      return;

    }

    rollbackNoCheck(false);

    sessionData.closeAllNavigators();

    sessionData.persistentStoreCollection.clearAllTables();

    sessionData.clearLobOps();

    statementManager.reset();

    sessionContext.lastIdentity=ValuePool.INTEGER_0;

    sessionContext.isAutoCommit=Boolean.TRUE;

    setResultMemoryRowCount(database.getResultMaxMemoryRows());

    user=sessionUser;

    resetSchema();

    setZoneSeconds(sessionTimeZoneSeconds);

    sessionMaxRows=0;

    ignoreCase=database.sqlIgnoreCase;

    setIsolation(isolationLevelDefault);

    txConflictRollback=database.txConflictRollback;

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

public void rollbackAction(int start,long timestamp){

  readLock.lock();

  try {

    if (isClosed) {

      return;

    }

    database.txManager.rollbackPartial(this,start,timestamp);

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

void rollbackNoCheck(boolean chain){

  writeLock.lock();

  try {

    if (isClosed) {

      return;

    }

    if (isTransaction) {

      database.txManager.rollback(this);

    }

    endTransaction(false,chain);

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Performs a partial transaction ROLLBACK of current savepoint level.

 * @throws HsqlException

 */

public void rollbackToSavepoint(){

  readLock.lock();

  try {

    if (isClosed) {

      return;

    }

    database.txManager.rollbackSavepoint(this,0);

  }

  finally {

    readLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Performs a partial transaction ROLLBACK to savepoint.

 * @param name name of savepoint

 * @throws HsqlException

 */

public void rollbackToSavepoint(String name){

  writeLock.lock();

  try {

    if (isClosed) {

      return;

    }

    int index=sessionContext.savepoints.getIndex(name);

    if (index < 0) {

      throw Error.error(ErrorCode.X_3B001,name);

    }

    database.txManager.rollbackSavepoint(this,index);

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Rolls back any uncommitted transaction this Session may have open.

 * @throws HsqlException

 */

public void rollback(boolean chain){

  writeLock.lock();

  try {

    if (sessionContext.depth > 0) {

      return;

    }

    rollbackNoCheck(chain);

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Registers a transaction SAVEPOINT. A new SAVEPOINT with the name of an existing one replaces the old SAVEPOINT.

 * @param name name of the savepoint

 * @throws HsqlException if there is no current transaction

 */

public void savepoint(String name){

  writeLock.lock();

  try {

    int index=sessionContext.savepoints.getIndex(name);

    if (index != -1) {

      sessionContext.savepoints.remove(name);

      sessionContext.savepointTimestamps.remove(index);

    }

    actionTimestamp=database.txManager.getNextGlobalChangeTimestamp();

    sessionContext.savepoints.add(name,ValuePool.getInt(rowActionList.size()));

    sessionContext.savepointTimestamps.addLast(actionTimestamp);

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Constructs a new Session object.

 * @param db the database to which this represents a connection

 * @param user the initial user

 * @param autocommit the initial autocommit value

 * @param readonly the initial readonly value

 * @param id the session identifier, as known to the database

 */

Session(Database db,User user,boolean autocommit,boolean readonly,long id,String zoneString,int timeZoneSeconds){

  sessionId=id;

  database=db;

  this.user=user;

  this.sessionUser=user;

  this.zoneString=zoneString;

  this.sessionTimeZoneSeconds=timeZoneSeconds;

  this.timeZoneSeconds=timeZoneSeconds;

  rowActionList=new HsqlArrayList(32,true);

  waitedSessions=new OrderedHashSet();

  waitingSessions=new OrderedHashSet();

  tempSet=new OrderedHashSet();

  actionSet=new OrderedHashSet();

  isolationLevelDefault=database.defaultIsolationLevel;

  ignoreCase=database.sqlIgnoreCase;

  isolationLevel=isolationLevelDefault;

  txConflictRollback=database.txConflictRollback;

  isReadOnlyDefault=readonly;

  isReadOnlyIsolation=isolationLevel == SessionInterface.TX_READ_UNCOMMITTED;

  sessionContext=new SessionContext(this);

  sessionContext.isAutoCommit=autocommit ? Boolean.TRUE : Boolean.FALSE;

  sessionContext.isReadOnly=isReadOnlyDefault ? Boolean.TRUE : Boolean.FALSE;

  parser=new ParserCommand(this,new Scanner());

  setResultMemoryRowCount(database.getResultMaxMemoryRows());

  resetSchema();

  sessionData=new SessionData(database,this);

  statementManager=new StatementManager(database);

  timeoutManager=new TimeoutManager();

  sessionStartTimestamp=System.currentTimeMillis();

}

Location: Session.java

Content: 

private Result setAttributes(Result r){

  Object[] row=r.getSessionAttributes();

  int id=((Integer)row[SessionInterface.INFO_ID]).intValue();

  try {

switch (id) {

case SessionInterface.INFO_AUTOCOMMIT:

{

        boolean value=((Boolean)row[SessionInterface.INFO_BOOLEAN]).booleanValue();

        this.setAutoCommit(value);

        break;

      }

case SessionInterface.INFO_CONNECTION_READONLY:

{

      boolean value=((Boolean)row[SessionInterface.INFO_BOOLEAN]).booleanValue();

      this.setReadOnlyDefault(value);

      break;

    }

case SessionInterface.INFO_ISOLATION:

{

    int value=((Integer)row[SessionInterface.INFO_INTEGER]).intValue();

    this.setIsolationDefault(value);

    break;

  }

case SessionInterface.INFO_CATALOG:

{

  String value=((String)row[SessionInterface.INFO_VARCHAR]);

  this.setCatalog(value);

}

}

}

 catch (HsqlException e) {

return Result.newErrorResult(e);

}

return Result.updateZeroResult;

}

Location: Session.java

Content: 

public void setAttribute(int id,Object object){

  writeLock.lock();

  try {

switch (id) {

case SessionInterface.INFO_AUTOCOMMIT:

{

        boolean value=((Boolean)object).booleanValue();

        this.setAutoCommit(value);

        break;

      }

case SessionInterface.INFO_CONNECTION_READONLY:

{

      boolean value=((Boolean)object).booleanValue();

      this.setReadOnlyDefault(value);

      break;

    }

case SessionInterface.INFO_ISOLATION:

{

    int value=((Integer)object).intValue();

    this.setIsolationDefault(value);

    break;

  }

case SessionInterface.INFO_CATALOG:

{

  String value=((String)object);

  this.setCatalog(value);

}

}

}

  finally {

writeLock.unlock();

}

}

Location: Session.java

Content: 

public void setCurrentSchemaHsqlName(HsqlName name){

  currentSchema=name;

}

Location: Session.java

Content: 

void setFeature(String feature,boolean value){

  int number=8;

  if (value) {

    sessionOptimization|=number;

  }

 else {

    sessionOptimization&=~number;

  }

}

Location: Session.java

Content: 

public void setIgnoreCase(boolean mode){

  ignoreCase=mode;

}

Location: Session.java

Content: 

public void setIsolationDefault(int level){

  writeLock.lock();

  try {

    if (level == SessionInterface.TX_READ_UNCOMMITTED) {

      level=SessionInterface.TX_READ_COMMITTED;

    }

    if (level == isolationLevelDefault) {

      return;

    }

    isolationLevelDefault=level;

    if (!isInMidTransaction()) {

      isolationLevel=isolationLevelDefault;

      isReadOnlyIsolation=level == SessionInterface.TX_READ_UNCOMMITTED;

    }

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * sets ISOLATION for the next transaction only

 */

public void setIsolation(int level){

  if (isInMidTransaction()) {

    throw Error.error(ErrorCode.X_25001);

  }

  if (level == SessionInterface.TX_READ_UNCOMMITTED) {

    level=SessionInterface.TX_READ_COMMITTED;

  }

  if (isolationLevel != level) {

    isolationLevel=level;

    isReadOnlyIsolation=level == SessionInterface.TX_READ_UNCOMMITTED;

  }

}

Location: Session.java

Content: 

public void setJDBCConnection(JDBCConnection connection){

  extConnection=connection;

}

Location: Session.java

Content: 

/** 

 * Setter for iLastIdentity attribute.

 * @param i the new value

 */

void setLastIdentity(Number i){

  sessionContext.lastIdentity=i;

}

Location: Session.java

Content: 

public void setNoSQL(){

  sessionContext.noSQL=Boolean.TRUE;

}

Location: Session.java

Content: 

public void setReadOnlyDefault(boolean readonly){

  writeLock.lock();

  try {

    if (!readonly && database.databaseReadOnly) {

      throw Error.error(ErrorCode.DATABASE_IS_READONLY);

    }

    isReadOnlyDefault=readonly;

    if (!isInMidTransaction()) {

      sessionContext.isReadOnly=isReadOnlyDefault ? Boolean.TRUE : Boolean.FALSE;

    }

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

public void setResultMemoryRowCount(int count){

  if (database.logger.getTempDirectoryPath() != null) {

    if (count < 0) {

      count=0;

    }

    resultMaxMemoryRows=count;

  }

}

Location: Session.java

Content: 

public void setRole(Grantee role){

  this.role=role;

}

Location: Session.java

Content: 

/** 

 * The SQL command SET MAXROWS n will override the Statement.setMaxRows(n) for the next direct statement only NB this is dedicated to the SET MAXROWS sql statement and should not otherwise be called. (fredt@users)

 */

void setSQLMaxRows(int rows){

  sessionMaxRows=rows;

}

Location: Session.java

Content: 

/** 

 * Sets this Session's User object to the one specified by the user argument.

 * @param user the new User object for this session

 */

public void setUser(User user){

  this.user=user;

}

Location: Session.java

Content: 

public void setZoneSeconds(int seconds){

  timeZoneSeconds=seconds;

}

Location: Session.java

Content: 

public void startPhasedTransaction(){

  writeLock.lock();

  try {

  }

  finally {

    writeLock.unlock();

  }

}

Location: Session.java

Content: 

/** 

 * Explicit start of transaction by user

 */

public void startTransaction(){

  database.txManager.beginTransaction(this);

}

