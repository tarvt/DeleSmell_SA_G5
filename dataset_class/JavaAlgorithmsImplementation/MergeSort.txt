Location: MergeSort.java

Content: 

private static <T extends Comparable<T>>void mergeInPlace(int aStart,int aLength,int bStart,int bLength,T[] unsorted){

  int i=aStart;

  int j=bStart;

  int aSize=aStart + aLength;

  int bSize=bStart + bLength;

  while (i < aSize && j < bSize) {

    T a=unsorted[i];

    T b=unsorted[j];

    if (b.compareTo(a) < 0) {

      System.arraycopy(unsorted,i,unsorted,i + 1,j - i);

      unsorted[i]=b;

      i++;

      j++;

      aSize++;

    }

 else {

      i++;

    }

  }

}

Location: MergeSort.java

Content: 

private MergeSort(){

}

Location: MergeSort.java

Content: 

private static <T extends Comparable<T>>void mergeWithExtraStorage(int aStart,int aLength,int bStart,int bLength,T[] unsorted){

  int count=0;

  T[] output=(T[])new Comparable[aLength + bLength];

  int i=aStart;

  int j=bStart;

  int aSize=aStart + aLength;

  int bSize=bStart + bLength;

  while (i < aSize || j < bSize) {

    T a=null;

    if (i < aSize) {

      a=unsorted[i];

    }

    T b=null;

    if (j < bSize) {

      b=unsorted[j];

    }

    if (a != null && b == null) {

      output[count++]=a;

      i++;

    }

 else     if (b != null && a == null) {

      output[count++]=b;

      j++;

    }

 else     if (b != null && b.compareTo(a) <= 0) {

      output[count++]=b;

      j++;

    }

 else {

      output[count++]=a;

      i++;

    }

  }

  int x=0;

  int size=aStart + aLength + bLength;

  for (int y=aStart; y < size; y++) {

    unsorted[y]=output[x++];

  }

}

Location: MergeSort.java

Content: 

private static <T extends Comparable<T>>void sort(SPACE_TYPE type,int start,int length,T[] unsorted){

  if (length > 2) {

    int aLength=(int)Math.floor(length / 2);

    int bLength=length - aLength;

    sort(type,start,aLength,unsorted);

    sort(type,start + aLength,bLength,unsorted);

    if (type == SPACE_TYPE.IN_PLACE)     mergeInPlace(start,aLength,start + aLength,bLength,unsorted);

 else     mergeWithExtraStorage(start,aLength,start + aLength,bLength,unsorted);

  }

 else   if (length == 2) {

    T e=unsorted[start + 1];

    if (e.compareTo(unsorted[start]) < 0) {

      unsorted[start + 1]=unsorted[start];

      unsorted[start]=e;

    }

  }

}

Location: MergeSort.java

Content: 

public static <T extends Comparable<T>>T[] sort(SPACE_TYPE type,T[] unsorted){

  sort(type,0,unsorted.length,unsorted);

  return unsorted;

}

