Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Construct the (internal representation of the) GDEF table based on previously parsed state.

 * @returns glyph definition table or null if insufficient or invalid state

 */

private GlyphDefinitionTable constructGDEF(){

  GlyphDefinitionTable gdef=null;

  List subtables;

  if ((subtables=constructGDEFSubtables()) != null) {

    if (subtables.size() > 0) {

      gdef=new GlyphDefinitionTable(subtables,processors);

    }

  }

  resetATState();

  return gdef;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private List constructGDEFSubtables(){

  List<GlyphSubtable> subtables=new java.util.ArrayList();

  if (seSubtables != null) {

    for (    Object seSubtable : seSubtables) {

      Object[] stp=(Object[])seSubtable;

      GlyphSubtable st;

      if ((st=constructGDEFSubtable(stp)) != null) {

        subtables.add(st);

      }

    }

  }

  return subtables;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphSubtable constructGDEFSubtable(Object[] stp){

  GlyphSubtable st=null;

  assert (stp != null) && (stp.length == 8);

  Integer tt=(Integer)stp[0];

  Integer lt=(Integer)stp[1];

  Integer ln=(Integer)stp[2];

  Integer lf=(Integer)stp[3];

  Integer sn=(Integer)stp[4];

  Integer sf=(Integer)stp[5];

  GlyphMappingTable mapping=(GlyphMappingTable)stp[6];

  List entries=(List)stp[7];

  if (tt == GlyphTable.GLYPH_TABLE_TYPE_DEFINITION) {

    int type=GDEFLookupType.getSubtableType(lt);

    String lid="lu" + ln;

    int sequence=sn;

    int flags=lf;

    int format=sf;

    st=GlyphDefinitionTable.createSubtable(type,lid,sequence,flags,format,mapping,entries);

  }

  return st;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Construct the (internal representation of the) GPOS table based on previously parsed state.

 * @returns glyph positioning table or null if insufficient or invalid state

 */

private GlyphPositioningTable constructGPOS(){

  GlyphPositioningTable gpos=null;

  Map lookups;

  if ((lookups=constructLookups()) != null) {

    List subtables;

    if ((subtables=constructGPOSSubtables()) != null) {

      if ((lookups.size() > 0) && (subtables.size() > 0)) {

        gpos=new GlyphPositioningTable(gdef,lookups,subtables,processors);

      }

    }

  }

  resetATState();

  return gpos;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private List constructGPOSSubtables(){

  List<GlyphSubtable> subtables=new java.util.ArrayList();

  if (seSubtables != null) {

    for (    Object seSubtable : seSubtables) {

      Object[] stp=(Object[])seSubtable;

      GlyphSubtable st;

      if ((st=constructGPOSSubtable(stp)) != null) {

        subtables.add(st);

      }

    }

  }

  return subtables;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphSubtable constructGPOSSubtable(Object[] stp){

  GlyphSubtable st=null;

  assert (stp != null) && (stp.length == 8);

  Integer tt=(Integer)stp[0];

  Integer lt=(Integer)stp[1];

  Integer ln=(Integer)stp[2];

  Integer lf=(Integer)stp[3];

  Integer sn=(Integer)stp[4];

  Integer sf=(Integer)stp[5];

  GlyphCoverageTable coverage=(GlyphCoverageTable)stp[6];

  List entries=(List)stp[7];

  if (tt == GlyphTable.GLYPH_TABLE_TYPE_POSITIONING) {

    int type=GSUBLookupType.getSubtableType(lt);

    String lid="lu" + ln;

    int sequence=sn;

    int flags=lf;

    int format=sf;

    st=GlyphPositioningTable.createSubtable(type,lid,sequence,flags,format,coverage,entries);

  }

  return st;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Construct the (internal representation of the) GSUB table based on previously parsed state.

 * @returns glyph substitution table or null if insufficient or invalid state

 */

private GlyphSubstitutionTable constructGSUB(){

  GlyphSubstitutionTable gsub=null;

  Map lookups;

  if ((lookups=constructLookups()) != null) {

    List subtables;

    if ((subtables=constructGSUBSubtables()) != null) {

      if ((lookups.size() > 0) && (subtables.size() > 0)) {

        gsub=new GlyphSubstitutionTable(gdef,lookups,subtables,processors);

      }

    }

  }

  resetATState();

  return gsub;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private List constructGSUBSubtables(){

  List<GlyphSubtable> subtables=new java.util.ArrayList();

  if (seSubtables != null) {

    for (    Object seSubtable : seSubtables) {

      Object[] stp=(Object[])seSubtable;

      GlyphSubtable st;

      if ((st=constructGSUBSubtable(stp)) != null) {

        subtables.add(st);

      }

    }

  }

  return subtables;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphSubtable constructGSUBSubtable(Object[] stp){

  GlyphSubtable st=null;

  assert (stp != null) && (stp.length == 8);

  Integer tt=(Integer)stp[0];

  Integer lt=(Integer)stp[1];

  Integer ln=(Integer)stp[2];

  Integer lf=(Integer)stp[3];

  Integer sn=(Integer)stp[4];

  Integer sf=(Integer)stp[5];

  GlyphCoverageTable coverage=(GlyphCoverageTable)stp[6];

  List entries=(List)stp[7];

  if (tt == GlyphTable.GLYPH_TABLE_TYPE_SUBSTITUTION) {

    int type=GSUBLookupType.getSubtableType(lt);

    String lid="lu" + ln;

    int sequence=sn;

    int flags=lf;

    int format=sf;

    st=GlyphSubstitutionTable.createSubtable(type,lid,sequence,flags,format,coverage,entries);

  }

  return st;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private Map constructLookups(){

  Map<GlyphTable.LookupSpec,List<String>> lookups=new java.util.LinkedHashMap();

  for (  Object o : seScripts.keySet()) {

    String st=(String)o;

    Object[] sp=(Object[])seScripts.get(st);

    if (sp != null) {

      assert sp.length == 3;

      Map<String,Object> languages=(Map)sp[2];

      if (sp[0] != null) {

        constructLookupsLanguage(lookups,st,(String)sp[0],languages);

      }

      if (sp[1] != null) {

        constructLookupsLanguages(lookups,st,(List)sp[1],languages);

      }

    }

  }

  return lookups;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void constructLookupsFeatures(Map lookups,String st,String lt,List<String> fids){

  for (  Object fid1 : fids) {

    String fid=(String)fid1;

    constructLookupsFeature(lookups,st,lt,fid);

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void constructLookupsFeature(Map lookups,String st,String lt,String fid){

  Object[] fp=(Object[])seFeatures.get(fid);

  if (fp != null) {

    assert fp.length == 2;

    String ft=(String)fp[0];

    List<String> lul=(List)fp[1];

    if ((ft != null) && (lul != null) && (lul.size() > 0)) {

      GlyphTable.LookupSpec ls=new GlyphTable.LookupSpec(st,lt,ft);

      lookups.put(ls,lul);

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void constructLookupsLanguages(Map lookups,String st,List<String> ll,Map<String,Object> languages){

  for (  Object aLl : ll) {

    String lt=(String)aLl;

    constructLookupsLanguage(lookups,st,lt,languages);

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void constructLookupsLanguage(Map lookups,String st,String lt,Map<String,Object> languages){

  Object[] lp=(Object[])languages.get(lt);

  if (lp != null) {

    assert lp.length == 2;

    if (lp[0] != null) {

      constructLookupsFeature(lookups,st,lt,(String)lp[0]);

    }

    if (lp[1] != null) {

      constructLookupsFeatures(lookups,st,lt,(List)lp[1]);

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void extractSESubState(int tableType,int lookupType,int lookupFlags,int lookupSequence,int subtableSequence,int subtableFormat){

  if (seEntries != null) {

    if ((tableType == GlyphTable.GLYPH_TABLE_TYPE_DEFINITION) || (seEntries.size() > 0)) {

      if (seSubtables != null) {

        Integer tt=tableType;

        Integer lt=lookupType;

        Integer ln=lookupSequence;

        Integer lf=lookupFlags;

        Integer sn=subtableSequence;

        Integer sf=subtableFormat;

        seSubtables.add(new Object[]{tt,lt,ln,lf,sn,sf,seMapping,seEntries});

      }

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void initATState(){

  seScripts=new java.util.LinkedHashMap();

  seLanguages=new java.util.LinkedHashMap();

  seFeatures=new java.util.LinkedHashMap();

  seSubtables=new java.util.ArrayList();

  resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void initATSubState(){

  seMapping=null;

  seEntries=new java.util.ArrayList();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Construct an <code>OTFAdvancedTypographicTableReader</code> instance.

 * @param otf parent font file reader (must be non-null)

 * @param in font file reader (must be non-null)

 */

public OTFAdvancedTypographicTableReader(OpenFont otf,FontFileReader in){

  assert otf != null;

  assert in != null;

  this.otf=otf;

  this.in=in;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Read all advanced typographic tables.

 * @throws AdvancedTypographicTableFormatException if ATT table has invalid format

 */

public void readAll() throws AdvancedTypographicTableFormatException {

  try {

    hongshuai();

    OFTableName tableTag=OFTableName.GDEF;

    initATState();

    OFDirTabEntry dirTab=otf.getDirectoryEntry(tableTag);

    if (gdef != null) {

      if (log.isDebugEnabled()) {

        log.debug(tableTag + ": ignoring duplicate table");

      }

    }

 else     if (dirTab != null) {

      otf.seekTab(in,tableTag,0);

      long version=in.readTTFULong();

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " version: " + (version / 65536)+ "."+ (version % 65536));

      }

      int cdo=in.readTTFUShort();

      int apo=in.readTTFUShort();

      int lco=in.readTTFUShort();

      int mao=in.readTTFUShort();

      int mgo;

      if (version >= 0x00010002) {

        mgo=in.readTTFUShort();

      }

 else {

        mgo=0;

      }

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " glyph class definition table offset: " + cdo);

        log.debug(tableTag + " attachment point list offset: " + apo);

        log.debug(tableTag + " ligature caret list offset: " + lco);

        log.debug(tableTag + " mark attachment class definition table offset: " + mao);

        log.debug(tableTag + " mark glyph set definitions table offset: " + mgo);

      }

      int seqno=0;

      long to=dirTab.getOffset();

      if (cdo != 0) {

        readGDEFClassDefTable(tableTag,seqno++,to + cdo);

      }

      if (apo != 0) {

        readGDEFAttachmentTable(tableTag,seqno++,to + apo);

      }

      if (lco != 0) {

        readGDEFLigatureCaretTable(tableTag,seqno++,to + lco);

      }

      if (mao != 0) {

        readGDEFMarkAttachmentTable(tableTag,seqno++,to + mao);

      }

      if (mgo != 0) {

        readGDEFMarkGlyphsTable(tableTag,seqno++,to + mgo);

      }

      GlyphDefinitionTable gdef;

      if ((gdef=constructGDEF()) != null) {

        this.gdef=gdef;

      }

    }

    readGSUB();

    readGPOS();

  }

 catch (  AdvancedTypographicTableFormatException e) {

    hongshuai();

    resetATState();

    gdef=null;

    gsub=null;

    gpos=null;

    throw e;

  }

catch (  IOException e) {

    hongshuai();

    resetATState();

    gdef=null;

    gsub=null;

    gpos=null;

    throw new AdvancedTypographicTableFormatException(e.getMessage(),e);

  }

 finally {

    hongshuai();

    seScripts=null;

    seLanguages=null;

    seFeatures=null;

    seSubtables=null;

    resetATSubState();

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readAlternateSubTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int ns=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " alternate substitution subtable format: " + subtableFormat+ " (mapped)");

    log.debug(tableTag + " alternate substitution coverage table offset: " + co);

    log.debug(tableTag + " alternate substitution alternate set count: " + ns);

  }

  seMapping=readCoverageTable(tableTag + " alternate substitution coverage",subtableOffset + co);

  int[] soa=new int[ns];

  for (int i=0, n=ns; i < n; i++) {

    soa[i]=in.readTTFUShort();

  }

  for (int i=0, n=ns; i < n; i++) {

    int so=soa[i];

    in.seekSet(subtableOffset + so);

    int ng=in.readTTFUShort();

    int[] ga=new int[ng];

    for (int j=0; j < ng; j++) {

      int gs=in.readTTFUShort();

      ga[j]=gs;

    }

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " alternate substitution alternate set[" + i+ "]: "+ toString(ga));

    }

    seEntries.add(ga);

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readAlternateSubTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readAlternateSubTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported alternate substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readChainedContextualPosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int nrs=in.readTTFUShort();

  int[] rsoa=new int[nrs];

  for (int i=0; i < nrs; i++) {

    rsoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " chained contextual positioning subtable format: " + subtableFormat+ " (glyphs)");

    log.debug(tableTag + " chained contextual positioning coverage table offset: " + co);

    log.debug(tableTag + " chained contextual positioning rule set count: " + nrs);

    for (int i=0; i < nrs; i++) {

      log.debug(tableTag + " chained contextual positioning rule set offset[" + i+ "]: "+ rsoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " chained contextual positioning coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[nrs];

  String header=null;

  for (int i=0; i < nrs; i++) {

    GlyphTable.RuleSet rs;

    int rso=rsoa[i];

    if (rso > 0) {

      in.seekSet(subtableOffset + rso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        GlyphTable.ChainedGlyphSequenceRule r;

        int ro=roa[j];

        if (ro > 0) {

          in.seekSet(subtableOffset + rso + ro);

          int nbg=in.readTTFUShort();

          int[] backtrackGlyphs=new int[nbg];

          for (int k=0, nk=backtrackGlyphs.length; k < nk; k++) {

            backtrackGlyphs[k]=in.readTTFUShort();

          }

          int nig=in.readTTFUShort();

          int[] glyphs=new int[nig - 1];

          for (int k=0, nk=glyphs.length; k < nk; k++) {

            glyphs[k]=in.readTTFUShort();

          }

          int nlg=in.readTTFUShort();

          int[] lookaheadGlyphs=new int[nlg];

          for (int k=0, nk=lookaheadGlyphs.length; k < nk; k++) {

            lookaheadGlyphs[k]=in.readTTFUShort();

          }

          int nl=in.readTTFUShort();

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual positioning lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.ChainedGlyphSequenceRule(lookups,nig,glyphs,backtrackGlyphs,lookaheadGlyphs);

        }

 else {

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readChainedContextualPosTableFormat2(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int bcdo=in.readTTFUShort();

  int icdo=in.readTTFUShort();

  int lcdo=in.readTTFUShort();

  int ngc=in.readTTFUShort();

  int[] csoa=new int[ngc];

  for (int i=0; i < ngc; i++) {

    csoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " chained contextual positioning subtable format: " + subtableFormat+ " (glyph classes)");

    log.debug(tableTag + " chained contextual positioning coverage table offset: " + co);

    log.debug(tableTag + " chained contextual positioning class set count: " + ngc);

    for (int i=0; i < ngc; i++) {

      log.debug(tableTag + " chained contextual positioning class set offset[" + i+ "]: "+ csoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " chained contextual positioning coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphClassTable bcdt;

  if (bcdo > 0) {

    bcdt=readClassDefTable(tableTag + " contextual positioning backtrack class definition",subtableOffset + bcdo);

  }

 else {

    bcdt=null;

  }

  GlyphClassTable icdt;

  if (icdo > 0) {

    icdt=readClassDefTable(tableTag + " contextual positioning input class definition",subtableOffset + icdo);

  }

 else {

    icdt=null;

  }

  GlyphClassTable lcdt;

  if (lcdo > 0) {

    lcdt=readClassDefTable(tableTag + " contextual positioning lookahead class definition",subtableOffset + lcdo);

  }

 else {

    lcdt=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[ngc];

  String header=null;

  for (int i=0; i < ngc; i++) {

    int cso=csoa[i];

    GlyphTable.RuleSet rs;

    if (cso > 0) {

      in.seekSet(subtableOffset + cso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        GlyphTable.ChainedClassSequenceRule r;

        int ro=roa[j];

        if (ro > 0) {

          in.seekSet(subtableOffset + cso + ro);

          int nbc=in.readTTFUShort();

          int[] backtrackClasses=new int[nbc];

          for (int k=0, nk=backtrackClasses.length; k < nk; k++) {

            backtrackClasses[k]=in.readTTFUShort();

          }

          int nic=in.readTTFUShort();

          int[] classes=new int[nic - 1];

          for (int k=0, nk=classes.length; k < nk; k++) {

            classes[k]=in.readTTFUShort();

          }

          int nlc=in.readTTFUShort();

          int[] lookaheadClasses=new int[nlc];

          for (int k=0, nk=lookaheadClasses.length; k < nk; k++) {

            lookaheadClasses[k]=in.readTTFUShort();

          }

          int nl=in.readTTFUShort();

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual positioning lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.ChainedClassSequenceRule(lookups,nic,classes,backtrackClasses,lookaheadClasses);

        }

 else {

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(icdt);

  seEntries.add(bcdt);

  seEntries.add(lcdt);

  seEntries.add(ngc);

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readChainedContextualPosTableFormat3(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int nbg=in.readTTFUShort();

  int[] bgcoa=new int[nbg];

  for (int i=0; i < nbg; i++) {

    bgcoa[i]=in.readTTFUShort();

  }

  int nig=in.readTTFUShort();

  int[] igcoa=new int[nig];

  for (int i=0; i < nig; i++) {

    igcoa[i]=in.readTTFUShort();

  }

  int nlg=in.readTTFUShort();

  int[] lgcoa=new int[nlg];

  for (int i=0; i < nlg; i++) {

    lgcoa[i]=in.readTTFUShort();

  }

  int nl=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " chained contextual positioning subtable format: " + subtableFormat+ " (glyph sets)");

    log.debug(tableTag + " chained contextual positioning backtrack glyph count: " + nbg);

    for (int i=0; i < nbg; i++) {

      log.debug(tableTag + " chained contextual positioning backtrack coverage table offset[" + i+ "]: "+ bgcoa[i]);

    }

    log.debug(tableTag + " chained contextual positioning input glyph count: " + nig);

    for (int i=0; i < nig; i++) {

      log.debug(tableTag + " chained contextual positioning input coverage table offset[" + i+ "]: "+ igcoa[i]);

    }

    log.debug(tableTag + " chained contextual positioning lookahead glyph count: " + nlg);

    for (int i=0; i < nlg; i++) {

      log.debug(tableTag + " chained contextual positioning lookahead coverage table offset[" + i+ "]: "+ lgcoa[i]);

    }

    log.debug(tableTag + " chained contextual positioning lookup count: " + nl);

  }

  GlyphCoverageTable[] bgca=new GlyphCoverageTable[nbg];

  for (int i=0; i < nbg; i++) {

    int bgco=bgcoa[i];

    GlyphCoverageTable bgct;

    if (bgco > 0) {

      bgct=readCoverageTable(tableTag + " chained contextual positioning backtrack coverage[" + i+ "]",subtableOffset + bgco);

    }

 else {

      bgct=null;

    }

    bgca[i]=bgct;

  }

  GlyphCoverageTable[] igca=new GlyphCoverageTable[nig];

  for (int i=0; i < nig; i++) {

    int igco=igcoa[i];

    GlyphCoverageTable igct;

    if (igco > 0) {

      igct=readCoverageTable(tableTag + " chained contextual positioning input coverage[" + i+ "]",subtableOffset + igco);

    }

 else {

      igct=null;

    }

    igca[i]=igct;

  }

  GlyphCoverageTable[] lgca=new GlyphCoverageTable[nlg];

  for (int i=0; i < nlg; i++) {

    int lgco=lgcoa[i];

    GlyphCoverageTable lgct;

    if (lgco > 0) {

      lgct=readCoverageTable(tableTag + " chained contextual positioning lookahead coverage[" + i+ "]",subtableOffset + lgco);

    }

 else {

      lgct=null;

    }

    lgca[i]=lgct;

  }

  String header=null;

  if (log.isDebugEnabled()) {

    header=tableTag + " chained contextual positioning lookups: ";

  }

  GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

  GlyphTable.Rule r=new GlyphTable.ChainedCoverageSequenceRule(lookups,nig,igca,bgca,lgca);

  GlyphTable.RuleSet rs=new GlyphTable.HomogeneousRuleSet(new GlyphTable.Rule[]{r});

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[]{rs};

  assert (igca != null) && (igca.length > 0);

  seMapping=igca[0];

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readChainedContextualPosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readChainedContextualPosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 2) {

    readChainedContextualPosTableFormat2(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 3) {

    readChainedContextualPosTableFormat3(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported chained contextual positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readChainedContextualSubTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int nrs=in.readTTFUShort();

  int[] rsoa=new int[nrs];

  for (int i=0; i < nrs; i++) {

    rsoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " chained contextual substitution format: " + subtableFormat+ " (glyphs)");

    log.debug(tableTag + " chained contextual substitution coverage table offset: " + co);

    log.debug(tableTag + " chained contextual substitution rule set count: " + nrs);

    for (int i=0; i < nrs; i++) {

      log.debug(tableTag + " chained contextual substitution rule set offset[" + i+ "]: "+ rsoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " chained contextual substitution coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[nrs];

  String header=null;

  for (int i=0; i < nrs; i++) {

    GlyphTable.RuleSet rs;

    int rso=rsoa[i];

    if (rso > 0) {

      in.seekSet(subtableOffset + rso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        GlyphTable.ChainedGlyphSequenceRule r;

        int ro=roa[j];

        if (ro > 0) {

          in.seekSet(subtableOffset + rso + ro);

          int nbg=in.readTTFUShort();

          int[] backtrackGlyphs=new int[nbg];

          for (int k=0, nk=backtrackGlyphs.length; k < nk; k++) {

            backtrackGlyphs[k]=in.readTTFUShort();

          }

          int nig=in.readTTFUShort();

          int[] glyphs=new int[nig - 1];

          for (int k=0, nk=glyphs.length; k < nk; k++) {

            glyphs[k]=in.readTTFUShort();

          }

          int nlg=in.readTTFUShort();

          int[] lookaheadGlyphs=new int[nlg];

          for (int k=0, nk=lookaheadGlyphs.length; k < nk; k++) {

            lookaheadGlyphs[k]=in.readTTFUShort();

          }

          int nl=in.readTTFUShort();

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual substitution lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.ChainedGlyphSequenceRule(lookups,nig,glyphs,backtrackGlyphs,lookaheadGlyphs);

        }

 else {

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readChainedContextualSubTableFormat2(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int bcdo=in.readTTFUShort();

  int icdo=in.readTTFUShort();

  int lcdo=in.readTTFUShort();

  int ngc=in.readTTFUShort();

  int[] csoa=new int[ngc];

  for (int i=0; i < ngc; i++) {

    csoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " chained contextual substitution format: " + subtableFormat+ " (glyph classes)");

    log.debug(tableTag + " chained contextual substitution coverage table offset: " + co);

    log.debug(tableTag + " chained contextual substitution class set count: " + ngc);

    for (int i=0; i < ngc; i++) {

      log.debug(tableTag + " chained contextual substitution class set offset[" + i+ "]: "+ csoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " chained contextual substitution coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphClassTable bcdt;

  if (bcdo > 0) {

    bcdt=readClassDefTable(tableTag + " contextual substitution backtrack class definition",subtableOffset + bcdo);

  }

 else {

    bcdt=null;

  }

  GlyphClassTable icdt;

  if (icdo > 0) {

    icdt=readClassDefTable(tableTag + " contextual substitution input class definition",subtableOffset + icdo);

  }

 else {

    icdt=null;

  }

  GlyphClassTable lcdt;

  if (lcdo > 0) {

    lcdt=readClassDefTable(tableTag + " contextual substitution lookahead class definition",subtableOffset + lcdo);

  }

 else {

    lcdt=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[ngc];

  String header=null;

  for (int i=0; i < ngc; i++) {

    int cso=csoa[i];

    GlyphTable.RuleSet rs;

    if (cso > 0) {

      in.seekSet(subtableOffset + cso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        int ro=roa[j];

        GlyphTable.ChainedClassSequenceRule r;

        if (ro > 0) {

          in.seekSet(subtableOffset + cso + ro);

          int nbc=in.readTTFUShort();

          int[] backtrackClasses=new int[nbc];

          for (int k=0, nk=backtrackClasses.length; k < nk; k++) {

            backtrackClasses[k]=in.readTTFUShort();

          }

          int nic=in.readTTFUShort();

          int[] classes=new int[nic - 1];

          for (int k=0, nk=classes.length; k < nk; k++) {

            classes[k]=in.readTTFUShort();

          }

          int nlc=in.readTTFUShort();

          int[] lookaheadClasses=new int[nlc];

          for (int k=0, nk=lookaheadClasses.length; k < nk; k++) {

            lookaheadClasses[k]=in.readTTFUShort();

          }

          int nl=in.readTTFUShort();

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual substitution lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.ChainedClassSequenceRule(lookups,nic,classes,backtrackClasses,lookaheadClasses);

        }

 else {

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(icdt);

  seEntries.add(bcdt);

  seEntries.add(lcdt);

  seEntries.add(ngc);

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readChainedContextualSubTableFormat3(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int nbg=in.readTTFUShort();

  int[] bgcoa=new int[nbg];

  for (int i=0; i < nbg; i++) {

    bgcoa[i]=in.readTTFUShort();

  }

  int nig=in.readTTFUShort();

  int[] igcoa=new int[nig];

  for (int i=0; i < nig; i++) {

    igcoa[i]=in.readTTFUShort();

  }

  int nlg=in.readTTFUShort();

  int[] lgcoa=new int[nlg];

  for (int i=0; i < nlg; i++) {

    lgcoa[i]=in.readTTFUShort();

  }

  int nl=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " chained contextual substitution format: " + subtableFormat+ " (glyph sets)");

    log.debug(tableTag + " chained contextual substitution backtrack glyph count: " + nbg);

    for (int i=0; i < nbg; i++) {

      log.debug(tableTag + " chained contextual substitution backtrack coverage table offset[" + i+ "]: "+ bgcoa[i]);

    }

    log.debug(tableTag + " chained contextual substitution input glyph count: " + nig);

    for (int i=0; i < nig; i++) {

      log.debug(tableTag + " chained contextual substitution input coverage table offset[" + i+ "]: "+ igcoa[i]);

    }

    log.debug(tableTag + " chained contextual substitution lookahead glyph count: " + nlg);

    for (int i=0; i < nlg; i++) {

      log.debug(tableTag + " chained contextual substitution lookahead coverage table offset[" + i+ "]: "+ lgcoa[i]);

    }

    log.debug(tableTag + " chained contextual substitution lookup count: " + nl);

  }

  GlyphCoverageTable[] bgca=new GlyphCoverageTable[nbg];

  for (int i=0; i < nbg; i++) {

    int bgco=bgcoa[i];

    GlyphCoverageTable bgct;

    if (bgco > 0) {

      bgct=readCoverageTable(tableTag + " chained contextual substitution backtrack coverage[" + i+ "]",subtableOffset + bgco);

    }

 else {

      bgct=null;

    }

    bgca[i]=bgct;

  }

  GlyphCoverageTable[] igca=new GlyphCoverageTable[nig];

  for (int i=0; i < nig; i++) {

    int igco=igcoa[i];

    GlyphCoverageTable igct;

    if (igco > 0) {

      igct=readCoverageTable(tableTag + " chained contextual substitution input coverage[" + i+ "]",subtableOffset + igco);

    }

 else {

      igct=null;

    }

    igca[i]=igct;

  }

  GlyphCoverageTable[] lgca=new GlyphCoverageTable[nlg];

  for (int i=0; i < nlg; i++) {

    int lgco=lgcoa[i];

    GlyphCoverageTable lgct;

    if (lgco > 0) {

      lgct=readCoverageTable(tableTag + " chained contextual substitution lookahead coverage[" + i+ "]",subtableOffset + lgco);

    }

 else {

      lgct=null;

    }

    lgca[i]=lgct;

  }

  String header=null;

  if (log.isDebugEnabled()) {

    header=tableTag + " chained contextual substitution lookups: ";

  }

  GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

  GlyphTable.Rule r=new GlyphTable.ChainedCoverageSequenceRule(lookups,nig,igca,bgca,lgca);

  GlyphTable.RuleSet rs=new GlyphTable.HomogeneousRuleSet(new GlyphTable.Rule[]{r});

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[]{rs};

  assert (igca != null) && (igca.length > 0);

  seMapping=igca[0];

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readChainedContextualSubTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readChainedContextualSubTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 2) {

    readChainedContextualSubTableFormat2(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 3) {

    readChainedContextualSubTableFormat3(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported chained contextual substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphClassTable readClassDefTableFormat1(String label,long tableOffset,int classFormat) throws IOException {

  List entries=new java.util.ArrayList();

  in.seekSet(tableOffset);

  in.skip(2);

  int sg=in.readTTFUShort();

  entries.add(sg);

  int ng=in.readTTFUShort();

  int[] ca=new int[ng];

  for (int i=0, n=ng; i < n; i++) {

    int gc=in.readTTFUShort();

    ca[i]=gc;

    entries.add(gc);

  }

  if (log.isDebugEnabled()) {

    log.debug(label + " glyph classes: " + toString(ca));

  }

  return GlyphClassTable.createClassTable(entries);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphClassTable readClassDefTableFormat2(String label,long tableOffset,int classFormat) throws IOException {

  List entries=new java.util.ArrayList();

  in.seekSet(tableOffset);

  in.skip(2);

  int nr=in.readTTFUShort();

  for (int i=0, n=nr; i < n; i++) {

    int s=in.readTTFUShort();

    int e=in.readTTFUShort();

    int m=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(label + " range[" + i+ "]: ["+ s+ ","+ e+ "]: "+ m);

    }

    entries.add(new GlyphClassTable.MappingRange(s,e,m));

  }

  return GlyphClassTable.createClassTable(entries);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphClassTable readClassDefTable(String label,long tableOffset) throws IOException {

  GlyphClassTable gct;

  long cp=in.getCurrentPos();

  in.seekSet(tableOffset);

  int cf=in.readTTFUShort();

  if (cf == 1) {

    gct=readClassDefTableFormat1(label,tableOffset,cf);

  }

 else   if (cf == 2) {

    gct=readClassDefTableFormat2(label,tableOffset,cf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported class definition table format: " + cf);

  }

  in.seekSet(cp);

  return gct;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Read the common layout tables (used by GSUB and GPOS).

 * @param tableTag tag of table being read

 * @param scriptList offset to script list from beginning of font file

 * @param featureList offset to feature list from beginning of font file

 * @param lookupList offset to lookup list from beginning of font file

 * @throws IOException In case of a I/O problem

 */

private void readCommonLayoutTables(OFTableName tableTag,long scriptList,long featureList,long lookupList) throws IOException {

  if (scriptList > 0) {

    readScriptList(tableTag,scriptList);

  }

  if (featureList > 0) {

    readFeatureList(tableTag,featureList);

  }

  if (lookupList > 0) {

    readLookupList(tableTag,lookupList);

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readContextualPosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int nrs=in.readTTFUShort();

  int[] rsoa=new int[nrs];

  for (int i=0; i < nrs; i++) {

    rsoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " contextual positioning subtable format: " + subtableFormat+ " (glyphs)");

    log.debug(tableTag + " contextual positioning coverage table offset: " + co);

    log.debug(tableTag + " contextual positioning rule set count: " + nrs);

    for (int i=0; i < nrs; i++) {

      log.debug(tableTag + " contextual positioning rule set offset[" + i+ "]: "+ rsoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " contextual positioning coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[nrs];

  String header=null;

  for (int i=0; i < nrs; i++) {

    GlyphTable.RuleSet rs;

    int rso=rsoa[i];

    if (rso > 0) {

      in.seekSet(subtableOffset + rso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        GlyphTable.GlyphSequenceRule r;

        int ro=roa[j];

        if (ro > 0) {

          in.seekSet(subtableOffset + rso + ro);

          int ng=in.readTTFUShort();

          int nl=in.readTTFUShort();

          int[] glyphs=new int[ng - 1];

          for (int k=0, nk=glyphs.length; k < nk; k++) {

            glyphs[k]=in.readTTFUShort();

          }

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual positioning lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.GlyphSequenceRule(lookups,ng,glyphs);

        }

 else {

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readContextualPosTableFormat2(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int cdo=in.readTTFUShort();

  int ngc=in.readTTFUShort();

  int[] csoa=new int[ngc];

  for (int i=0; i < ngc; i++) {

    csoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " contextual positioning subtable format: " + subtableFormat+ " (glyph classes)");

    log.debug(tableTag + " contextual positioning coverage table offset: " + co);

    log.debug(tableTag + " contextual positioning class set count: " + ngc);

    for (int i=0; i < ngc; i++) {

      log.debug(tableTag + " contextual positioning class set offset[" + i+ "]: "+ csoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " contextual positioning coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphClassTable cdt;

  if (cdo > 0) {

    cdt=readClassDefTable(tableTag + " contextual positioning class definition",subtableOffset + cdo);

  }

 else {

    cdt=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[ngc];

  String header=null;

  for (int i=0; i < ngc; i++) {

    int cso=csoa[i];

    GlyphTable.RuleSet rs;

    if (cso > 0) {

      in.seekSet(subtableOffset + cso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        int ro=roa[j];

        GlyphTable.ClassSequenceRule r;

        if (ro > 0) {

          in.seekSet(subtableOffset + cso + ro);

          int ng=in.readTTFUShort();

          int nl=in.readTTFUShort();

          int[] classes=new int[ng - 1];

          for (int k=0, nk=classes.length; k < nk; k++) {

            classes[k]=in.readTTFUShort();

          }

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual positioning lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.ClassSequenceRule(lookups,ng,classes);

        }

 else {

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(cdt);

  seEntries.add(ngc);

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readContextualPosTableFormat3(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int ng=in.readTTFUShort();

  int nl=in.readTTFUShort();

  int[] gcoa=new int[ng];

  for (int i=0; i < ng; i++) {

    gcoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " contextual positioning subtable format: " + subtableFormat+ " (glyph sets)");

    log.debug(tableTag + " contextual positioning glyph input sequence length count: " + ng);

    log.debug(tableTag + " contextual positioning lookup count: " + nl);

    for (int i=0; i < ng; i++) {

      log.debug(tableTag + " contextual positioning coverage table offset[" + i+ "]: "+ gcoa[i]);

    }

  }

  GlyphCoverageTable[] gca=new GlyphCoverageTable[ng];

  for (int i=0; i < ng; i++) {

    int gco=gcoa[i];

    GlyphCoverageTable gct;

    if (gco > 0) {

      gct=readCoverageTable(tableTag + " contextual positioning coverage[" + i+ "]",subtableOffset + gcoa[i]);

    }

 else {

      gct=null;

    }

    gca[i]=gct;

  }

  String header=null;

  if (log.isDebugEnabled()) {

    header=tableTag + " contextual positioning lookups: ";

  }

  GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

  GlyphTable.Rule r=new GlyphTable.CoverageSequenceRule(lookups,ng,gca);

  GlyphTable.RuleSet rs=new GlyphTable.HomogeneousRuleSet(new GlyphTable.Rule[]{r});

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[]{rs};

  assert (gca != null) && (gca.length > 0);

  seMapping=gca[0];

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readContextualPosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readContextualPosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 2) {

    readContextualPosTableFormat2(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 3) {

    readContextualPosTableFormat3(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported contextual positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readContextualSubTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int nrs=in.readTTFUShort();

  int[] rsoa=new int[nrs];

  for (int i=0; i < nrs; i++) {

    rsoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " contextual substitution format: " + subtableFormat+ " (glyphs)");

    log.debug(tableTag + " contextual substitution coverage table offset: " + co);

    log.debug(tableTag + " contextual substitution rule set count: " + nrs);

    for (int i=0; i < nrs; i++) {

      log.debug(tableTag + " contextual substitution rule set offset[" + i+ "]: "+ rsoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " contextual substitution coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[nrs];

  String header=null;

  for (int i=0; i < nrs; i++) {

    GlyphTable.RuleSet rs;

    int rso=rsoa[i];

    if (rso > 0) {

      in.seekSet(subtableOffset + rso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        GlyphTable.GlyphSequenceRule r;

        int ro=roa[j];

        if (ro > 0) {

          in.seekSet(subtableOffset + rso + ro);

          int ng=in.readTTFUShort();

          int nl=in.readTTFUShort();

          int[] glyphs=new int[ng - 1];

          for (int k=0, nk=glyphs.length; k < nk; k++) {

            glyphs[k]=in.readTTFUShort();

          }

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual substitution lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.GlyphSequenceRule(lookups,ng,glyphs);

        }

 else {

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readContextualSubTableFormat2(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int cdo=in.readTTFUShort();

  int ngc=in.readTTFUShort();

  int[] csoa=new int[ngc];

  for (int i=0; i < ngc; i++) {

    csoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " contextual substitution format: " + subtableFormat+ " (glyph classes)");

    log.debug(tableTag + " contextual substitution coverage table offset: " + co);

    log.debug(tableTag + " contextual substitution class set count: " + ngc);

    for (int i=0; i < ngc; i++) {

      log.debug(tableTag + " contextual substitution class set offset[" + i+ "]: "+ csoa[i]);

    }

  }

  GlyphCoverageTable ct;

  if (co > 0) {

    ct=readCoverageTable(tableTag + " contextual substitution coverage",subtableOffset + co);

  }

 else {

    ct=null;

  }

  GlyphClassTable cdt;

  if (cdo > 0) {

    cdt=readClassDefTable(tableTag + " contextual substitution class definition",subtableOffset + cdo);

  }

 else {

    cdt=null;

  }

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[ngc];

  String header=null;

  for (int i=0; i < ngc; i++) {

    int cso=csoa[i];

    GlyphTable.RuleSet rs;

    if (cso > 0) {

      in.seekSet(subtableOffset + cso);

      int nr=in.readTTFUShort();

      int[] roa=new int[nr];

      GlyphTable.Rule[] ra=new GlyphTable.Rule[nr];

      for (int j=0; j < nr; j++) {

        roa[j]=in.readTTFUShort();

      }

      for (int j=0; j < nr; j++) {

        int ro=roa[j];

        GlyphTable.ClassSequenceRule r;

        if (ro > 0) {

          in.seekSet(subtableOffset + cso + ro);

          int ng=in.readTTFUShort();

          int nl=in.readTTFUShort();

          int[] classes=new int[ng - 1];

          for (int k=0, nk=classes.length; k < nk; k++) {

            classes[k]=in.readTTFUShort();

          }

          if (log.isDebugEnabled()) {

            header=tableTag + " contextual substitution lookups @rule[" + i+ "]["+ j+ "]: ";

          }

          GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

          r=new GlyphTable.ClassSequenceRule(lookups,ng,classes);

        }

 else {

          assert ro > 0 : "unexpected null subclass rule offset";

          r=null;

        }

        ra[j]=r;

      }

      rs=new GlyphTable.HomogeneousRuleSet(ra);

    }

 else {

      rs=null;

    }

    rsa[i]=rs;

  }

  seMapping=ct;

  seEntries.add(cdt);

  seEntries.add(ngc);

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readContextualSubTableFormat3(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int ng=in.readTTFUShort();

  int nl=in.readTTFUShort();

  int[] gcoa=new int[ng];

  for (int i=0; i < ng; i++) {

    gcoa[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " contextual substitution format: " + subtableFormat+ " (glyph sets)");

    log.debug(tableTag + " contextual substitution glyph input sequence length count: " + ng);

    log.debug(tableTag + " contextual substitution lookup count: " + nl);

    for (int i=0; i < ng; i++) {

      log.debug(tableTag + " contextual substitution coverage table offset[" + i+ "]: "+ gcoa[i]);

    }

  }

  GlyphCoverageTable[] gca=new GlyphCoverageTable[ng];

  for (int i=0; i < ng; i++) {

    int gco=gcoa[i];

    GlyphCoverageTable gct;

    if (gco > 0) {

      gct=readCoverageTable(tableTag + " contextual substitution coverage[" + i+ "]",subtableOffset + gco);

    }

 else {

      gct=null;

    }

    gca[i]=gct;

  }

  String header=null;

  if (log.isDebugEnabled()) {

    header=tableTag + " contextual substitution lookups: ";

  }

  GlyphTable.RuleLookup[] lookups=readRuleLookups(nl,header);

  GlyphTable.Rule r=new GlyphTable.CoverageSequenceRule(lookups,ng,gca);

  GlyphTable.RuleSet rs=new GlyphTable.HomogeneousRuleSet(new GlyphTable.Rule[]{r});

  GlyphTable.RuleSet[] rsa=new GlyphTable.RuleSet[]{rs};

  assert (gca != null) && (gca.length > 0);

  seMapping=gca[0];

  seEntries.add(rsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readContextualSubTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readContextualSubTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 2) {

    readContextualSubTableFormat2(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 3) {

    readContextualSubTableFormat3(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported contextual substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphCoverageTable readCoverageTableFormat1(String label,long tableOffset,int coverageFormat) throws IOException {

  List entries=new java.util.ArrayList();

  in.seekSet(tableOffset);

  in.skip(2);

  int ng=in.readTTFUShort();

  int[] ga=new int[ng];

  for (int i=0, n=ng; i < n; i++) {

    int g=in.readTTFUShort();

    ga[i]=g;

    entries.add(g);

  }

  if (log.isDebugEnabled()) {

    log.debug(label + " glyphs: " + toString(ga));

  }

  return GlyphCoverageTable.createCoverageTable(entries);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphCoverageTable readCoverageTableFormat2(String label,long tableOffset,int coverageFormat) throws IOException {

  List entries=new java.util.ArrayList();

  in.seekSet(tableOffset);

  in.skip(2);

  int nr=in.readTTFUShort();

  for (int i=0, n=nr; i < n; i++) {

    int s=in.readTTFUShort();

    int e=in.readTTFUShort();

    int m=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(label + " range[" + i+ "]: ["+ s+ ","+ e+ "]: "+ m);

    }

    entries.add(new GlyphCoverageTable.MappingRange(s,e,m));

  }

  return GlyphCoverageTable.createCoverageTable(entries);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphCoverageTable readCoverageTable(String label,long tableOffset) throws IOException {

  GlyphCoverageTable gct;

  long cp=in.getCurrentPos();

  in.seekSet(tableOffset);

  int cf=in.readTTFUShort();

  if (cf == 1) {

    gct=readCoverageTableFormat1(label,tableOffset,cf);

  }

 else   if (cf == 2) {

    gct=readCoverageTableFormat2(label,tableOffset,cf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported coverage table format: " + cf);

  }

  in.seekSet(cp);

  return gct;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readCursivePosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int ec=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " cursive positioning subtable format: " + subtableFormat);

    log.debug(tableTag + " cursive positioning coverage table offset: " + co);

    log.debug(tableTag + " cursive positioning entry/exit count: " + ec);

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " cursive positioning coverage",subtableOffset + co);

  GlyphPositioningTable.Anchor[] aa=new GlyphPositioningTable.Anchor[ec * 2];

  for (int i=0, n=ec; i < n; i++) {

    int eno=in.readTTFUShort();

    int exo=in.readTTFUShort();

    GlyphPositioningTable.Anchor ena;

    if (eno > 0) {

      ena=readPosAnchor(subtableOffset + eno);

    }

 else {

      ena=null;

    }

    GlyphPositioningTable.Anchor exa;

    if (exo > 0) {

      exa=readPosAnchor(subtableOffset + exo);

    }

 else {

      exa=null;

    }

    aa[(i * 2) + 0]=ena;

    aa[(i * 2) + 1]=exa;

    if (log.isDebugEnabled()) {

      if (ena != null) {

        log.debug(tableTag + " cursive entry anchor [" + i+ "]: "+ ena);

      }

      if (exa != null) {

        log.debug(tableTag + " cursive exit anchor  [" + i+ "]: "+ exa);

      }

    }

  }

  seMapping=ct;

  seEntries.add(aa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readCursivePosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readCursivePosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported cursive positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readExtensionPosTableFormat1(int lookupType,int lookupFlags,int lookupSequence,int subtableSequence,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int lt=in.readTTFUShort();

  long eo=in.readTTFULong();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " extension positioning subtable format: " + subtableFormat);

    log.debug(tableTag + " extension positioning lookup type: " + lt);

    log.debug(tableTag + " extension positioning lookup table offset: " + eo);

  }

  readGPOSSubtable(lt,lookupFlags,lookupSequence,subtableSequence,subtableOffset + eo);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readExtensionPosTable(int lookupType,int lookupFlags,int lookupSequence,int subtableSequence,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readExtensionPosTableFormat1(lookupType,lookupFlags,lookupSequence,subtableSequence,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported extension positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readExtensionSubTableFormat1(int lookupType,int lookupFlags,int lookupSequence,int subtableSequence,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int lt=in.readTTFUShort();

  long eo=in.readTTFULong();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " extension substitution subtable format: " + subtableFormat);

    log.debug(tableTag + " extension substitution lookup type: " + lt);

    log.debug(tableTag + " extension substitution lookup table offset: " + eo);

  }

  readGSUBSubtable(lt,lookupFlags,lookupSequence,subtableSequence,subtableOffset + eo);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readExtensionSubTable(int lookupType,int lookupFlags,int lookupSequence,int subtableSequence,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readExtensionSubTableFormat1(lookupType,lookupFlags,lookupSequence,subtableSequence,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported extension substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readFeatureList(OFTableName tableTag,long featureList) throws IOException {

  in.seekSet(featureList);

  int nf=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " feature list record count: " + nf);

  }

  if (nf > 0) {

    String[] fta=new String[nf];

    int[] foa=new int[nf];

    for (int i=0, n=nf; i < n; i++) {

      String ft=in.readTTFString(4);

      int fo=in.readTTFUShort();

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " feature tag: " + ft);

        log.debug(tableTag + " feature table offset: " + fo);

      }

      fta[i]=ft;

      foa[i]=fo;

    }

    for (int i=0, n=nf; i < n; i++) {

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " feature index: " + i);

      }

      readFeatureTable(tableTag,featureList + foa[i],fta[i],i);

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readFeatureTable(OFTableName tableTag,long featureTable,String featureTag,int featureIndex) throws IOException {

  in.seekSet(featureTable);

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " feature table: " + featureTag);

  }

  int po=in.readTTFUShort();

  int nl=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " feature table parameters offset: " + po);

    log.debug(tableTag + " feature table lookup list index count: " + nl);

  }

  List lul=new java.util.ArrayList();

  for (int i=0; i < nl; i++) {

    int li=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " feature table lookup index: " + li);

    }

    lul.add("lu" + li);

  }

  seFeatures.put("f" + featureIndex,new Object[]{featureTag,lul});

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGDEFAttachmentTable(OFTableName tableTag,int lookupSequence,long subtableOffset) throws IOException {

  initATSubState();

  in.seekSet(subtableOffset);

  int co=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " attachment point coverage table offset: " + co);

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " attachment point coverage",subtableOffset + co);

  seMapping=ct;

  extractSESubState(GlyphTable.GLYPH_TABLE_TYPE_DEFINITION,GDEFLookupType.ATTACHMENT_POINT,0,lookupSequence,0,1);

  resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGDEFClassDefTable(OFTableName tableTag,int lookupSequence,long subtableOffset) throws IOException {

  initATSubState();

  in.seekSet(subtableOffset);

  GlyphClassTable ct=readClassDefTable(tableTag + " glyph class definition table",subtableOffset);

  seMapping=ct;

  extractSESubState(GlyphTable.GLYPH_TABLE_TYPE_DEFINITION,GDEFLookupType.GLYPH_CLASS,0,lookupSequence,0,1);

  resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGDEFLigatureCaretTable(OFTableName tableTag,int lookupSequence,long subtableOffset) throws IOException {

  initATSubState();

  in.seekSet(subtableOffset);

  int co=in.readTTFUShort();

  int nl=in.readTTFUShort();

  int[] lgto=new int[nl];

  for (int i=0; i < nl; i++) {

    lgto[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " ligature caret coverage table offset: " + co);

    log.debug(tableTag + " ligature caret ligature glyph count: " + nl);

    for (int i=0; i < nl; i++) {

      log.debug(tableTag + " ligature glyph table offset[" + i+ "]: "+ lgto[i]);

    }

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " ligature caret coverage",subtableOffset + co);

  seMapping=ct;

  extractSESubState(GlyphTable.GLYPH_TABLE_TYPE_DEFINITION,GDEFLookupType.LIGATURE_CARET,0,lookupSequence,0,1);

  resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGDEFMarkAttachmentTable(OFTableName tableTag,int lookupSequence,long subtableOffset) throws IOException {

  initATSubState();

  in.seekSet(subtableOffset);

  GlyphClassTable ct=readClassDefTable(tableTag + " glyph class definition table",subtableOffset);

  seMapping=ct;

  extractSESubState(GlyphTable.GLYPH_TABLE_TYPE_DEFINITION,GDEFLookupType.MARK_ATTACHMENT,0,lookupSequence,0,1);

  resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGDEFMarkGlyphsTableFormat1(OFTableName tableTag,int lookupSequence,long subtableOffset,int subtableFormat) throws IOException {

  initATSubState();

  in.seekSet(subtableOffset);

  in.skip(2);

  int nmc=in.readTTFUShort();

  long[] mso=new long[nmc];

  for (int i=0; i < nmc; i++) {

    mso[i]=in.readTTFULong();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark set subtable format: " + subtableFormat+ " (glyph sets)");

    log.debug(tableTag + " mark set class count: " + nmc);

    for (int i=0; i < nmc; i++) {

      log.debug(tableTag + " mark set coverage table offset[" + i+ "]: "+ mso[i]);

    }

  }

  GlyphCoverageTable[] msca=new GlyphCoverageTable[nmc];

  for (int i=0; i < nmc; i++) {

    msca[i]=readCoverageTable(tableTag + " mark set coverage[" + i+ "]",subtableOffset + mso[i]);

  }

  GlyphClassTable ct=GlyphClassTable.createClassTable(Arrays.asList(msca));

  seMapping=ct;

  extractSESubState(GlyphTable.GLYPH_TABLE_TYPE_DEFINITION,GDEFLookupType.MARK_ATTACHMENT,0,lookupSequence,0,1);

  resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGDEFMarkGlyphsTable(OFTableName tableTag,int lookupSequence,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readGDEFMarkGlyphsTableFormat1(tableTag,lookupSequence,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported mark glyph sets subtable format: " + sf);

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Read the GPOS table.

 * @throws IOException In case of a I/O problem

 */

private void readGPOS() throws IOException {

  OFTableName tableTag=OFTableName.GPOS;

  initATState();

  OFDirTabEntry dirTab=otf.getDirectoryEntry(tableTag);

  if (gpos != null) {

    if (log.isDebugEnabled()) {

      log.debug(tableTag + ": ignoring duplicate table");

    }

  }

 else   if (dirTab != null) {

    otf.seekTab(in,tableTag,0);

    int version=in.readTTFLong();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " version: " + (version / 65536)+ "."+ (version % 65536));

    }

    int slo=in.readTTFUShort();

    int flo=in.readTTFUShort();

    int llo=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " script list offset: " + slo);

      log.debug(tableTag + " feature list offset: " + flo);

      log.debug(tableTag + " lookup list offset: " + llo);

    }

    long to=dirTab.getOffset();

    readCommonLayoutTables(tableTag,to + slo,to + flo,to + llo);

    GlyphPositioningTable gpos;

    if ((gpos=constructGPOS()) != null) {

      this.gpos=gpos;

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGPOSSubtable(int lookupType,int lookupFlags,int lookupSequence,int subtableSequence,long subtableOffset) throws IOException {

  initATSubState();

  int subtableFormat=-1;

switch (lookupType) {

case GPOSLookupType.SINGLE:

    subtableFormat=readSinglePosTable(lookupType,lookupFlags,subtableOffset);

  break;

case GPOSLookupType.PAIR:

subtableFormat=readPairPosTable(lookupType,lookupFlags,subtableOffset);

break;

case GPOSLookupType.CURSIVE:

subtableFormat=readCursivePosTable(lookupType,lookupFlags,subtableOffset);

break;

case GPOSLookupType.MARK_TO_BASE:

subtableFormat=readMarkToBasePosTable(lookupType,lookupFlags,subtableOffset);

break;

case GPOSLookupType.MARK_TO_LIGATURE:

subtableFormat=readMarkToLigaturePosTable(lookupType,lookupFlags,subtableOffset);

break;

case GPOSLookupType.MARK_TO_MARK:

subtableFormat=readMarkToMarkPosTable(lookupType,lookupFlags,subtableOffset);

break;

case GPOSLookupType.CONTEXTUAL:

subtableFormat=readContextualPosTable(lookupType,lookupFlags,subtableOffset);

break;

case GPOSLookupType.CHAINED_CONTEXTUAL:

subtableFormat=readChainedContextualPosTable(lookupType,lookupFlags,subtableOffset);

break;

case GPOSLookupType.EXTENSION:

subtableFormat=readExtensionPosTable(lookupType,lookupFlags,lookupSequence,subtableSequence,subtableOffset);

break;

default :

break;

}

extractSESubState(GlyphTable.GLYPH_TABLE_TYPE_POSITIONING,lookupType,lookupFlags,lookupSequence,subtableSequence,subtableFormat);

resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

/** 

 * Read the GSUB table.

 * @throws IOException In case of a I/O problem

 */

private void readGSUB() throws IOException {

  OFTableName tableTag=OFTableName.GSUB;

  initATState();

  OFDirTabEntry dirTab=otf.getDirectoryEntry(tableTag);

  if (gpos != null) {

    if (log.isDebugEnabled()) {

      log.debug(tableTag + ": ignoring duplicate table");

    }

  }

 else   if (dirTab != null) {

    otf.seekTab(in,tableTag,0);

    int version=in.readTTFLong();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " version: " + (version / 65536)+ "."+ (version % 65536));

    }

    int slo=in.readTTFUShort();

    int flo=in.readTTFUShort();

    int llo=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " script list offset: " + slo);

      log.debug(tableTag + " feature list offset: " + flo);

      log.debug(tableTag + " lookup list offset: " + llo);

    }

    long to=dirTab.getOffset();

    readCommonLayoutTables(tableTag,to + slo,to + flo,to + llo);

    GlyphSubstitutionTable gsub;

    if ((gsub=constructGSUB()) != null) {

      this.gsub=gsub;

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readGSUBSubtable(int lookupType,int lookupFlags,int lookupSequence,int subtableSequence,long subtableOffset) throws IOException {

  initATSubState();

  int subtableFormat=-1;

switch (lookupType) {

case GSUBLookupType.SINGLE:

    subtableFormat=readSingleSubTable(lookupType,lookupFlags,subtableOffset);

  break;

case GSUBLookupType.MULTIPLE:

subtableFormat=readMultipleSubTable(lookupType,lookupFlags,subtableOffset);

break;

case GSUBLookupType.ALTERNATE:

subtableFormat=readAlternateSubTable(lookupType,lookupFlags,subtableOffset);

break;

case GSUBLookupType.LIGATURE:

subtableFormat=readLigatureSubTable(lookupType,lookupFlags,subtableOffset);

break;

case GSUBLookupType.CONTEXTUAL:

subtableFormat=readContextualSubTable(lookupType,lookupFlags,subtableOffset);

break;

case GSUBLookupType.CHAINED_CONTEXTUAL:

subtableFormat=readChainedContextualSubTable(lookupType,lookupFlags,subtableOffset);

break;

case GSUBLookupType.REVERSE_CHAINED_SINGLE:

subtableFormat=readReverseChainedSingleSubTable(lookupType,lookupFlags,subtableOffset);

break;

case GSUBLookupType.EXTENSION:

subtableFormat=readExtensionSubTable(lookupType,lookupFlags,lookupSequence,subtableSequence,subtableOffset);

break;

default :

break;

}

extractSESubState(GlyphTable.GLYPH_TABLE_TYPE_SUBSTITUTION,lookupType,lookupFlags,lookupSequence,subtableSequence,subtableFormat);

resetATSubState();

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readLangSysTable(OFTableName tableTag,long langSysTable,String langSysTag) throws IOException {

  in.seekSet(langSysTable);

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " lang sys table: " + langSysTag);

  }

  int lo=in.readTTFUShort();

  int rf=in.readTTFUShort();

  String rfi;

  if (rf != 65535) {

    rfi="f" + rf;

  }

 else {

    rfi=null;

  }

  int nf=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " lang sys table reorder table: " + lo);

    log.debug(tableTag + " lang sys table required feature index: " + rf);

    log.debug(tableTag + " lang sys table non-required feature count: " + nf);

  }

  List fl=new java.util.ArrayList();

  for (int i=0; i < nf; i++) {

    int fi=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " lang sys table non-required feature index: " + fi);

    }

    fl.add("f" + fi);

  }

  if (seLanguages == null) {

    seLanguages=new java.util.LinkedHashMap();

  }

  seLanguages.put(langSysTag,new Object[]{rfi,fl});

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readLigatureSubTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int ns=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " ligature substitution subtable format: " + subtableFormat+ " (mapped)");

    log.debug(tableTag + " ligature substitution coverage table offset: " + co);

    log.debug(tableTag + " ligature substitution ligature set count: " + ns);

  }

  seMapping=readCoverageTable(tableTag + " ligature substitution coverage",subtableOffset + co);

  int[] soa=new int[ns];

  for (int i=0, n=ns; i < n; i++) {

    soa[i]=in.readTTFUShort();

  }

  for (int i=0, n=ns; i < n; i++) {

    int so=soa[i];

    in.seekSet(subtableOffset + so);

    int nl=in.readTTFUShort();

    int[] loa=new int[nl];

    for (int j=0; j < nl; j++) {

      loa[j]=in.readTTFUShort();

    }

    List ligs=new java.util.ArrayList();

    for (int j=0; j < nl; j++) {

      int lo=loa[j];

      in.seekSet(subtableOffset + so + lo);

      int lg=in.readTTFUShort();

      int nc=in.readTTFUShort();

      int[] ca=new int[nc - 1];

      for (int k=0; k < nc - 1; k++) {

        ca[k]=in.readTTFUShort();

      }

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " ligature substitution ligature set[" + i+ "]: ligature("+ lg+ "), components: "+ toString(ca));

      }

      ligs.add(new GlyphSubstitutionTable.Ligature(lg,ca));

    }

    seEntries.add(new GlyphSubstitutionTable.LigatureSet(ligs));

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readLigatureSubTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readLigatureSubTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported ligature substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readLookupList(OFTableName tableTag,long lookupList) throws IOException {

  in.seekSet(lookupList);

  int nl=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " lookup list record count: " + nl);

  }

  if (nl > 0) {

    int[] loa=new int[nl];

    for (int i=0, n=nl; i < n; i++) {

      int lo=in.readTTFUShort();

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " lookup table offset: " + lo);

      }

      loa[i]=lo;

    }

    for (int i=0, n=nl; i < n; i++) {

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " lookup index: " + i);

      }

      readLookupTable(tableTag,i,lookupList + loa[i]);

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readLookupTable(OFTableName tableTag,int lookupSequence,long lookupTable) throws IOException {

  boolean isGSUB=tableTag.equals(OFTableName.GSUB);

  boolean isGPOS=tableTag.equals(OFTableName.GPOS);

  in.seekSet(lookupTable);

  int lt=in.readTTFUShort();

  int lf=in.readTTFUShort();

  int ns=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    String lts;

    if (isGSUB) {

      lts=GSUBLookupType.toString(lt);

    }

 else     if (isGPOS) {

      lts=GPOSLookupType.toString(lt);

    }

 else {

      lts="?";

    }

    log.debug(tableTag + " lookup table type: " + lt+ " ("+ lts+ ")");

    log.debug(tableTag + " lookup table flags: " + lf+ " ("+ LookupFlag.toString(lf)+ ")");

    log.debug(tableTag + " lookup table subtable count: " + ns);

  }

  int[] soa=new int[ns];

  for (int i=0; i < ns; i++) {

    int so=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " lookup table subtable offset: " + so);

    }

    soa[i]=so;

  }

  if ((lf & LookupFlag.USE_MARK_FILTERING_SET) != 0) {

    int fs=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " lookup table mark filter set: " + fs);

    }

  }

  for (int i=0; i < ns; i++) {

    int so=soa[i];

    if (isGSUB) {

      readGSUBSubtable(lt,lf,lookupSequence,i,lookupTable + so);

    }

 else     if (isGPOS) {

      readGPOSSubtable(lt,lf,lookupSequence,i,lookupTable + so);

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readMarkToBasePosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int mco=in.readTTFUShort();

  int bco=in.readTTFUShort();

  int nmc=in.readTTFUShort();

  int mao=in.readTTFUShort();

  int bao=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-base positioning subtable format: " + subtableFormat);

    log.debug(tableTag + " mark-to-base positioning mark coverage table offset: " + mco);

    log.debug(tableTag + " mark-to-base positioning base coverage table offset: " + bco);

    log.debug(tableTag + " mark-to-base positioning mark class count: " + nmc);

    log.debug(tableTag + " mark-to-base positioning mark array offset: " + mao);

    log.debug(tableTag + " mark-to-base positioning base array offset: " + bao);

  }

  GlyphCoverageTable mct=readCoverageTable(tableTag + " mark-to-base positioning mark coverage",subtableOffset + mco);

  GlyphCoverageTable bct=readCoverageTable(tableTag + " mark-to-base positioning base coverage",subtableOffset + bco);

  in.seekSet(subtableOffset + mao);

  int nm=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-base positioning mark count: " + nm);

  }

  GlyphPositioningTable.MarkAnchor[] maa=new GlyphPositioningTable.MarkAnchor[nm];

  for (int i=0; i < nm; i++) {

    int mc=in.readTTFUShort();

    int ao=in.readTTFUShort();

    GlyphPositioningTable.Anchor a;

    if (ao > 0) {

      a=readPosAnchor(subtableOffset + mao + ao);

    }

 else {

      a=null;

    }

    GlyphPositioningTable.MarkAnchor ma;

    if (a != null) {

      ma=new GlyphPositioningTable.MarkAnchor(mc,a);

    }

 else {

      ma=null;

    }

    maa[i]=ma;

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " mark-to-base positioning mark anchor[" + i+ "]: "+ ma);

    }

  }

  in.seekSet(subtableOffset + bao);

  int nb=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-base positioning base count: " + nb);

  }

  GlyphPositioningTable.Anchor[][] bam=new GlyphPositioningTable.Anchor[nb][nmc];

  for (int i=0; i < nb; i++) {

    for (int j=0; j < nmc; j++) {

      int ao=in.readTTFUShort();

      GlyphPositioningTable.Anchor a;

      if (ao > 0) {

        a=readPosAnchor(subtableOffset + bao + ao);

      }

 else {

        a=null;

      }

      bam[i][j]=a;

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " mark-to-base positioning base anchor[" + i+ "]["+ j+ "]: "+ a);

      }

    }

  }

  seMapping=mct;

  seEntries.add(bct);

  seEntries.add(nmc);

  seEntries.add(maa);

  seEntries.add(bam);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readMarkToBasePosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readMarkToBasePosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported mark-to-base positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readMarkToLigaturePosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int mco=in.readTTFUShort();

  int lco=in.readTTFUShort();

  int nmc=in.readTTFUShort();

  int mao=in.readTTFUShort();

  int lao=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-ligature positioning subtable format: " + subtableFormat);

    log.debug(tableTag + " mark-to-ligature positioning mark coverage table offset: " + mco);

    log.debug(tableTag + " mark-to-ligature positioning ligature coverage table offset: " + lco);

    log.debug(tableTag + " mark-to-ligature positioning mark class count: " + nmc);

    log.debug(tableTag + " mark-to-ligature positioning mark array offset: " + mao);

    log.debug(tableTag + " mark-to-ligature positioning ligature array offset: " + lao);

  }

  GlyphCoverageTable mct=readCoverageTable(tableTag + " mark-to-ligature positioning mark coverage",subtableOffset + mco);

  GlyphCoverageTable lct=readCoverageTable(tableTag + " mark-to-ligature positioning ligature coverage",subtableOffset + lco);

  in.seekSet(subtableOffset + mao);

  int nm=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-ligature positioning mark count: " + nm);

  }

  GlyphPositioningTable.MarkAnchor[] maa=new GlyphPositioningTable.MarkAnchor[nm];

  for (int i=0; i < nm; i++) {

    int mc=in.readTTFUShort();

    int ao=in.readTTFUShort();

    GlyphPositioningTable.Anchor a;

    if (ao > 0) {

      a=readPosAnchor(subtableOffset + mao + ao);

    }

 else {

      a=null;

    }

    GlyphPositioningTable.MarkAnchor ma;

    if (a != null) {

      ma=new GlyphPositioningTable.MarkAnchor(mc,a);

    }

 else {

      ma=null;

    }

    maa[i]=ma;

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " mark-to-ligature positioning mark anchor[" + i+ "]: "+ ma);

    }

  }

  in.seekSet(subtableOffset + lao);

  int nl=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-ligature positioning ligature count: " + nl);

  }

  int[] laoa=new int[nl];

  for (int i=0; i < nl; i++) {

    laoa[i]=in.readTTFUShort();

  }

  int mxc=0;

  for (int i=0; i < nl; i++) {

    int lato=laoa[i];

    in.seekSet(subtableOffset + lao + lato);

    int cc=in.readTTFUShort();

    if (cc > mxc) {

      mxc=cc;

    }

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-ligature positioning maximum component count: " + mxc);

  }

  GlyphPositioningTable.Anchor[][][] lam=new GlyphPositioningTable.Anchor[nl][][];

  for (int i=0; i < nl; i++) {

    int lato=laoa[i];

    in.seekSet(subtableOffset + lao + lato);

    int cc=in.readTTFUShort();

    GlyphPositioningTable.Anchor[][] lcm=new GlyphPositioningTable.Anchor[cc][nmc];

    for (int j=0; j < cc; j++) {

      for (int k=0; k < nmc; k++) {

        int ao=in.readTTFUShort();

        GlyphPositioningTable.Anchor a;

        if (ao > 0) {

          a=readPosAnchor(subtableOffset + lao + lato+ ao);

        }

 else {

          a=null;

        }

        lcm[j][k]=a;

        if (log.isDebugEnabled()) {

          log.debug(tableTag + " mark-to-ligature positioning ligature anchor[" + i+ "]["+ j+ "]["+ k+ "]: "+ a);

        }

      }

    }

    lam[i]=lcm;

  }

  seMapping=mct;

  seEntries.add(lct);

  seEntries.add(nmc);

  seEntries.add(mxc);

  seEntries.add(maa);

  seEntries.add(lam);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readMarkToLigaturePosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readMarkToLigaturePosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported mark-to-ligature positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readMarkToMarkPosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int m1co=in.readTTFUShort();

  int m2co=in.readTTFUShort();

  int nmc=in.readTTFUShort();

  int m1ao=in.readTTFUShort();

  int m2ao=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-mark positioning subtable format: " + subtableFormat);

    log.debug(tableTag + " mark-to-mark positioning mark #1 coverage table offset: " + m1co);

    log.debug(tableTag + " mark-to-mark positioning mark #2 coverage table offset: " + m2co);

    log.debug(tableTag + " mark-to-mark positioning mark class count: " + nmc);

    log.debug(tableTag + " mark-to-mark positioning mark #1 array offset: " + m1ao);

    log.debug(tableTag + " mark-to-mark positioning mark #2 array offset: " + m2ao);

  }

  GlyphCoverageTable mct1=readCoverageTable(tableTag + " mark-to-mark positioning mark #1 coverage",subtableOffset + m1co);

  GlyphCoverageTable mct2=readCoverageTable(tableTag + " mark-to-mark positioning mark #2 coverage",subtableOffset + m2co);

  in.seekSet(subtableOffset + m1ao);

  int nm1=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-mark positioning mark #1 count: " + nm1);

  }

  GlyphPositioningTable.MarkAnchor[] maa=new GlyphPositioningTable.MarkAnchor[nm1];

  for (int i=0; i < nm1; i++) {

    int mc=in.readTTFUShort();

    int ao=in.readTTFUShort();

    GlyphPositioningTable.Anchor a;

    if (ao > 0) {

      a=readPosAnchor(subtableOffset + m1ao + ao);

    }

 else {

      a=null;

    }

    GlyphPositioningTable.MarkAnchor ma;

    if (a != null) {

      ma=new GlyphPositioningTable.MarkAnchor(mc,a);

    }

 else {

      ma=null;

    }

    maa[i]=ma;

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " mark-to-mark positioning mark #1 anchor[" + i+ "]: "+ ma);

    }

  }

  in.seekSet(subtableOffset + m2ao);

  int nm2=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " mark-to-mark positioning mark #2 count: " + nm2);

  }

  GlyphPositioningTable.Anchor[][] mam=new GlyphPositioningTable.Anchor[nm2][nmc];

  for (int i=0; i < nm2; i++) {

    for (int j=0; j < nmc; j++) {

      int ao=in.readTTFUShort();

      GlyphPositioningTable.Anchor a;

      if (ao > 0) {

        a=readPosAnchor(subtableOffset + m2ao + ao);

      }

 else {

        a=null;

      }

      mam[i][j]=a;

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " mark-to-mark positioning mark #2 anchor[" + i+ "]["+ j+ "]: "+ a);

      }

    }

  }

  seMapping=mct1;

  seEntries.add(mct2);

  seEntries.add(nmc);

  seEntries.add(maa);

  seEntries.add(mam);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readMarkToMarkPosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readMarkToMarkPosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported mark-to-mark positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readMultipleSubTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int ns=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " multiple substitution subtable format: " + subtableFormat+ " (mapped)");

    log.debug(tableTag + " multiple substitution coverage table offset: " + co);

    log.debug(tableTag + " multiple substitution sequence count: " + ns);

  }

  seMapping=readCoverageTable(tableTag + " multiple substitution coverage",subtableOffset + co);

  int[] soa=new int[ns];

  for (int i=0, n=ns; i < n; i++) {

    soa[i]=in.readTTFUShort();

  }

  int[][] gsa=new int[ns][];

  for (int i=0, n=ns; i < n; i++) {

    int so=soa[i];

    int[] ga;

    if (so > 0) {

      in.seekSet(subtableOffset + so);

      int ng=in.readTTFUShort();

      ga=new int[ng];

      for (int j=0; j < ng; j++) {

        ga[j]=in.readTTFUShort();

      }

    }

 else {

      ga=null;

    }

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " multiple substitution sequence[" + i+ "]: "+ toString(ga));

    }

    gsa[i]=ga;

  }

  seEntries.add(gsa);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readMultipleSubTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readMultipleSubTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported multiple substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readPairPosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int vf1=in.readTTFUShort();

  int vf2=in.readTTFUShort();

  int nps=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " pair positioning subtable format: " + subtableFormat+ " (glyphs)");

    log.debug(tableTag + " pair positioning coverage table offset: " + co);

    log.debug(tableTag + " pair positioning value format #1: " + vf1);

    log.debug(tableTag + " pair positioning value format #2: " + vf2);

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " pair positioning coverage",subtableOffset + co);

  GlyphPositioningTable.PairValues[][] pvm=new GlyphPositioningTable.PairValues[nps][];

  for (int i=0, n=nps; i < n; i++) {

    int pso=in.readTTFUShort();

    pvm[i]=readPosPairSetTable(subtableOffset,pso,vf1,vf2);

  }

  seMapping=ct;

  seEntries.add(pvm);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readPairPosTableFormat2(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int vf1=in.readTTFUShort();

  int vf2=in.readTTFUShort();

  int cd1o=in.readTTFUShort();

  int cd2o=in.readTTFUShort();

  int nc1=in.readTTFUShort();

  int nc2=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " pair positioning subtable format: " + subtableFormat+ " (glyph classes)");

    log.debug(tableTag + " pair positioning coverage table offset: " + co);

    log.debug(tableTag + " pair positioning value format #1: " + vf1);

    log.debug(tableTag + " pair positioning value format #2: " + vf2);

    log.debug(tableTag + " pair positioning class def table #1 offset: " + cd1o);

    log.debug(tableTag + " pair positioning class def table #2 offset: " + cd2o);

    log.debug(tableTag + " pair positioning class #1 count: " + nc1);

    log.debug(tableTag + " pair positioning class #2 count: " + nc2);

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " pair positioning coverage",subtableOffset + co);

  GlyphClassTable cdt1=readClassDefTable(tableTag + " pair positioning class definition #1",subtableOffset + cd1o);

  GlyphClassTable cdt2=readClassDefTable(tableTag + " pair positioning class definition #2",subtableOffset + cd2o);

  GlyphPositioningTable.PairValues[][] pvm=new GlyphPositioningTable.PairValues[nc1][nc2];

  for (int i=0; i < nc1; i++) {

    for (int j=0; j < nc2; j++) {

      GlyphPositioningTable.PairValues pv=readPosPairValues(subtableOffset,false,vf1,vf2);

      pvm[i][j]=pv;

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " pair set table value[" + i+ "]["+ j+ "]: "+ pv);

      }

    }

  }

  seMapping=ct;

  seEntries.add(cdt1);

  seEntries.add(cdt2);

  seEntries.add(nc1);

  seEntries.add(nc2);

  seEntries.add(pvm);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readPairPosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readPairPosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 2) {

    readPairPosTableFormat2(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported pair positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphPositioningTable.Anchor readPosAnchor(long anchorTableOffset) throws IOException {

  GlyphPositioningTable.Anchor a;

  long cp=in.getCurrentPos();

  in.seekSet(anchorTableOffset);

  int af=in.readTTFUShort();

  if (af == 1) {

    int x=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

    int y=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

    a=new GlyphPositioningTable.Anchor(x,y);

  }

 else   if (af == 2) {

    int x=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

    int y=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

    int ap=in.readTTFUShort();

    a=new GlyphPositioningTable.Anchor(x,y,ap);

  }

 else   if (af == 3) {

    int x=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

    int y=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

    int xdo=in.readTTFUShort();

    int ydo=in.readTTFUShort();

    GlyphPositioningTable.DeviceTable xd;

    if (xdo != 0) {

      xd=readPosDeviceTable(cp,xdo);

    }

 else {

      xd=null;

    }

    GlyphPositioningTable.DeviceTable yd;

    if (ydo != 0) {

      yd=readPosDeviceTable(cp,ydo);

    }

 else {

      yd=null;

    }

    a=new GlyphPositioningTable.Anchor(x,y,xd,yd);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported positioning anchor format: " + af);

  }

  in.seekSet(cp);

  return a;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphPositioningTable.DeviceTable readPosDeviceTable(long subtableOffset,long deviceTableOffset) throws IOException {

  long cp=in.getCurrentPos();

  in.seekSet(subtableOffset + deviceTableOffset);

  int ss=in.readTTFUShort();

  int es=in.readTTFUShort();

  int df=in.readTTFUShort();

  int s1;

  int m1;

  int dm;

  int dd;

  int s2;

  if (df == 1) {

    s1=14;

    m1=0x3;

    dm=1;

    dd=4;

    s2=2;

  }

 else   if (df == 2) {

    s1=12;

    m1=0xF;

    dm=7;

    dd=16;

    s2=4;

  }

 else   if (df == 3) {

    s1=8;

    m1=0xFF;

    dm=127;

    dd=256;

    s2=8;

  }

 else {

    log.debug("unsupported device table delta format: " + df + ", ignoring device table");

    return null;

  }

  int n=(es - ss) + 1;

  if (n < 0) {

    log.debug("invalid device table delta count: " + n + ", ignoring device table");

    return null;

  }

  int[] da=new int[n];

  for (int i=0; (i < n) && (s2 > 0); ) {

    int p=in.readTTFUShort();

    for (int j=0, k=16 / s2; j < k; j++) {

      int d=(p >> s1) & m1;

      if (d > dm) {

        d-=dd;

      }

      if (i < n) {

        da[i++]=d;

      }

 else {

        break;

      }

      p<<=s2;

    }

  }

  in.seekSet(cp);

  return new GlyphPositioningTable.DeviceTable(ss,es,da);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphPositioningTable.PairValues[] readPosPairSetTable(long subtableOffset,int pairSetTableOffset,int vf1,int vf2) throws IOException {

  String tableTag="GPOS";

  long cp=in.getCurrentPos();

  in.seekSet(subtableOffset + pairSetTableOffset);

  int npv=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " pair set table offset: " + pairSetTableOffset);

    log.debug(tableTag + " pair set table values count: " + npv);

  }

  GlyphPositioningTable.PairValues[] pva=new GlyphPositioningTable.PairValues[npv];

  for (int i=0, n=npv; i < n; i++) {

    GlyphPositioningTable.PairValues pv=readPosPairValues(subtableOffset,true,vf1,vf2);

    pva[i]=pv;

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " pair set table value[" + i+ "]: "+ pv);

    }

  }

  in.seekSet(cp);

  return pva;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphPositioningTable.PairValues readPosPairValues(long subtableOffset,boolean hasGlyph,int vf1,int vf2) throws IOException {

  int glyph;

  if (hasGlyph) {

    glyph=in.readTTFUShort();

  }

 else {

    glyph=0;

  }

  GlyphPositioningTable.Value v1;

  if (vf1 != 0) {

    v1=readPosValue(subtableOffset,vf1);

  }

 else {

    v1=null;

  }

  GlyphPositioningTable.Value v2;

  if (vf2 != 0) {

    v2=readPosValue(subtableOffset,vf2);

  }

 else {

    v2=null;

  }

  return new GlyphPositioningTable.PairValues(glyph,v1,v2);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphPositioningTable.Value readPosValue(long subtableOffset,int valueFormat) throws IOException {

  int xp;

  if ((valueFormat & GlyphPositioningTable.Value.X_PLACEMENT) != 0) {

    xp=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

  }

 else {

    xp=0;

  }

  int yp;

  if ((valueFormat & GlyphPositioningTable.Value.Y_PLACEMENT) != 0) {

    yp=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

  }

 else {

    yp=0;

  }

  int xa;

  if ((valueFormat & GlyphPositioningTable.Value.X_ADVANCE) != 0) {

    xa=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

  }

 else {

    xa=0;

  }

  int ya;

  if ((valueFormat & GlyphPositioningTable.Value.Y_ADVANCE) != 0) {

    ya=otf.convertTTFUnit2PDFUnit(in.readTTFShort());

  }

 else {

    ya=0;

  }

  GlyphPositioningTable.DeviceTable xpd;

  if ((valueFormat & GlyphPositioningTable.Value.X_PLACEMENT_DEVICE) != 0) {

    int xpdo=in.readTTFUShort();

    xpd=readPosDeviceTable(subtableOffset,xpdo);

  }

 else {

    xpd=null;

  }

  GlyphPositioningTable.DeviceTable ypd;

  if ((valueFormat & GlyphPositioningTable.Value.Y_PLACEMENT_DEVICE) != 0) {

    int ypdo=in.readTTFUShort();

    ypd=readPosDeviceTable(subtableOffset,ypdo);

  }

 else {

    ypd=null;

  }

  GlyphPositioningTable.DeviceTable xad;

  if ((valueFormat & GlyphPositioningTable.Value.X_ADVANCE_DEVICE) != 0) {

    int xado=in.readTTFUShort();

    xad=readPosDeviceTable(subtableOffset,xado);

  }

 else {

    xad=null;

  }

  GlyphPositioningTable.DeviceTable yad;

  if ((valueFormat & GlyphPositioningTable.Value.Y_ADVANCE_DEVICE) != 0) {

    int yado=in.readTTFUShort();

    yad=readPosDeviceTable(subtableOffset,yado);

  }

 else {

    yad=null;

  }

  return new GlyphPositioningTable.Value(xp,yp,xa,ya,xpd,ypd,xad,yad);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readReverseChainedSingleSubTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int nbg=in.readTTFUShort();

  int[] bgcoa=new int[nbg];

  for (int i=0; i < nbg; i++) {

    bgcoa[i]=in.readTTFUShort();

  }

  int nlg=in.readTTFUShort();

  int[] lgcoa=new int[nlg];

  for (int i=0; i < nlg; i++) {

    lgcoa[i]=in.readTTFUShort();

  }

  int ng=in.readTTFUShort();

  int[] glyphs=new int[ng];

  for (int i=0, n=ng; i < n; i++) {

    glyphs[i]=in.readTTFUShort();

  }

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " reverse chained contextual substitution format: " + subtableFormat);

    log.debug(tableTag + " reverse chained contextual substitution coverage table offset: " + co);

    log.debug(tableTag + " reverse chained contextual substitution backtrack glyph count: " + nbg);

    for (int i=0; i < nbg; i++) {

      log.debug(tableTag + " reverse chained contextual substitution backtrack coverage table offset[" + i+ "]: "+ bgcoa[i]);

    }

    log.debug(tableTag + " reverse chained contextual substitution lookahead glyph count: " + nlg);

    for (int i=0; i < nlg; i++) {

      log.debug(tableTag + " reverse chained contextual substitution lookahead coverage table offset[" + i+ "]: "+ lgcoa[i]);

    }

    log.debug(tableTag + " reverse chained contextual substitution glyphs: " + toString(glyphs));

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " reverse chained contextual substitution coverage",subtableOffset + co);

  GlyphCoverageTable[] bgca=new GlyphCoverageTable[nbg];

  for (int i=0; i < nbg; i++) {

    int bgco=bgcoa[i];

    GlyphCoverageTable bgct;

    if (bgco > 0) {

      bgct=readCoverageTable(tableTag + " reverse chained contextual substitution backtrack coverage[" + i+ "]",subtableOffset + bgco);

    }

 else {

      bgct=null;

    }

    bgca[i]=bgct;

  }

  GlyphCoverageTable[] lgca=new GlyphCoverageTable[nlg];

  for (int i=0; i < nlg; i++) {

    int lgco=lgcoa[i];

    GlyphCoverageTable lgct;

    if (lgco > 0) {

      lgct=readCoverageTable(tableTag + " reverse chained contextual substitution lookahead coverage[" + i+ "]",subtableOffset + lgco);

    }

 else {

      lgct=null;

    }

    lgca[i]=lgct;

  }

  seMapping=ct;

  seEntries.add(bgca);

  seEntries.add(lgca);

  seEntries.add(glyphs);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readReverseChainedSingleSubTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readReverseChainedSingleSubTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported reverse chained single substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private GlyphTable.RuleLookup[] readRuleLookups(int numLookups,String header) throws IOException {

  GlyphTable.RuleLookup[] la=new GlyphTable.RuleLookup[numLookups];

  for (int i=0, n=numLookups; i < n; i++) {

    int sequenceIndex=in.readTTFUShort();

    int lookupIndex=in.readTTFUShort();

    la[i]=new GlyphTable.RuleLookup(sequenceIndex,lookupIndex);

    if (log.isDebugEnabled() && (header != null)) {

      log.debug(header + "lookup[" + i+ "]: "+ la[i]);

    }

  }

  return la;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readScriptList(OFTableName tableTag,long scriptList) throws IOException {

  in.seekSet(scriptList);

  int ns=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " script list record count: " + ns);

  }

  if (ns > 0) {

    String[] sta=new String[ns];

    int[] soa=new int[ns];

    for (int i=0, n=ns; i < n; i++) {

      String st=in.readTTFString(4);

      int so=in.readTTFUShort();

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " script tag: " + st);

        log.debug(tableTag + " script table offset: " + so);

      }

      sta[i]=st;

      soa[i]=so;

    }

    for (int i=0, n=ns; i < n; i++) {

      seLanguages=null;

      readScriptTable(tableTag,scriptList + soa[i],sta[i]);

    }

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readScriptTable(OFTableName tableTag,long scriptTable,String scriptTag) throws IOException {

  in.seekSet(scriptTable);

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " script table: " + scriptTag);

  }

  int dl=in.readTTFUShort();

  String dt=defaultTag;

  if (dl > 0) {

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " default lang sys tag: " + dt);

      log.debug(tableTag + " default lang sys table offset: " + dl);

    }

  }

  int nl=in.readTTFUShort();

  List ll=new java.util.ArrayList();

  if (nl > 0) {

    String[] lta=new String[nl];

    int[] loa=new int[nl];

    for (int i=0, n=nl; i < n; i++) {

      String lt=in.readTTFString(4);

      int lo=in.readTTFUShort();

      if (log.isDebugEnabled()) {

        log.debug(tableTag + " lang sys tag: " + lt);

        log.debug(tableTag + " lang sys table offset: " + lo);

      }

      lta[i]=lt;

      loa[i]=lo;

      if (dl == lo) {

        dl=0;

        dt=lt;

      }

      ll.add(lt);

    }

    for (int i=0, n=nl; i < n; i++) {

      readLangSysTable(tableTag,scriptTable + loa[i],lta[i]);

    }

  }

  if (dl > 0) {

    readLangSysTable(tableTag,scriptTable + dl,dt);

  }

 else   if (dt != null) {

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " lang sys default: " + dt);

    }

  }

  seScripts.put(scriptTag,new Object[]{dt,ll,seLanguages});

  seLanguages=null;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readSinglePosTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int vf=in.readTTFUShort();

  GlyphPositioningTable.Value v=readPosValue(subtableOffset,vf);

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " single positioning subtable format: " + subtableFormat+ " (delta)");

    log.debug(tableTag + " single positioning coverage table offset: " + co);

    log.debug(tableTag + " single positioning value: " + v);

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " single positioning coverage",subtableOffset + co);

  seMapping=ct;

  seEntries.add(v);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readSinglePosTableFormat2(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GPOS";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int vf=in.readTTFUShort();

  int nv=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " single positioning subtable format: " + subtableFormat+ " (mapped)");

    log.debug(tableTag + " single positioning coverage table offset: " + co);

    log.debug(tableTag + " single positioning value count: " + nv);

  }

  GlyphCoverageTable ct=readCoverageTable(tableTag + " single positioning coverage",subtableOffset + co);

  GlyphPositioningTable.Value[] pva=new GlyphPositioningTable.Value[nv];

  for (int i=0, n=nv; i < n; i++) {

    GlyphPositioningTable.Value pv=readPosValue(subtableOffset,vf);

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " single positioning value[" + i+ "]: "+ pv);

    }

    pva[i]=pv;

  }

  seMapping=ct;

  seEntries.add(pva);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readSinglePosTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readSinglePosTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 2) {

    readSinglePosTableFormat2(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported single positioning subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readSingleSubTableFormat1(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int dg=in.readTTFShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " single substitution subtable format: " + subtableFormat+ " (delta)");

    log.debug(tableTag + " single substitution coverage table offset: " + co);

    log.debug(tableTag + " single substitution delta: " + dg);

  }

  seMapping=readCoverageTable(tableTag + " single substitution coverage",subtableOffset + co);

  seEntries.add(dg);

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void readSingleSubTableFormat2(int lookupType,int lookupFlags,long subtableOffset,int subtableFormat) throws IOException {

  String tableTag="GSUB";

  in.seekSet(subtableOffset);

  in.skip(2);

  int co=in.readTTFUShort();

  int ng=in.readTTFUShort();

  if (log.isDebugEnabled()) {

    log.debug(tableTag + " single substitution subtable format: " + subtableFormat+ " (mapped)");

    log.debug(tableTag + " single substitution coverage table offset: " + co);

    log.debug(tableTag + " single substitution glyph count: " + ng);

  }

  seMapping=readCoverageTable(tableTag + " single substitution coverage",subtableOffset + co);

  for (int i=0, n=ng; i < n; i++) {

    int gs=in.readTTFUShort();

    if (log.isDebugEnabled()) {

      log.debug(tableTag + " single substitution glyph[" + i+ "]: "+ gs);

    }

    seEntries.add(gs);

  }

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private int readSingleSubTable(int lookupType,int lookupFlags,long subtableOffset) throws IOException {

  in.seekSet(subtableOffset);

  int sf=in.readTTFUShort();

  if (sf == 1) {

    readSingleSubTableFormat1(lookupType,lookupFlags,subtableOffset,sf);

  }

 else   if (sf == 2) {

    readSingleSubTableFormat2(lookupType,lookupFlags,subtableOffset,sf);

  }

 else {

    throw new AdvancedTypographicTableFormatException("unsupported single substitution subtable format: " + sf);

  }

  return sf;

}

Location: OTFAdvancedTypographicTableReader.java

Content: 

private void resetATSubState(){

  seMapping=null;

  seEntries=null;

}

