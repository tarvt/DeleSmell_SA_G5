Location: Root.java

Content: 

/** 

 * Add a Destination object to this FO

 * @param destination the Destination object to add

 */

public void addDestination(Destination destination){

  if (destinationList == null) {

    destinationList=new java.util.ArrayList<Destination>();

  }

  destinationList.add(destination);

}

Location: Root.java

Content: 

/** 

 * Adds the specified page sequence.

 * @param pageSequence The page sequence to add

 */

public void addPageSequence(PageSequence pageSequence){

  pageSequences.add(pageSequence);

}

Location: Root.java

Content: 

/** 

 * Public accessor for the BookmarkTree object for this FO

 * @return the BookmarkTree object

 */

public BookmarkTree getBookmarkTree(){

  return bookmarkTree;

}

Location: Root.java

Content: 

/** 

 * {@inheritDoc} 

 */

public FOTreeBuilderContext getBuilderContext(){

  return this.builderContext;

}

Location: Root.java

Content: 

/** 

 * Returns the associated Declarations.

 * @return the Declarations instance

 */

public Declarations getDeclarations(){

  return this.declarations;

}

Location: Root.java

Content: 

/** 

 * Gets the last page number generated by the previous page-sequence

 * @return the last page number, 0 if no page sequences yet generated

 */

public int getEndingPageNumberOfPreviousSequence(){

  return endingPageNumberOfPreviousSequence;

}

Location: Root.java

Content: 

/** 

 * This method overrides the FONode version. The FONode version calls the method by the same name for the parent object. Since Root is at the top of the tree, it returns the actual FOEventHandler object. Thus, any FONode can use this chain to find which FOEventHandler it is being built for.

 * @return the FOEventHandler implementation that this Root is attached to

 */

public FOEventHandler getFOEventHandler(){

  return foEventHandler;

}

Location: Root.java

Content: 

/** 

 * Returns the last page sequence (current while parsing).

 * @return The last page sequence or null

 */

public PageSequence getLastPageSequence(){

  if (getPageSequenceCount() > 0) {

    return pageSequences.get(getPageSequenceCount() - 1);

  }

 else {

    return null;

  }

}

Location: Root.java

Content: 

public PageSequence getLastSeq(){

  return lastSeq;

}

Location: Root.java

Content: 

/** 

 * Returns the number of PageSequence instances.

 * @return the number of PageSequence instances

 */

public int getPageSequenceCount(){

  return pageSequences.size();

}

Location: Root.java

Content: 

/** 

 * Some properties, such as 'force-page-count', require a page-sequence to know about some properties of the next.

 * @param current the current PageSequence

 * @return succeeding PageSequence; null if none

 */

public PageSequence getSucceedingPageSequence(PageSequence current){

  int currentIndex=pageSequences.indexOf(current);

  if (currentIndex == -1) {

    return null;

  }

  if (currentIndex < (pageSequences.size() - 1)) {

    return pageSequences.get(currentIndex + 1);

  }

 else {

    return null;

  }

}

Location: Root.java

Content: 

/** 

 * Returns the total number of pages generated by FOP (May not equal endingPageNumberOfPreviousSequence due to initial-page-number property on fo:page-sequences.)

 * @return the last page number, 0 if no page sequences yet generated

 */

public int getTotalPagesGenerated(){

  return totalPagesGenerated;

}

Location: Root.java

Content: 

/** 

 * Notify additional pages generated to increase the totalPagesGenerated counter

 * @param lastPageNumber the last page number generated by the sequence

 * @param additionalPages the total pages generated by the sequence (for statistics)

 * @throws IllegalArgumentException for negative additional page counts

 */

public void notifyPageSequenceFinished(int lastPageNumber,int additionalPages) throws IllegalArgumentException {

  if (additionalPages >= 0) {

    totalPagesGenerated+=additionalPages;

    endingPageNumberOfPreviousSequence=lastPageNumber;

  }

 else {

    throw new IllegalArgumentException("Number of additional pages must be zero or greater.");

  }

}

Location: Root.java

Content: 

/** 

 * Base constructor

 * @param parent {@link FONode} that is the parent of this objectNote: parent should be null for the fo:root.

 */

public Root(FONode parent){

  super(parent);

  pageSequences=new java.util.ArrayList<PageSequence>();

}

Location: Root.java

Content: 

/** 

 * Set the BookmarkTree object for this FO

 * @param bookmarkTree the BookmarkTree object

 */

public void setBookmarkTree(BookmarkTree bookmarkTree){

  this.bookmarkTree=bookmarkTree;

}

Location: Root.java

Content: 

/** 

 * Sets the builder context for this FO tree.

 * @param context the builder context to be used

 */

public void setBuilderContext(FOTreeBuilderContext context){

  this.builderContext=context;

}

Location: Root.java

Content: 

/** 

 * Sets the associated Declarations.

 * @param declarations the Declarations to use

 */

public void setDeclarations(Declarations declarations){

  this.declarations=declarations;

}

Location: Root.java

Content: 

/** 

 * Sets the FOEventHandler object that this Root is attached to

 * @param foEventHandler the FOEventHandler object

 */

public void setFOEventHandler(FOEventHandler foEventHandler){

  this.foEventHandler=foEventHandler;

}

Location: Root.java

Content: 

public void setLastSeq(PageSequence seq){

  lastSeq=seq;

}

Location: Root.java

Content: 

/** 

 * Sets the associated LayoutMasterSet.

 * @param layoutMasterSet the LayoutMasterSet to use

 */

public void setLayoutMasterSet(LayoutMasterSet layoutMasterSet){

  this.layoutMasterSet=layoutMasterSet;

}

Location: Root.java

Content: 

/** 

 * @param loc location in the source file

 * @param child the {@link FONode} to validate against

 * @throws ValidationException if the incoming node is not a valid child for the given FO

 */

protected void validateChildNode(Locator loc,FONode child) throws ValidationException {

  if (child instanceof AbstractPageSequence) {

    pageSequenceFound=true;

  }

}

