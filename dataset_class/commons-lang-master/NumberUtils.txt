Location: NumberUtils.java

Content: 

/** 

 * <p>Compares two  {@code byte} values numerically. This is the same functionality as provided in Java 7.</p>

 * @param x the first {@code byte} to compare

 * @param y the second {@code byte} to compare

 * @return the value {@code 0} if {@code x == y}; a value less than  {@code 0} if {@code x < y}; and a value greater than  {@code 0} if {@code x > y}

 * @since 3.4

 */

public static int compare(final byte x,final byte y){

  return x - y;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Compares two  {@code int} values numerically. This is the same functionality as provided in Java 7.</p>

 * @param x the first {@code int} to compare

 * @param y the second {@code int} to compare

 * @return the value {@code 0} if {@code x == y}; a value less than  {@code 0} if {@code x < y}; and a value greater than  {@code 0} if {@code x > y}

 * @since 3.4

 */

public static int compare(final int x,final int y){

  if (x == y) {

    return 0;

  }

  return x < y ? -1 : 1;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Compares to  {@code long} values numerically. This is the same functionality as provided in Java 7.</p>

 * @param x the first {@code long} to compare

 * @param y the second {@code long} to compare

 * @return the value {@code 0} if {@code x == y}; a value less than  {@code 0} if {@code x < y}; and a value greater than  {@code 0} if {@code x > y}

 * @since 3.4

 */

public static int compare(final long x,final long y){

  if (x == y) {

    return 0;

  }

  return x < y ? -1 : 1;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Compares to  {@code short} values numerically. This is the same functionality as provided in Java 7.</p>

 * @param x the first {@code short} to compare

 * @param y the second {@code short} to compare

 * @return the value {@code 0} if {@code x == y}; a value less than  {@code 0} if {@code x < y}; and a value greater than  {@code 0} if {@code x > y}

 * @since 3.4

 */

public static int compare(final short x,final short y){

  if (x == y) {

    return 0;

  }

  return x < y ? -1 : 1;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code BigDecimal}.</p> <p>Returns  {@code null} if the string is {@code null}.</p>

 * @param str  a {@code String} to convert, may be null

 * @return converted {@code BigDecimal} (or null if the input is null)

 * @throws NumberFormatException if the value cannot be converted

 */

public static BigDecimal createBigDecimal(final String str){

  if (str == null) {

    return null;

  }

  if (StringUtils.isBlank(str)) {

    throw new NumberFormatException("A blank string is not a valid number");

  }

  return new BigDecimal(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code BigInteger}; since 3.2 it handles hex (0x or #) and octal (0) notations.</p> <p>Returns  {@code null} if the string is {@code null}.</p>

 * @param str  a {@code String} to convert, may be null

 * @return converted {@code BigInteger} (or null if the input is null)

 * @throws NumberFormatException if the value cannot be converted

 */

public static BigInteger createBigInteger(final String str){

  if (str == null) {

    return null;

  }

  if (str.isEmpty()) {

    throw new NumberFormatException("An empty string is not a valid number");

  }

  int pos=0;

  int radix=10;

  boolean negate=false;

  final char char0=str.charAt(0);

  if (char0 == '-') {

    negate=true;

    pos=1;

  }

 else   if (char0 == '+') {

    pos=1;

  }

  if (str.startsWith("0x",pos) || str.startsWith("0X",pos)) {

    radix=16;

    pos+=2;

  }

 else   if (str.startsWith("#",pos)) {

    radix=16;

    pos++;

  }

 else   if (str.startsWith("0",pos) && str.length() > pos + 1) {

    radix=8;

    pos++;

  }

  final BigInteger value=new BigInteger(str.substring(pos),radix);

  return negate ? value.negate() : value;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code Double}.</p> <p>Returns  {@code null} if the string is {@code null}.</p>

 * @param str  a {@code String} to convert, may be null

 * @return converted {@code Double} (or null if the input is null)

 * @throws NumberFormatException if the value cannot be converted

 */

public static Double createDouble(final String str){

  if (str == null) {

    return null;

  }

  return Double.valueOf(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code Float}.</p> <p>Returns  {@code null} if the string is {@code null}.</p>

 * @param str  a {@code String} to convert, may be null

 * @return converted {@code Float} (or null if the input is null)

 * @throws NumberFormatException if the value cannot be converted

 */

public static Float createFloat(final String str){

  if (str == null) {

    return null;

  }

  return Float.valueOf(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code Integer}, handling hex (0xhhhh) and octal (0dddd) notations. N.B. a leading zero means octal; spaces are not trimmed.</p> <p>Returns  {@code null} if the string is {@code null}.</p>

 * @param str  a {@code String} to convert, may be null

 * @return converted {@code Integer} (or null if the input is null)

 * @throws NumberFormatException if the value cannot be converted

 */

public static Integer createInteger(final String str){

  if (str == null) {

    return null;

  }

  return Integer.decode(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code Long}; since 3.1 it handles hex (0Xhhhh) and octal (0ddd) notations. N.B. a leading zero means octal; spaces are not trimmed.</p> <p>Returns  {@code null} if the string is {@code null}.</p>

 * @param str  a {@code String} to convert, may be null

 * @return converted {@code Long} (or null if the input is null)

 * @throws NumberFormatException if the value cannot be converted

 */

public static Long createLong(final String str){

  if (str == null) {

    return null;

  }

  return Long.decode(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Turns a string value into a java.lang.Number.</p> <p>If the string starts with  {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the prefix is more than 8 - or BigInteger if there are more than 16 digits. </p> <p>Then, the value is examined for a type qualifier on the end, i.e. one of {@code 'f', 'F', 'd', 'D', 'l', 'L'}.  If it is found, it starts trying to create successively larger types from the type specified until one is found that can represent the value.</p> <p>If a type specifier is not found, it will check for a decimal point and then try successively larger types from  {@code Integer} to{@code BigInteger} and from {@code Float} to{@code BigDecimal}.</p> <p> Integral values with a leading  {@code 0} will be interpreted as octal; the returned number willbe Integer, Long or BigDecimal as appropriate. </p> <p>Returns  {@code null} if the string is {@code null}.</p> <p>This method does not trim the input string, i.e., strings with leading or trailing spaces will generate NumberFormatExceptions.</p>

 * @param str  String containing a number, may be null

 * @return Number created from the string (or null if the input is null)

 * @throws NumberFormatException if the value cannot be converted

 */

public static Number createNumber(final String str){

  if (str == null) {

    return null;

  }

  if (StringUtils.isBlank(str)) {

    throw new NumberFormatException("A blank string is not a valid number");

  }

  final String[] hex_prefixes={"0x","0X","#"};

  final int length=str.length();

  final int offset=str.charAt(0) == '+' || str.charAt(0) == '-' ? 1 : 0;

  int pfxLen=0;

  for (  final String pfx : hex_prefixes) {

    if (str.startsWith(pfx,offset)) {

      pfxLen+=pfx.length() + offset;

      break;

    }

  }

  if (pfxLen > 0) {

    char firstSigDigit=0;

    for (int i=pfxLen; i < length; i++) {

      firstSigDigit=str.charAt(i);

      if (firstSigDigit != '0') {

        break;

      }

      pfxLen++;

    }

    final int hexDigits=length - pfxLen;

    if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') {

      return createBigInteger(str);

    }

    if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') {

      return createLong(str);

    }

    return createInteger(str);

  }

  final char lastChar=str.charAt(length - 1);

  final String mant;

  final String dec;

  final String exp;

  final int decPos=str.indexOf('.');

  final int expPos=str.indexOf('e') + str.indexOf('E') + 1;

  final boolean requestType=!Character.isDigit(lastChar) && lastChar != '.';

  if (decPos > -1) {

    if (expPos > -1) {

      if (expPos < decPos || expPos > length) {

        throw new NumberFormatException(str + " is not a valid number.");

      }

      dec=str.substring(decPos + 1,expPos);

    }

 else {

      dec=str.substring(decPos + 1,requestType ? length - 1 : length);

    }

    mant=getMantissa(str,decPos);

  }

 else {

    if (expPos > -1) {

      if (expPos > length) {

        throw new NumberFormatException(str + " is not a valid number.");

      }

      mant=getMantissa(str,expPos);

    }

 else {

      mant=getMantissa(str,requestType ? length - 1 : length);

    }

    dec=null;

  }

  if (requestType) {

    if (expPos > -1 && expPos < length - 1) {

      exp=str.substring(expPos + 1,length - 1);

    }

 else {

      exp=null;

    }

    final String numeric=str.substring(0,length - 1);

switch (lastChar) {

case 'l':

case 'L':

      if (dec == null && exp == null && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {

        try {

          return createLong(numeric);

        }

 catch (        final NumberFormatException nfe) {

        }

        return createBigInteger(numeric);

      }

    throw new NumberFormatException(str + " is not a valid number.");

case 'f':

case 'F':

  try {

    final Float f=createFloat(str);

    if (!(f.isInfinite() || f.floatValue() == 0.0F && !isZero(mant,dec))) {

      return f;

    }

  }

 catch (  final NumberFormatException nfe) {

  }

case 'd':

case 'D':

try {

  final Double d=createDouble(str);

  if (!(d.isInfinite() || d.doubleValue() == 0.0D && !isZero(mant,dec))) {

    return d;

  }

}

 catch (final NumberFormatException nfe) {

}

try {

return createBigDecimal(numeric);

}

 catch (final NumberFormatException e) {

}

default :

throw new NumberFormatException(str + " is not a valid number.");

}

}

if (expPos > -1 && expPos < length - 1) {

exp=str.substring(expPos + 1);

}

 else {

exp=null;

}

if (dec == null && exp == null) {

try {

return createInteger(str);

}

 catch (final NumberFormatException nfe) {

}

try {

return createLong(str);

}

 catch (final NumberFormatException nfe) {

}

return createBigInteger(str);

}

try {

final Float f=createFloat(str);

final Double d=createDouble(str);

if (!f.isInfinite() && !(f.floatValue() == 0.0F && !isZero(mant,dec)) && f.toString().equals(d.toString())) {

return f;

}

if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !isZero(mant,dec))) {

final BigDecimal b=createBigDecimal(str);

if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {

return d;

}

return b;

}

}

 catch (final NumberFormatException nfe) {

}

return createBigDecimal(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Utility method for  {@link #createNumber(java.lang.String)}.</p> <p>Returns mantissa of the given number.</p>

 * @param str the string representation of the number

 * @param stopPos the position of the exponent or decimal point

 * @return mantissa of the given number

 */

private static String getMantissa(final String str,final int stopPos){

  final char firstChar=str.charAt(0);

  final boolean hasSign=firstChar == '-' || firstChar == '+';

  return hasSign ? str.substring(1,stopPos) : str.substring(0,stopPos);

}

Location: NumberUtils.java

Content: 

/** 

 * Utility method for  {@link #createNumber(java.lang.String)}. <p>Returns  {@code true} if s is {@code null} or empty.</p>

 * @param str the String to check

 * @return if it is all zeros or {@code null}

 */

private static boolean isAllZeros(final String str){

  if (str == null) {

    return true;

  }

  for (int i=str.length() - 1; i >= 0; i--) {

    if (str.charAt(i) != '0') {

      return false;

    }

  }

  return true;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Checks whether the String a valid Java number.</p> <p>Valid numbers include hexadecimal marked with the  {@code 0x} or{@code 0X} qualifier, octal numbers, scientific notation andnumbers marked with a type qualifier (e.g. 123L).</p> <p>Non-hexadecimal strings beginning with a leading zero are treated as octal values. Thus the string  {@code 09} will return{@code false}, since  {@code 9} is not a valid octal value.However, numbers beginning with  {@code 0.} are treated as decimal.</p><p> {@code null} and empty/blank {@code String} will return{@code false}.</p> <p>Note,  {@link #createNumber(String)} should return a number for everyinput resulting in  {@code true}.</p>

 * @param str  the {@code String} to check

 * @return {@code true} if the string is a correctly formatted number

 * @since 3.5

 */

public static boolean isCreatable(final String str){

  if (StringUtils.isEmpty(str)) {

    return false;

  }

  final char[] chars=str.toCharArray();

  int sz=chars.length;

  boolean hasExp=false;

  boolean hasDecPoint=false;

  boolean allowSigns=false;

  boolean foundDigit=false;

  final int start=chars[0] == '-' || chars[0] == '+' ? 1 : 0;

  if (sz > start + 1 && chars[start] == '0' && !StringUtils.contains(str,'.')) {

    if (chars[start + 1] == 'x' || chars[start + 1] == 'X') {

      int i=start + 2;

      if (i == sz) {

        return false;

      }

      for (; i < chars.length; i++) {

        if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {

          return false;

        }

      }

      return true;

    }

    if (Character.isDigit(chars[start + 1])) {

      int i=start + 1;

      for (; i < chars.length; i++) {

        if (chars[i] < '0' || chars[i] > '7') {

          return false;

        }

      }

      return true;

    }

  }

  sz--;

  int i=start;

  while (i < sz || i < sz + 1 && allowSigns && !foundDigit) {

    if (chars[i] >= '0' && chars[i] <= '9') {

      foundDigit=true;

      allowSigns=false;

    }

 else     if (chars[i] == '.') {

      if (hasDecPoint || hasExp) {

        return false;

      }

      hasDecPoint=true;

    }

 else     if (chars[i] == 'e' || chars[i] == 'E') {

      if (hasExp) {

        return false;

      }

      if (!foundDigit) {

        return false;

      }

      hasExp=true;

      allowSigns=true;

    }

 else     if (chars[i] == '+' || chars[i] == '-') {

      if (!allowSigns) {

        return false;

      }

      allowSigns=false;

      foundDigit=false;

    }

 else {

      return false;

    }

    i++;

  }

  if (i < chars.length) {

    if (chars[i] >= '0' && chars[i] <= '9') {

      return true;

    }

    if (chars[i] == 'e' || chars[i] == 'E') {

      return false;

    }

    if (chars[i] == '.') {

      if (hasDecPoint || hasExp) {

        return false;

      }

      return foundDigit;

    }

    if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {

      return foundDigit;

    }

    if (chars[i] == 'l' || chars[i] == 'L') {

      return foundDigit && !hasExp && !hasDecPoint;

    }

    return false;

  }

  return !allowSigns && foundDigit;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Checks whether the  {@code String} contains onlydigit characters.</p> <p> {@code Null} and empty String will return{@code false}.</p>

 * @param str  the {@code String} to check

 * @return {@code true} if str contains only Unicode numeric

 */

public static boolean isDigits(final String str){

  return StringUtils.isNumeric(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Checks whether the String a valid Java number.</p> <p>Valid numbers include hexadecimal marked with the  {@code 0x} or{@code 0X} qualifier, octal numbers, scientific notation andnumbers marked with a type qualifier (e.g. 123L).</p> <p>Non-hexadecimal strings beginning with a leading zero are treated as octal values. Thus the string  {@code 09} will return{@code false}, since  {@code 9} is not a valid octal value.However, numbers beginning with  {@code 0.} are treated as decimal.</p><p> {@code null} and empty/blank {@code String} will return{@code false}.</p> <p>Note,  {@link #createNumber(String)} should return a number for everyinput resulting in  {@code true}.</p>

 * @param str  the {@code String} to check

 * @return {@code true} if the string is a correctly formatted number

 * @since 3.3 the code supports hex {@code 0Xhhh} anoctal  {@code 0ddd} validation

 * @deprecated This feature will be removed in Lang 4.0,use  {@link NumberUtils#isCreatable(String)} instead

 */

@Deprecated public static boolean isNumber(final String str){

  return isCreatable(str);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Checks whether the given String is a parsable number.</p> <p>Parsable numbers include those Strings understood by  {@link Integer#parseInt(String)}, {@link Long#parseLong(String)},  {@link Float#parseFloat(String)} or{@link Double#parseDouble(String)}. This method can be used instead of catching  {@link java.text.ParseException}when calling one of those methods.</p> <p>Hexadecimal and scientific notations are <strong>not</strong> considered parsable. See  {@link #isCreatable(String)} on those cases.</p><p> {@code Null} and empty String will return {@code false}.</p>

 * @param str the String to check.

 * @return {@code true} if the string is a parsable number.

 * @since 3.4

 */

public static boolean isParsable(final String str){

  if (StringUtils.isEmpty(str)) {

    return false;

  }

  if (str.charAt(str.length() - 1) == '.') {

    return false;

  }

  if (str.charAt(0) == '-') {

    if (str.length() == 1) {

      return false;

    }

    return withDecimalsParsing(str,1);

  }

  return withDecimalsParsing(str,0);

}

Location: NumberUtils.java

Content: 

/** 

 * Utility method for  {@link #createNumber(java.lang.String)}. <p>This will check if the magnitude of the number is zero by checking if there are only zeros before and after the decimal place.</p> <p>Note: It is <strong>assumed</strong> that the input string has been converted to either a Float or Double with a value of zero when this method is called. This eliminates invalid input for example  {@code ".", ".D", ".e0"}.</p> <p>Thus the method only requires checking if both arguments are null, empty or contain only zeros.</p> <p>Given  {@code s = mant + "." + dec}:</p> <ul> <li> {@code true} if s is {@code "0.0"}<li> {@code true} if s is {@code "0."}<li> {@code true} if s is {@code ".0"}<li> {@code false} otherwise (this assumes {@code "."} is not possible)</ul>

 * @param mant the mantissa decimal digits before the decimal point (sign must be removed; never null)

 * @param dec the decimal digits after the decimal point (exponent and type specifier removed;can be null)

 * @return true if the magnitude is zero

 */

private static boolean isZero(final String mant,final String dec){

  return isAllZeros(mant) && isAllZeros(dec);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the maximum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the maximum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from max(byte[]) to max(byte...)

 */

public static byte max(final byte... array){

  validateArray(array);

  byte max=array[0];

  for (int i=1; i < array.length; i++) {

    if (array[i] > max) {

      max=array[i];

    }

  }

  return max;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the maximum of three  {@code byte} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the largest of the values

 */

public static byte max(byte a,final byte b,final byte c){

  if (b > a) {

    a=b;

  }

  if (c > a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the maximum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the maximum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @see IEEE754rUtils#max(double[]) IEEE754rUtils for a version of this method that handles NaN differently

 * @since 3.4 Changed signature from max(double[]) to max(double...)

 */

public static double max(final double... array){

  validateArray(array);

  double max=array[0];

  for (int j=1; j < array.length; j++) {

    if (Double.isNaN(array[j])) {

      return Double.NaN;

    }

    if (array[j] > max) {

      max=array[j];

    }

  }

  return max;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the maximum of three  {@code double} values.</p><p>If any value is  {@code NaN},  {@code NaN} isreturned. Infinity is handled.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the largest of the values

 * @see IEEE754rUtils#max(double,double,double) for a version of this method that handles NaN differently

 */

public static double max(final double a,final double b,final double c){

  return Math.max(Math.max(a,b),c);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the maximum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the maximum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @see IEEE754rUtils#max(float[]) IEEE754rUtils for a version of this method that handles NaN differently

 * @since 3.4 Changed signature from max(float[]) to max(float...)

 */

public static float max(final float... array){

  validateArray(array);

  float max=array[0];

  for (int j=1; j < array.length; j++) {

    if (Float.isNaN(array[j])) {

      return Float.NaN;

    }

    if (array[j] > max) {

      max=array[j];

    }

  }

  return max;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the maximum of three  {@code float} values.</p><p>If any value is  {@code NaN},  {@code NaN} isreturned. Infinity is handled.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the largest of the values

 * @see IEEE754rUtils#max(float,float,float) for a version of this method that handles NaN differently

 */

public static float max(final float a,final float b,final float c){

  return Math.max(Math.max(a,b),c);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the maximum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the maximum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from max(int[]) to max(int...)

 */

public static int max(final int... array){

  validateArray(array);

  int max=array[0];

  for (int j=1; j < array.length; j++) {

    if (array[j] > max) {

      max=array[j];

    }

  }

  return max;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the maximum of three  {@code int} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the largest of the values

 */

public static int max(int a,final int b,final int c){

  if (b > a) {

    a=b;

  }

  if (c > a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the maximum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the maximum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from max(long[]) to max(long...)

 */

public static long max(final long... array){

  validateArray(array);

  long max=array[0];

  for (int j=1; j < array.length; j++) {

    if (array[j] > max) {

      max=array[j];

    }

  }

  return max;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the maximum of three  {@code long} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the largest of the values

 */

public static long max(long a,final long b,final long c){

  if (b > a) {

    a=b;

  }

  if (c > a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the maximum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the maximum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from max(short[]) to max(short...)

 */

public static short max(final short... array){

  validateArray(array);

  short max=array[0];

  for (int i=1; i < array.length; i++) {

    if (array[i] > max) {

      max=array[i];

    }

  }

  return max;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the maximum of three  {@code short} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the largest of the values

 */

public static short max(short a,final short b,final short c){

  if (b > a) {

    a=b;

  }

  if (c > a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the minimum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the minimum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from min(byte[]) to min(byte...)

 */

public static byte min(final byte... array){

  validateArray(array);

  byte min=array[0];

  for (int i=1; i < array.length; i++) {

    if (array[i] < min) {

      min=array[i];

    }

  }

  return min;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the minimum of three  {@code byte} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the smallest of the values

 */

public static byte min(byte a,final byte b,final byte c){

  if (b < a) {

    a=b;

  }

  if (c < a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the minimum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the minimum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @see IEEE754rUtils#min(double[]) IEEE754rUtils for a version of this method that handles NaN differently

 * @since 3.4 Changed signature from min(double[]) to min(double...)

 */

public static double min(final double... array){

  validateArray(array);

  double min=array[0];

  for (int i=1; i < array.length; i++) {

    if (Double.isNaN(array[i])) {

      return Double.NaN;

    }

    if (array[i] < min) {

      min=array[i];

    }

  }

  return min;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the minimum of three  {@code double} values.</p><p>If any value is  {@code NaN},  {@code NaN} isreturned. Infinity is handled.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the smallest of the values

 * @see IEEE754rUtils#min(double,double,double) for a version of this method that handles NaN differently

 */

public static double min(final double a,final double b,final double c){

  return Math.min(Math.min(a,b),c);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the minimum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the minimum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @see IEEE754rUtils#min(float[]) IEEE754rUtils for a version of this method that handles NaN differently

 * @since 3.4 Changed signature from min(float[]) to min(float...)

 */

public static float min(final float... array){

  validateArray(array);

  float min=array[0];

  for (int i=1; i < array.length; i++) {

    if (Float.isNaN(array[i])) {

      return Float.NaN;

    }

    if (array[i] < min) {

      min=array[i];

    }

  }

  return min;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the minimum of three  {@code float} values.</p><p>If any value is  {@code NaN},  {@code NaN} isreturned. Infinity is handled.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the smallest of the values

 * @see IEEE754rUtils#min(float,float,float) for a version of this method that handles NaN differently

 */

public static float min(final float a,final float b,final float c){

  return Math.min(Math.min(a,b),c);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the minimum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the minimum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from min(int[]) to min(int...)

 */

public static int min(final int... array){

  validateArray(array);

  int min=array[0];

  for (int j=1; j < array.length; j++) {

    if (array[j] < min) {

      min=array[j];

    }

  }

  return min;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the minimum of three  {@code int} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the smallest of the values

 */

public static int min(int a,final int b,final int c){

  if (b < a) {

    a=b;

  }

  if (c < a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the minimum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the minimum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from min(long[]) to min(long...)

 */

public static long min(final long... array){

  validateArray(array);

  long min=array[0];

  for (int i=1; i < array.length; i++) {

    if (array[i] < min) {

      min=array[i];

    }

  }

  return min;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the minimum of three  {@code long} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the smallest of the values

 */

public static long min(long a,final long b,final long c){

  if (b < a) {

    a=b;

  }

  if (c < a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Returns the minimum value in an array.</p>

 * @param array  an array, must not be null or empty

 * @return the minimum value in the array

 * @throws NullPointerException if {@code array} is {@code null}

 * @throws IllegalArgumentException if {@code array} is empty

 * @since 3.4 Changed signature from min(short[]) to min(short...)

 */

public static short min(final short... array){

  validateArray(array);

  short min=array[0];

  for (int i=1; i < array.length; i++) {

    if (array[i] < min) {

      min=array[i];

    }

  }

  return min;

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Gets the minimum of three  {@code short} values.</p>

 * @param a  value 1

 * @param b  value 2

 * @param c  value 3

 * @return  the smallest of the values

 */

public static short min(short a,final short b,final short c){

  if (b < a) {

    a=b;

  }

  if (c < a) {

    a=c;

  }

  return a;

}

Location: NumberUtils.java

Content: 

/** 

 * <p> {@code NumberUtils} instances should NOT be constructed in standard programming.Instead, the class should be used as  {@code NumberUtils.toInt("6");}.</p> <p>This constructor is public to permit tools that require a JavaBean instance to operate.</p>

 */

public NumberUtils(){

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code byte}, returning {@code zero} if the conversion fails.</p><p>If the string is  {@code null},  {@code zero} is returned.</p><pre> NumberUtils.toByte(null) = 0 NumberUtils.toByte("")   = 0 NumberUtils.toByte("1")  = 1 </pre>

 * @param str  the string to convert, may be null

 * @return the byte represented by the string, or {@code zero} ifconversion fails

 * @since 2.5

 */

public static byte toByte(final String str){

  return toByte(str,(byte)0);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code byte}, returning a default value if the conversion fails.</p> <p>If the string is  {@code null}, the default value is returned.</p> <pre> NumberUtils.toByte(null, 1) = 1 NumberUtils.toByte("", 1)   = 1 NumberUtils.toByte("1", 0)  = 1 </pre>

 * @param str  the string to convert, may be null

 * @param defaultValue  the default value

 * @return the byte represented by the string, or the default if conversion fails

 * @since 2.5

 */

public static byte toByte(final String str,final byte defaultValue){

  if (str == null) {

    return defaultValue;

  }

  try {

    return Byte.parseByte(str);

  }

 catch (  final NumberFormatException nfe) {

    return defaultValue;

  }

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code BigDecimal} to a {@code double}.</p> <p>If the  {@code BigDecimal} {@code value} is{@code null}, then the specified default value is returned.</p> <pre> NumberUtils.toDouble(null)                     = 0.0d NumberUtils.toDouble(BigDecimal.valudOf(8.5d)) = 8.5d </pre>

 * @param value the {@code BigDecimal} to convert, may be {@code null}.

 * @return the double represented by the {@code BigDecimal} or{@code 0.0d} if the {@code BigDecimal} is {@code null}.

 * @since 3.8

 */

public static double toDouble(final BigDecimal value){

  return toDouble(value,0.0d);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code BigDecimal} to a {@code double}.</p> <p>If the  {@code BigDecimal} {@code value} is{@code null}, then the specified default value is returned.</p> <pre> NumberUtils.toDouble(null, 1.1d)                     = 1.1d NumberUtils.toDouble(BigDecimal.valudOf(8.5d), 1.1d) = 8.5d </pre>

 * @param value the {@code BigDecimal} to convert, may be {@code null}.

 * @param defaultValue the default value

 * @return the double represented by the {@code BigDecimal} or thedefaultValue if the  {@code BigDecimal} is {@code null}.

 * @since 3.8

 */

public static double toDouble(final BigDecimal value,final double defaultValue){

  return value == null ? defaultValue : value.doubleValue();

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code double}, returning {@code 0.0d} if the conversion fails.</p><p>If the string  {@code str} is {@code null}, {@code 0.0d} is returned.</p><pre> NumberUtils.toDouble(null)   = 0.0d NumberUtils.toDouble("")     = 0.0d NumberUtils.toDouble("1.5")  = 1.5d </pre>

 * @param str the string to convert, may be {@code null}

 * @return the double represented by the string, or {@code 0.0d}if conversion fails

 * @since 2.1

 */

public static double toDouble(final String str){

  return toDouble(str,0.0d);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code double}, returning a default value if the conversion fails.</p> <p>If the string  {@code str} is {@code null}, the default value is returned.</p> <pre> NumberUtils.toDouble(null, 1.1d)   = 1.1d NumberUtils.toDouble("", 1.1d)     = 1.1d NumberUtils.toDouble("1.5", 0.0d)  = 1.5d </pre>

 * @param str the string to convert, may be {@code null}

 * @param defaultValue the default value

 * @return the double represented by the string, or defaultValueif conversion fails

 * @since 2.1

 */

public static double toDouble(final String str,final double defaultValue){

  if (str == null) {

    return defaultValue;

  }

  try {

    return Double.parseDouble(str);

  }

 catch (  final NumberFormatException nfe) {

    return defaultValue;

  }

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code float}, returning {@code 0.0f} if the conversion fails.</p><p>If the string  {@code str} is {@code null}, {@code 0.0f} is returned.</p><pre> NumberUtils.toFloat(null)   = 0.0f NumberUtils.toFloat("")     = 0.0f NumberUtils.toFloat("1.5")  = 1.5f </pre>

 * @param str the string to convert, may be {@code null}

 * @return the float represented by the string, or {@code 0.0f}if conversion fails

 * @since 2.1

 */

public static float toFloat(final String str){

  return toFloat(str,0.0f);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code float}, returning a default value if the conversion fails.</p> <p>If the string  {@code str} is {@code null}, the default value is returned.</p> <pre> NumberUtils.toFloat(null, 1.1f)   = 1.0f NumberUtils.toFloat("", 1.1f)     = 1.1f NumberUtils.toFloat("1.5", 0.0f)  = 1.5f </pre>

 * @param str the string to convert, may be {@code null}

 * @param defaultValue the default value

 * @return the float represented by the string, or defaultValueif conversion fails

 * @since 2.1

 */

public static float toFloat(final String str,final float defaultValue){

  if (str == null) {

    return defaultValue;

  }

  try {

    return Float.parseFloat(str);

  }

 catch (  final NumberFormatException nfe) {

    return defaultValue;

  }

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to an {@code int}, returning {@code zero} if the conversion fails.</p><p>If the string is  {@code null},  {@code zero} is returned.</p><pre> NumberUtils.toInt(null) = 0 NumberUtils.toInt("")   = 0 NumberUtils.toInt("1")  = 1 </pre>

 * @param str  the string to convert, may be null

 * @return the int represented by the string, or {@code zero} ifconversion fails

 * @since 2.1

 */

public static int toInt(final String str){

  return toInt(str,0);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to an {@code int}, returning a default value if the conversion fails.</p> <p>If the string is  {@code null}, the default value is returned.</p> <pre> NumberUtils.toInt(null, 1) = 1 NumberUtils.toInt("", 1)   = 1 NumberUtils.toInt("1", 0)  = 1 </pre>

 * @param str  the string to convert, may be null

 * @param defaultValue  the default value

 * @return the int represented by the string, or the default if conversion fails

 * @since 2.1

 */

public static int toInt(final String str,final int defaultValue){

  if (str == null) {

    return defaultValue;

  }

  try {

    return Integer.parseInt(str);

  }

 catch (  final NumberFormatException nfe) {

    return defaultValue;

  }

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code long}, returning {@code zero} if the conversion fails.</p><p>If the string is  {@code null},  {@code zero} is returned.</p><pre> NumberUtils.toLong(null) = 0L NumberUtils.toLong("")   = 0L NumberUtils.toLong("1")  = 1L </pre>

 * @param str  the string to convert, may be null

 * @return the long represented by the string, or {@code 0} ifconversion fails

 * @since 2.1

 */

public static long toLong(final String str){

  return toLong(str,0L);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code long}, returning a default value if the conversion fails.</p> <p>If the string is  {@code null}, the default value is returned.</p> <pre> NumberUtils.toLong(null, 1L) = 1L NumberUtils.toLong("", 1L)   = 1L NumberUtils.toLong("1", 0L)  = 1L </pre>

 * @param str  the string to convert, may be null

 * @param defaultValue  the default value

 * @return the long represented by the string, or the default if conversion fails

 * @since 2.1

 */

public static long toLong(final String str,final long defaultValue){

  if (str == null) {

    return defaultValue;

  }

  try {

    return Long.parseLong(str);

  }

 catch (  final NumberFormatException nfe) {

    return defaultValue;

  }

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code BigDecimal} to a {@code BigDecimal} with a scale oftwo that has been rounded using  {@code RoundingMode.HALF_EVEN}. If the supplied {@code value} is null, then {@code BigDecimal.ZERO} is returned.<p>Note, the scale of a  {@code BigDecimal} is the number of digits to the right of thedecimal point.</p>

 * @param value the {@code BigDecimal} to convert, may be null.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final BigDecimal value){

  return toScaledBigDecimal(value,INTEGER_TWO,RoundingMode.HALF_EVEN);

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code BigDecimal} to a {@code BigDecimal} whose scale is thespecified value with a  {@code RoundingMode} applied. If the input {@code value}is  {@code null}, we simply return  {@code BigDecimal.ZERO}.

 * @param value the {@code BigDecimal} to convert, may be null.

 * @param scale the number of digits to the right of the decimal point.

 * @param roundingMode a rounding behavior for numerical operations capable ofdiscarding precision.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final BigDecimal value,final int scale,final RoundingMode roundingMode){

  if (value == null) {

    return BigDecimal.ZERO;

  }

  return value.setScale(scale,(roundingMode == null) ? RoundingMode.HALF_EVEN : roundingMode);

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code Double} to a {@code BigDecimal} with a scale oftwo that has been rounded using  {@code RoundingMode.HALF_EVEN}. If the supplied {@code value} is null, then {@code BigDecimal.ZERO} is returned.<p>Note, the scale of a  {@code BigDecimal} is the number of digits to the right of thedecimal point.</p>

 * @param value the {@code Double} to convert, may be null.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final Double value){

  return toScaledBigDecimal(value,INTEGER_TWO,RoundingMode.HALF_EVEN);

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code Double} to a {@code BigDecimal} whose scale is thespecified value with a  {@code RoundingMode} applied. If the input {@code value}is  {@code null}, we simply return  {@code BigDecimal.ZERO}.

 * @param value the {@code Double} to convert, may be null.

 * @param scale the number of digits to the right of the decimal point.

 * @param roundingMode a rounding behavior for numerical operations capable ofdiscarding precision.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final Double value,final int scale,final RoundingMode roundingMode){

  if (value == null) {

    return BigDecimal.ZERO;

  }

  return toScaledBigDecimal(BigDecimal.valueOf(value),scale,roundingMode);

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code Float} to a {@code BigDecimal} with a scale oftwo that has been rounded using  {@code RoundingMode.HALF_EVEN}. If the supplied {@code value} is null, then {@code BigDecimal.ZERO} is returned.<p>Note, the scale of a  {@code BigDecimal} is the number of digits to the right of thedecimal point.</p>

 * @param value the {@code Float} to convert, may be null.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final Float value){

  return toScaledBigDecimal(value,INTEGER_TWO,RoundingMode.HALF_EVEN);

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code Float} to a {@code BigDecimal} whose scale is thespecified value with a  {@code RoundingMode} applied. If the input {@code value}is  {@code null}, we simply return  {@code BigDecimal.ZERO}.

 * @param value the {@code Float} to convert, may be null.

 * @param scale the number of digits to the right of the decimal point.

 * @param roundingMode a rounding behavior for numerical operations capable ofdiscarding precision.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final Float value,final int scale,final RoundingMode roundingMode){

  if (value == null) {

    return BigDecimal.ZERO;

  }

  return toScaledBigDecimal(BigDecimal.valueOf(value),scale,roundingMode);

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code String} to a {@code BigDecimal} with a scale oftwo that has been rounded using  {@code RoundingMode.HALF_EVEN}. If the supplied {@code value} is null, then {@code BigDecimal.ZERO} is returned.<p>Note, the scale of a  {@code BigDecimal} is the number of digits to the right of thedecimal point.</p>

 * @param value the {@code String} to convert, may be null.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final String value){

  return toScaledBigDecimal(value,INTEGER_TWO,RoundingMode.HALF_EVEN);

}

Location: NumberUtils.java

Content: 

/** 

 * Convert a  {@code String} to a {@code BigDecimal} whose scale is thespecified value with a  {@code RoundingMode} applied. If the input {@code value}is  {@code null}, we simply return  {@code BigDecimal.ZERO}.

 * @param value the {@code String} to convert, may be null.

 * @param scale the number of digits to the right of the decimal point.

 * @param roundingMode a rounding behavior for numerical operations capable ofdiscarding precision.

 * @return the scaled, with appropriate rounding, {@code BigDecimal}.

 * @since 3.8

 */

public static BigDecimal toScaledBigDecimal(final String value,final int scale,final RoundingMode roundingMode){

  if (value == null) {

    return BigDecimal.ZERO;

  }

  return toScaledBigDecimal(createBigDecimal(value),scale,roundingMode);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to a {@code short}, returning {@code zero} if the conversion fails.</p><p>If the string is  {@code null},  {@code zero} is returned.</p><pre> NumberUtils.toShort(null) = 0 NumberUtils.toShort("")   = 0 NumberUtils.toShort("1")  = 1 </pre>

 * @param str  the string to convert, may be null

 * @return the short represented by the string, or {@code zero} ifconversion fails

 * @since 2.5

 */

public static short toShort(final String str){

  return toShort(str,(short)0);

}

Location: NumberUtils.java

Content: 

/** 

 * <p>Convert a  {@code String} to an {@code short}, returning a default value if the conversion fails.</p> <p>If the string is  {@code null}, the default value is returned.</p> <pre> NumberUtils.toShort(null, 1) = 1 NumberUtils.toShort("", 1)   = 1 NumberUtils.toShort("1", 0)  = 1 </pre>

 * @param str  the string to convert, may be null

 * @param defaultValue  the default value

 * @return the short represented by the string, or the default if conversion fails

 * @since 2.5

 */

public static short toShort(final String str,final short defaultValue){

  if (str == null) {

    return defaultValue;

  }

  try {

    return Short.parseShort(str);

  }

 catch (  final NumberFormatException nfe) {

    return defaultValue;

  }

}

Location: NumberUtils.java

Content: 

/** 

 * Checks if the specified array is neither null nor empty.

 * @param array  the array to check

 * @throws IllegalArgumentException if {@code array} is empty

 * @throws NullPointerException if {@code array} is {@code null}

 */

private static void validateArray(final Object array){

  Validate.notNull(array,"array");

  Validate.isTrue(Array.getLength(array) != 0,"Array cannot be empty.");

}

Location: NumberUtils.java

Content: 

private static boolean withDecimalsParsing(final String str,final int beginIdx){

  int decimalPoints=0;

  for (int i=beginIdx; i < str.length(); i++) {

    final boolean isDecimalPoint=str.charAt(i) == '.';

    if (isDecimalPoint) {

      decimalPoints++;

    }

    if (decimalPoints > 1) {

      return false;

    }

    if (!isDecimalPoint && !Character.isDigit(str.charAt(i))) {

      return false;

    }

  }

  return true;

}

