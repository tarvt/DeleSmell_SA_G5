Location: Stylesheet.java

Content: 

private void addDOMField(ClassGenerator classGen){

  final FieldGen fgen=new FieldGen(ACC_PUBLIC,Util.getJCRefType(DOM_INTF_SIG),DOM_FIELD,classGen.getConstantPool());

  classGen.addField(fgen.getField());

}

Location: Stylesheet.java

Content: 

public void addIncludedStylesheet(Stylesheet child){

  if (_includedStylesheets == null) {

    _includedStylesheets=new Vector();

  }

  _includedStylesheets.addElement(child);

}

Location: Stylesheet.java

Content: 

public int addParam(Param param){

  _globals.addElement(param);

  return _globals.size() - 1;

}

Location: Stylesheet.java

Content: 

/** 

 * Adds a single prefix mapping to this syntax tree node.

 * @param prefix Namespace prefix.

 * @param uri    Namespace URI.

 */

protected void addPrefixMapping(String prefix,String uri){

  if (prefix.equals(EMPTYSTRING) && uri.equals(XHTML_URI))   return;

  super.addPrefixMapping(prefix,uri);

}

Location: Stylesheet.java

Content: 

/** 

 * Add a static field

 */

private void addStaticField(ClassGenerator classGen,String type,String name){

  final FieldGen fgen=new FieldGen(ACC_PROTECTED | ACC_STATIC,Util.getJCRefType(type),name,classGen.getConstantPool());

  classGen.addField(fgen.getField());

}

Location: Stylesheet.java

Content: 

protected void addTemplate(Template template){

  _templates.addElement(template);

}

Location: Stylesheet.java

Content: 

public boolean callsNodeset(){

  return _callsNodeset;

}

Location: Stylesheet.java

Content: 

public boolean checkForLoop(String systemId){

  if (_systemId != null && _systemId.equals(systemId)) {

    return true;

  }

  if (_parentStylesheet != null)   return _parentStylesheet.checkForLoop(systemId);

  return false;

}

Location: Stylesheet.java

Content: 

/** 

 * Check and set the output method

 */

private void checkOutputMethod(){

  if (_lastOutputElement != null) {

    String method=_lastOutputElement.getOutputMethod();

    if (method != null) {

      if (method.equals("xml"))       _outputMethod=XML_OUTPUT;

 else       if (method.equals("html"))       _outputMethod=HTML_OUTPUT;

 else       if (method.equals("text"))       _outputMethod=TEXT_OUTPUT;

    }

  }

}

Location: Stylesheet.java

Content: 

/** 

 * Compile a buildKeys() method into the output class. Note that keys for the input document are created in topLevel(), not in this method. However, we still need this method to create keys for documents loaded via the XPath document() function.

 */

private String compileBuildKeys(ClassGenerator classGen){

  final ConstantPoolGen cpg=classGen.getConstantPool();

  final org.apache.bcel.generic.Type[] argTypes={Util.getJCRefType(DOM_INTF_SIG),Util.getJCRefType(NODE_ITERATOR_SIG),Util.getJCRefType(TRANSLET_OUTPUT_SIG),org.apache.bcel.generic.Type.INT};

  final String[] argNames={DOCUMENT_PNAME,ITERATOR_PNAME,TRANSLET_OUTPUT_PNAME,"current"};

  final InstructionList il=new InstructionList();

  final MethodGenerator buildKeys=new MethodGenerator(ACC_PUBLIC,org.apache.bcel.generic.Type.VOID,argTypes,argNames,"buildKeys",_className,il,classGen.getConstantPool());

  buildKeys.addException("org.apache.xalan.xsltc.TransletException");

  final Enumeration elements=elements();

  while (elements.hasMoreElements()) {

    final Object element=elements.nextElement();

    if (element instanceof Key) {

      final Key key=(Key)element;

      key.translate(classGen,buildKeys);

      _keys.put(key.getName(),key);

    }

  }

  il.append(RETURN);

  classGen.addMethod(buildKeys);

  return ("(" + DOM_INTF_SIG + NODE_ITERATOR_SIG+ TRANSLET_OUTPUT_SIG+ "I)V");

}

Location: Stylesheet.java

Content: 

/** 

 * Compile the translet's constructor

 */

private void compileConstructor(ClassGenerator classGen,Output output){

  final ConstantPoolGen cpg=classGen.getConstantPool();

  final InstructionList il=new InstructionList();

  final MethodGenerator constructor=new MethodGenerator(ACC_PUBLIC,org.apache.bcel.generic.Type.VOID,null,null,"<init>",_className,il,cpg);

  il.append(classGen.loadTranslet());

  il.append(new INVOKESPECIAL(cpg.addMethodref(TRANSLET_CLASS,"<init>","()V")));

  constructor.markChunkStart();

  il.append(classGen.loadTranslet());

  il.append(new GETSTATIC(cpg.addFieldref(_className,STATIC_NAMES_ARRAY_FIELD,NAMES_INDEX_SIG)));

  il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,NAMES_INDEX,NAMES_INDEX_SIG)));

  constructor.markChunkEnd();

  constructor.markChunkStart();

  il.append(classGen.loadTranslet());

  il.append(new GETSTATIC(cpg.addFieldref(_className,STATIC_URIS_ARRAY_FIELD,URIS_INDEX_SIG)));

  il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,URIS_INDEX,URIS_INDEX_SIG)));

  constructor.markChunkEnd();

  constructor.markChunkStart();

  il.append(classGen.loadTranslet());

  il.append(new GETSTATIC(cpg.addFieldref(_className,STATIC_TYPES_ARRAY_FIELD,TYPES_INDEX_SIG)));

  il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,TYPES_INDEX,TYPES_INDEX_SIG)));

  constructor.markChunkEnd();

  constructor.markChunkStart();

  il.append(classGen.loadTranslet());

  il.append(new GETSTATIC(cpg.addFieldref(_className,STATIC_NAMESPACE_ARRAY_FIELD,NAMESPACE_INDEX_SIG)));

  il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,NAMESPACE_INDEX,NAMESPACE_INDEX_SIG)));

  constructor.markChunkEnd();

  constructor.markChunkStart();

  il.append(classGen.loadTranslet());

  il.append(new PUSH(cpg,AbstractTranslet.CURRENT_TRANSLET_VERSION));

  il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,TRANSLET_VERSION_INDEX,TRANSLET_VERSION_INDEX_SIG)));

  constructor.markChunkEnd();

  if (_hasIdCall) {

    constructor.markChunkStart();

    il.append(classGen.loadTranslet());

    il.append(new PUSH(cpg,Boolean.TRUE));

    il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,HASIDCALL_INDEX,HASIDCALL_INDEX_SIG)));

    constructor.markChunkEnd();

  }

  if (output != null) {

    constructor.markChunkStart();

    output.translate(classGen,constructor);

    constructor.markChunkEnd();

  }

  if (_numberFormattingUsed) {

    constructor.markChunkStart();

    DecimalFormatting.translateDefaultDFS(classGen,constructor);

    constructor.markChunkEnd();

  }

  il.append(RETURN);

  classGen.addMethod(constructor);

}

Location: Stylesheet.java

Content: 

private void compileModes(ClassGenerator classGen){

  _defaultMode.compileApplyTemplates(classGen);

  final Enumeration modes=_modes.elements();

  while (modes.hasMoreElements()) {

    final Mode mode=(Mode)modes.nextElement();

    mode.compileApplyTemplates(classGen);

  }

}

Location: Stylesheet.java

Content: 

/** 

 * <p> Compile the namesArray, urisArray, typesArray, namespaceArray, namespaceAncestorsArray, prefixURIsIdxArray and prefixURIPairsArray into the static initializer. They are read-only from the translet. All translet instances can share a single copy of this informtion. </p> <p> The <code>namespaceAncestorsArray</code>, <code>prefixURIsIdxArray</code> and <code>prefixURIPairsArray</code> contain namespace information accessible from the stylesheet: <dl> <dt><code>namespaceAncestorsArray</code></dt> <dd>Array indexed by integer stylesheet node IDs containing node IDs of the nearest ancestor node in the stylesheet with namespace declarations or <code>-1</code> if there is no such ancestor. There can be more than one disjoint tree of nodes - one for each stylesheet module</dd> <dt><code>prefixURIsIdxArray</code></dt> <dd>Array indexed by integer stylesheet node IDs containing the index into <code>prefixURIPairsArray</code> of the first namespace prefix declared for the node. The values are stored in ascending order, so the next value in this array (if any) can be used to find the last such prefix-URI pair</dd> <dt>prefixURIPairsArray</dt> <dd>Array of pairs of namespace prefixes and URIs. A zero-length string represents the default namespace if it appears as a prefix and a namespace undeclaration if it appears as a URI.</dd> </dl> </p> <p> For this stylesheet <pre> <code> &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt; &lt;xsl:template match="/"&gt; &lt;xsl:for-each select="*" xmlns:foo="foouri"&gt; &lt;xsl:element name="{n}" xmlns:foo="baruri"&gt; &lt;/xsl:for-each&gt; &lt;out xmlns="lumpit"/&gt; &lt;xsl:element name="{n}" xmlns="foouri"/&gt; &lt;xsl:element name="{n}" namespace="{ns}" xmlns="limpit"/gt; &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; </code> </pre> there will be four stylesheet nodes whose namespace information is needed, and <ul> <li><code>namespaceAncestorsArray</code> will have the value <code>[-1,0,1,0]</code>;</li> <li><code>prefixURIsIdxArray</code> will have the value <code>[0,4,6,8]</code>; and</li> <li><code>prefixURIPairsArray</code> will have the value <code>["xml","http://www.w3.org/XML/1998/namespace", "xsl","http://www.w3.org/1999/XSL/Transform" "foo","foouri","foo","baruri","","foouri"].</code></li> </ul> </p>

 */

private void compileStaticInitializer(ClassGenerator classGen){

  final ConstantPoolGen cpg=classGen.getConstantPool();

  final InstructionList il=new InstructionList();

  final MethodGenerator staticConst=new MethodGenerator(ACC_PUBLIC | ACC_STATIC,org.apache.bcel.generic.Type.VOID,null,null,"<clinit>",_className,il,cpg);

  addStaticField(classGen,"[" + STRING_SIG,STATIC_NAMES_ARRAY_FIELD);

  addStaticField(classGen,"[" + STRING_SIG,STATIC_URIS_ARRAY_FIELD);

  addStaticField(classGen,"[I",STATIC_TYPES_ARRAY_FIELD);

  addStaticField(classGen,"[" + STRING_SIG,STATIC_NAMESPACE_ARRAY_FIELD);

  final int charDataFieldCount=getXSLTC().getCharacterDataCount();

  for (int i=0; i < charDataFieldCount; i++) {

    addStaticField(classGen,STATIC_CHAR_DATA_FIELD_SIG,STATIC_CHAR_DATA_FIELD + i);

  }

  final Vector namesIndex=getXSLTC().getNamesIndex();

  int size=namesIndex.size();

  String[] namesArray=new String[size];

  String[] urisArray=new String[size];

  int[] typesArray=new int[size];

  int index;

  for (int i=0; i < size; i++) {

    String encodedName=(String)namesIndex.elementAt(i);

    if ((index=encodedName.lastIndexOf(':')) > -1) {

      urisArray[i]=encodedName.substring(0,index);

    }

    index=index + 1;

    if (encodedName.charAt(index) == '@') {

      typesArray[i]=DTM.ATTRIBUTE_NODE;

      index++;

    }

 else     if (encodedName.charAt(index) == '?') {

      typesArray[i]=DTM.NAMESPACE_NODE;

      index++;

    }

 else {

      typesArray[i]=DTM.ELEMENT_NODE;

    }

    if (index == 0) {

      namesArray[i]=encodedName;

    }

 else {

      namesArray[i]=encodedName.substring(index);

    }

  }

  staticConst.markChunkStart();

  il.append(new PUSH(cpg,size));

  il.append(new ANEWARRAY(cpg.addClass(STRING)));

  int namesArrayRef=cpg.addFieldref(_className,STATIC_NAMES_ARRAY_FIELD,NAMES_INDEX_SIG);

  il.append(new PUTSTATIC(namesArrayRef));

  staticConst.markChunkEnd();

  for (int i=0; i < size; i++) {

    final String name=namesArray[i];

    staticConst.markChunkStart();

    il.append(new GETSTATIC(namesArrayRef));

    il.append(new PUSH(cpg,i));

    il.append(new PUSH(cpg,name));

    il.append(AASTORE);

    staticConst.markChunkEnd();

  }

  staticConst.markChunkStart();

  il.append(new PUSH(cpg,size));

  il.append(new ANEWARRAY(cpg.addClass(STRING)));

  int urisArrayRef=cpg.addFieldref(_className,STATIC_URIS_ARRAY_FIELD,URIS_INDEX_SIG);

  il.append(new PUTSTATIC(urisArrayRef));

  staticConst.markChunkEnd();

  for (int i=0; i < size; i++) {

    final String uri=urisArray[i];

    staticConst.markChunkStart();

    il.append(new GETSTATIC(urisArrayRef));

    il.append(new PUSH(cpg,i));

    il.append(new PUSH(cpg,uri));

    il.append(AASTORE);

    staticConst.markChunkEnd();

  }

  staticConst.markChunkStart();

  il.append(new PUSH(cpg,size));

  il.append(new NEWARRAY(BasicType.INT));

  int typesArrayRef=cpg.addFieldref(_className,STATIC_TYPES_ARRAY_FIELD,TYPES_INDEX_SIG);

  il.append(new PUTSTATIC(typesArrayRef));

  staticConst.markChunkEnd();

  for (int i=0; i < size; i++) {

    final int nodeType=typesArray[i];

    staticConst.markChunkStart();

    il.append(new GETSTATIC(typesArrayRef));

    il.append(new PUSH(cpg,i));

    il.append(new PUSH(cpg,nodeType));

    il.append(IASTORE);

    staticConst.markChunkEnd();

  }

  final Vector namespaces=getXSLTC().getNamespaceIndex();

  staticConst.markChunkStart();

  il.append(new PUSH(cpg,namespaces.size()));

  il.append(new ANEWARRAY(cpg.addClass(STRING)));

  int namespaceArrayRef=cpg.addFieldref(_className,STATIC_NAMESPACE_ARRAY_FIELD,NAMESPACE_INDEX_SIG);

  il.append(new PUTSTATIC(namespaceArrayRef));

  staticConst.markChunkEnd();

  for (int i=0; i < namespaces.size(); i++) {

    final String ns=(String)namespaces.elementAt(i);

    staticConst.markChunkStart();

    il.append(new GETSTATIC(namespaceArrayRef));

    il.append(new PUSH(cpg,i));

    il.append(new PUSH(cpg,ns));

    il.append(AASTORE);

    staticConst.markChunkEnd();

  }

  final Vector namespaceAncestors=getXSLTC().getNSAncestorPointers();

  if (namespaceAncestors != null && namespaceAncestors.size() != 0) {

    addStaticField(classGen,NS_ANCESTORS_INDEX_SIG,STATIC_NS_ANCESTORS_ARRAY_FIELD);

    staticConst.markChunkStart();

    il.append(new PUSH(cpg,namespaceAncestors.size()));

    il.append(new NEWARRAY(BasicType.INT));

    int namespaceAncestorsArrayRef=cpg.addFieldref(_className,STATIC_NS_ANCESTORS_ARRAY_FIELD,NS_ANCESTORS_INDEX_SIG);

    il.append(new PUTSTATIC(namespaceAncestorsArrayRef));

    staticConst.markChunkEnd();

    for (int i=0; i < namespaceAncestors.size(); i++) {

      int ancestor=((Integer)namespaceAncestors.get(i)).intValue();

      staticConst.markChunkStart();

      il.append(new GETSTATIC(namespaceAncestorsArrayRef));

      il.append(new PUSH(cpg,i));

      il.append(new PUSH(cpg,ancestor));

      il.append(IASTORE);

      staticConst.markChunkEnd();

    }

  }

  final Vector prefixURIPairsIdx=getXSLTC().getPrefixURIPairsIdx();

  if (prefixURIPairsIdx != null && prefixURIPairsIdx.size() != 0) {

    addStaticField(classGen,PREFIX_URIS_IDX_SIG,STATIC_PREFIX_URIS_IDX_ARRAY_FIELD);

    staticConst.markChunkStart();

    il.append(new PUSH(cpg,prefixURIPairsIdx.size()));

    il.append(new NEWARRAY(BasicType.INT));

    int prefixURIPairsIdxArrayRef=cpg.addFieldref(_className,STATIC_PREFIX_URIS_IDX_ARRAY_FIELD,PREFIX_URIS_IDX_SIG);

    il.append(new PUTSTATIC(prefixURIPairsIdxArrayRef));

    staticConst.markChunkEnd();

    for (int i=0; i < prefixURIPairsIdx.size(); i++) {

      int idx=((Integer)prefixURIPairsIdx.get(i)).intValue();

      staticConst.markChunkStart();

      il.append(new GETSTATIC(prefixURIPairsIdxArrayRef));

      il.append(new PUSH(cpg,i));

      il.append(new PUSH(cpg,idx));

      il.append(IASTORE);

      staticConst.markChunkEnd();

    }

  }

  final Vector prefixURIPairs=getXSLTC().getPrefixURIPairs();

  if (prefixURIPairs != null && prefixURIPairs.size() != 0) {

    addStaticField(classGen,PREFIX_URIS_ARRAY_SIG,STATIC_PREFIX_URIS_ARRAY_FIELD);

    staticConst.markChunkStart();

    il.append(new PUSH(cpg,prefixURIPairs.size()));

    il.append(new ANEWARRAY(cpg.addClass(STRING)));

    int prefixURIPairsRef=cpg.addFieldref(_className,STATIC_PREFIX_URIS_ARRAY_FIELD,PREFIX_URIS_ARRAY_SIG);

    il.append(new PUTSTATIC(prefixURIPairsRef));

    staticConst.markChunkEnd();

    for (int i=0; i < prefixURIPairs.size(); i++) {

      String prefixOrURI=(String)prefixURIPairs.get(i);

      staticConst.markChunkStart();

      il.append(new GETSTATIC(prefixURIPairsRef));

      il.append(new PUSH(cpg,i));

      il.append(new PUSH(cpg,prefixOrURI));

      il.append(AASTORE);

      staticConst.markChunkEnd();

    }

  }

  final int charDataCount=getXSLTC().getCharacterDataCount();

  final int toCharArray=cpg.addMethodref(STRING,"toCharArray","()[C");

  for (int i=0; i < charDataCount; i++) {

    staticConst.markChunkStart();

    il.append(new PUSH(cpg,getXSLTC().getCharacterData(i)));

    il.append(new INVOKEVIRTUAL(toCharArray));

    il.append(new PUTSTATIC(cpg.addFieldref(_className,STATIC_CHAR_DATA_FIELD + i,STATIC_CHAR_DATA_FIELD_SIG)));

    staticConst.markChunkEnd();

  }

  il.append(RETURN);

  classGen.addMethod(staticConst);

}

Location: Stylesheet.java

Content: 

/** 

 * Compile a topLevel() method into the output class. This method is called from transform() to handle all non-template top-level elements. Returns the signature of the topLevel() method. Global variables/params and keys are first sorted to resolve dependencies between them. The XSLT 1.0 spec does not allow a key to depend on a variable. However, for compatibility with Xalan interpretive, that type of dependency is allowed. Note also that the buildKeys() method is still generated as it is used by the LoadDocument class, but it no longer called from transform().

 */

private String compileTopLevel(ClassGenerator classGen){

  final ConstantPoolGen cpg=classGen.getConstantPool();

  final org.apache.bcel.generic.Type[] argTypes={Util.getJCRefType(DOM_INTF_SIG),Util.getJCRefType(NODE_ITERATOR_SIG),Util.getJCRefType(TRANSLET_OUTPUT_SIG)};

  final String[] argNames={DOCUMENT_PNAME,ITERATOR_PNAME,TRANSLET_OUTPUT_PNAME};

  final InstructionList il=new InstructionList();

  final MethodGenerator toplevel=new MethodGenerator(ACC_PUBLIC,org.apache.bcel.generic.Type.VOID,argTypes,argNames,"topLevel",_className,il,classGen.getConstantPool());

  toplevel.addException("org.apache.xalan.xsltc.TransletException");

  final LocalVariableGen current=toplevel.addLocalVariable("current",org.apache.bcel.generic.Type.INT,null,null);

  final int setFilter=cpg.addInterfaceMethodref(DOM_INTF,"setFilter","(Lorg/apache/xalan/xsltc/StripFilter;)V");

  final int gitr=cpg.addInterfaceMethodref(DOM_INTF,"getIterator","()" + NODE_ITERATOR_SIG);

  il.append(toplevel.loadDOM());

  il.append(new INVOKEINTERFACE(gitr,1));

  il.append(toplevel.nextNode());

  current.setStart(il.append(new ISTORE(current.getIndex())));

  Vector varDepElements=new Vector(_globals);

  Enumeration elements=elements();

  while (elements.hasMoreElements()) {

    final Object element=elements.nextElement();

    if (element instanceof Key) {

      varDepElements.add(element);

    }

  }

  varDepElements=resolveDependencies(varDepElements);

  final int count=varDepElements.size();

  for (int i=0; i < count; i++) {

    final TopLevelElement tle=(TopLevelElement)varDepElements.elementAt(i);

    tle.translate(classGen,toplevel);

    if (tle instanceof Key) {

      final Key key=(Key)tle;

      _keys.put(key.getName(),key);

    }

  }

  Vector whitespaceRules=new Vector();

  elements=elements();

  while (elements.hasMoreElements()) {

    final Object element=elements.nextElement();

    if (element instanceof DecimalFormatting) {

      ((DecimalFormatting)element).translate(classGen,toplevel);

    }

 else     if (element instanceof Whitespace) {

      whitespaceRules.addAll(((Whitespace)element).getRules());

    }

  }

  if (whitespaceRules.size() > 0) {

    Whitespace.translateRules(whitespaceRules,classGen);

  }

  if (classGen.containsMethod(STRIP_SPACE,STRIP_SPACE_PARAMS) != null) {

    il.append(toplevel.loadDOM());

    il.append(classGen.loadTranslet());

    il.append(new INVOKEINTERFACE(setFilter,2));

  }

  il.append(RETURN);

  classGen.addMethod(toplevel);

  return ("(" + DOM_INTF_SIG + NODE_ITERATOR_SIG+ TRANSLET_OUTPUT_SIG+ ")V");

}

Location: Stylesheet.java

Content: 

/** 

 * Compile transform() into the output class. This method is used to initialize global variables and global parameters. The current node is set to be the document's root node.

 */

private void compileTransform(ClassGenerator classGen){

  final ConstantPoolGen cpg=classGen.getConstantPool();

  final org.apache.bcel.generic.Type[] argTypes=new org.apache.bcel.generic.Type[3];

  argTypes[0]=Util.getJCRefType(DOM_INTF_SIG);

  argTypes[1]=Util.getJCRefType(NODE_ITERATOR_SIG);

  argTypes[2]=Util.getJCRefType(TRANSLET_OUTPUT_SIG);

  final String[] argNames=new String[3];

  argNames[0]=DOCUMENT_PNAME;

  argNames[1]=ITERATOR_PNAME;

  argNames[2]=TRANSLET_OUTPUT_PNAME;

  final InstructionList il=new InstructionList();

  final MethodGenerator transf=new MethodGenerator(ACC_PUBLIC,org.apache.bcel.generic.Type.VOID,argTypes,argNames,"transform",_className,il,classGen.getConstantPool());

  transf.addException("org.apache.xalan.xsltc.TransletException");

  final LocalVariableGen current=transf.addLocalVariable("current",org.apache.bcel.generic.Type.INT,null,null);

  final String applyTemplatesSig=classGen.getApplyTemplatesSig();

  final int applyTemplates=cpg.addMethodref(getClassName(),"applyTemplates",applyTemplatesSig);

  final int domField=cpg.addFieldref(getClassName(),DOM_FIELD,DOM_INTF_SIG);

  il.append(classGen.loadTranslet());

  if (isMultiDocument()) {

    il.append(new NEW(cpg.addClass(MULTI_DOM_CLASS)));

    il.append(DUP);

  }

  il.append(classGen.loadTranslet());

  il.append(transf.loadDOM());

  il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,"makeDOMAdapter","(" + DOM_INTF_SIG + ")"+ DOM_ADAPTER_SIG)));

  if (isMultiDocument()) {

    final int init=cpg.addMethodref(MULTI_DOM_CLASS,"<init>","(" + DOM_INTF_SIG + ")V");

    il.append(new INVOKESPECIAL(init));

  }

  il.append(new PUTFIELD(domField));

  final int gitr=cpg.addInterfaceMethodref(DOM_INTF,"getIterator","()" + NODE_ITERATOR_SIG);

  il.append(transf.loadDOM());

  il.append(new INVOKEINTERFACE(gitr,1));

  il.append(transf.nextNode());

  current.setStart(il.append(new ISTORE(current.getIndex())));

  il.append(classGen.loadTranslet());

  il.append(transf.loadHandler());

  final int index=cpg.addMethodref(TRANSLET_CLASS,"transferOutputSettings","(" + OUTPUT_HANDLER_SIG + ")V");

  il.append(new INVOKEVIRTUAL(index));

  final String keySig=compileBuildKeys(classGen);

  final int keyIdx=cpg.addMethodref(getClassName(),"buildKeys",keySig);

  final Enumeration toplevel=elements();

  if (_globals.size() > 0 || toplevel.hasMoreElements()) {

    final String topLevelSig=compileTopLevel(classGen);

    final int topLevelIdx=cpg.addMethodref(getClassName(),"topLevel",topLevelSig);

    il.append(classGen.loadTranslet());

    il.append(classGen.loadTranslet());

    il.append(new GETFIELD(domField));

    il.append(transf.loadIterator());

    il.append(transf.loadHandler());

    il.append(new INVOKEVIRTUAL(topLevelIdx));

  }

  il.append(transf.loadHandler());

  il.append(transf.startDocument());

  il.append(classGen.loadTranslet());

  il.append(classGen.loadTranslet());

  il.append(new GETFIELD(domField));

  il.append(transf.loadIterator());

  il.append(transf.loadHandler());

  il.append(new INVOKEVIRTUAL(applyTemplates));

  il.append(transf.loadHandler());

  il.append(transf.endDocument());

  il.append(RETURN);

  classGen.addMethod(transf);

}

Location: Stylesheet.java

Content: 

public void declareExtensionPrefixes(Parser parser){

  final SymbolTable stable=parser.getSymbolTable();

  final String extensionPrefixes=getAttribute("extension-element-prefixes");

  extensionURI(extensionPrefixes,stable);

}

Location: Stylesheet.java

Content: 

/** 

 * Store extension URIs

 */

private void extensionURI(String prefixes,SymbolTable stable){

  if (prefixes != null) {

    StringTokenizer tokens=new StringTokenizer(prefixes);

    while (tokens.hasMoreTokens()) {

      final String prefix=tokens.nextToken();

      final String uri=lookupNamespace(prefix);

      if (uri != null) {

        _extensions.put(uri,prefix);

      }

    }

  }

}

Location: Stylesheet.java

Content: 

public Vector getAllValidTemplates(){

  if (_includedStylesheets == null) {

    return _templates;

  }

  if (_allValidTemplates == null) {

    Vector templates=new Vector();

    int size=_includedStylesheets.size();

    for (int i=0; i < size; i++) {

      Stylesheet included=(Stylesheet)_includedStylesheets.elementAt(i);

      templates.addAll(included.getAllValidTemplates());

    }

    templates.addAll(_templates);

    if (_parentStylesheet != null) {

      return templates;

    }

    _allValidTemplates=templates;

  }

  return _allValidTemplates;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:attribute-set" properties.

 * @see <a href="http://www.w3.org/TR/xslt#attribute-sets">attribute-sets in

	 *      XSLT Specification</a>

 * @return the number of "xsl:attribute-set" properties.

 */

public int getAttributeSetCount(){

  return (null != m_attributeSets) ? m_attributeSets.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:attribute-set" property.

 * @see <a href="http://www.w3.org/TR/xslt#attribute-sets">attribute-sets in

	 *      XSLT Specification</a>

 * @param i Index of ElemAttributeSet to get in list

 * @return ElemAttributeSet at the given index

 * @throws ArrayIndexOutOfBoundsException

 */

public ElemAttributeSet getAttributeSet(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_attributeSets)   throw new ArrayIndexOutOfBoundsException();

  return (ElemAttributeSet)m_attributeSets.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get whether or not the stylesheet is in "Forward Compatibility Mode"

 * @return true if in forward compatible mode, false otherwise

 */

public boolean getCompatibleMode(){

  return m_isCompatibleMode;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of xsl:decimal-format declarations.

 * @see DecimalFormatProperties

 * @return the number of xsl:decimal-format declarations.

 */

public int getDecimalFormatCount(){

  return (null != m_DecimalFormatDeclarations) ? m_DecimalFormatDeclarations.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:decimal-format" property.

 * @see <a href="http://www.w3.org/TR/xslt#format-number">format-number in XSLT

	 *      Specification</a>

 * @see DecimalFormatProperties

 * @param i Index of decimal-format property in stack

 * @return The decimal-format property at the given index

 * @throws ArrayIndexOutOfBoundsException

 */

public DecimalFormatProperties getDecimalFormat(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_DecimalFormatDeclarations)   throw new ArrayIndexOutOfBoundsException();

  return (DecimalFormatProperties)m_DecimalFormatDeclarations.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:decimal-format" property.

 * @see DecimalFormatProperties

 * @see <a href="http://www.w3.org/TR/xslt#format-number">format-number in XSLT

	 *      Specification</a>

 * @param name The qualified name of the decimal format property.

 * @return null if not found, otherwise a DecimalFormatProperties object, fromwhich you can get a DecimalFormatSymbols object.

 */

public DecimalFormatProperties getDecimalFormat(QName name){

  if (null == m_DecimalFormatDeclarations)   return null;

  int n=getDecimalFormatCount();

  for (int i=(n - 1); i >= 0; i++) {

    DecimalFormatProperties dfp=getDecimalFormat(i);

    if (dfp.getName().equals(name))     return dfp;

  }

  return null;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "exclude-result-prefixes" Strings.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#literal-result-element">literal-result-element

	 *      in XSLT Specification</a>

 * @return The number of prefix strings to be excluded.

 */

public int getExcludeResultPrefixCount(){

  return (null != m_ExcludeResultPrefixs) ? m_ExcludeResultPrefixs.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "exclude-result-prefix" property. The designation of a namespace as an excluded namespace is effective within the subtree of the stylesheet rooted at the element bearing the exclude-result-prefixes or xsl:exclude-result-prefixes attribute; a subtree rooted at an xsl:stylesheet element does not include any stylesheets imported or included by children of that xsl:stylesheet element.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#literal-result-element">literal-result-element

	 *      in XSLT Specification</a>

 * @param i Index of prefix to get in list

 * @return Prefix to be excluded at the given index

 * @throws ArrayIndexOutOfBoundsException

 */

public String getExcludeResultPrefix(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_ExcludeResultPrefixs)   throw new ArrayIndexOutOfBoundsException();

  return m_ExcludeResultPrefixs.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get the base identifier with which this stylesheet is associated.

 * @return the base identifier with which this stylesheet is associated.

 */

public String getHref(){

  return m_href;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the "id" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#section-Embedding-Stylesheets">section-Embedding-Stylesheets

	 *      in XSLT Specification</a>

 * @return The value of the "id" property.

 */

public String getId(){

  return m_Id;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of imported stylesheets.

 * @see <a href="http://www.w3.org/TR/xslt#import">import in XSLT

	 *      Specification</a>

 * @return the number of imported stylesheets.

 */

public int getImportCount(){

  return (null != m_imports) ? m_imports.size() : 0;

}

Location: Stylesheet.java

Content: 

public int getImportPrecedence(){

  return _importPrecedence;

}

Location: Stylesheet.java

Content: 

/** 

 * Get a stylesheet from the "import" list.

 * @see <a href="http://www.w3.org/TR/xslt#import">import in XSLT

	 *      Specification</a>

 * @param i Index of the stylesheet to get

 * @return The stylesheet at the given index

 * @throws ArrayIndexOutOfBoundsException

 */

public StylesheetComposed getImport(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_imports)   throw new ArrayIndexOutOfBoundsException();

  return (StylesheetComposed)m_imports.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of included stylesheets.

 * @see <a href="http://www.w3.org/TR/xslt#import">import in XSLT

	 *      Specification</a>

 * @return the number of included stylesheets.

 */

public int getIncludeCount(){

  return (null != m_includes) ? m_includes.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the stylesheet at the given in index in "include" list

 * @see <a href="http://www.w3.org/TR/xslt#include">include in XSLT

	 *      Specification</a>

 * @param i Index of stylesheet to get

 * @return Stylesheet at the given index

 * @throws ArrayIndexOutOfBoundsException

 */

public Stylesheet getInclude(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_includes)   throw new ArrayIndexOutOfBoundsException();

  return (Stylesheet)m_includes.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:key" properties.

 * @see <a href="http://www.w3.org/TR/xslt#key">key in XSLT Specification</a>

 * @return the number of "xsl:key" properties.

 */

public int getKeyCount(){

  return (null != m_keyDeclarations) ? m_keyDeclarations.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:key" property.

 * @see <a href="http://www.w3.org/TR/xslt#key">key in XSLT Specification</a>

 * @param i Index of KeyDeclaration element to get

 * @return KeyDeclaration element at given index in list

 * @throws ArrayIndexOutOfBoundsException

 */

public KeyDeclaration getKey(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_keyDeclarations)   throw new ArrayIndexOutOfBoundsException();

  return (KeyDeclaration)m_keyDeclarations.elementAt(i);

}

Location: Stylesheet.java

Content: 

public Output getLastOutputElement(){

  return _lastOutputElement;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the minimum of the precedence of this stylesheet, any stylesheet imported by this stylesheet and any include/import descendant of this stylesheet.

 */

public int getMinimumDescendantPrecedence(){

  if (_minimumDescendantPrecedence == -1) {

    int min=getImportPrecedence();

    final int inclImpCount=(_includedStylesheets != null) ? _includedStylesheets.size() : 0;

    for (int i=0; i < inclImpCount; i++) {

      int prec=((Stylesheet)_includedStylesheets.elementAt(i)).getMinimumDescendantPrecedence();

      if (prec < min) {

        min=prec;

      }

    }

    _minimumDescendantPrecedence=min;

  }

  return _minimumDescendantPrecedence;

}

Location: Stylesheet.java

Content: 

public Mode getMode(QName modeName){

  if (modeName == null) {

    if (_defaultMode == null) {

      _defaultMode=new Mode(null,this,Constants.EMPTYSTRING);

    }

    return _defaultMode;

  }

 else {

    Mode mode=(Mode)_modes.get(modeName);

    if (mode == null) {

      final String suffix=Integer.toString(_nextModeSerial++);

      _modes.put(modeName,mode=new Mode(modeName,this,suffix));

    }

    return mode;

  }

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:namespace-alias" properties.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @return the number of "xsl:namespace-alias" properties.

 */

public int getNamespaceAliasCount(){

  return (null != m_prefix_aliases) ? m_prefix_aliases.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:namespace-alias" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#literal-result-element">literal-result-element

	 *      in XSLT Specification</a>

 * @param i Index of NamespaceAlias element to get from the list

 * @return NamespaceAlias element at the given index in the list

 * @throws ArrayIndexOutOfBoundsException

 */

public NamespaceAlias getNamespaceAlias(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_prefix_aliases)   throw new ArrayIndexOutOfBoundsException();

  return (NamespaceAlias)m_prefix_aliases.elementAt(i);

}

Location: Stylesheet.java

Content: 

public String getNamespace(String prefix){

  return lookupNamespace(prefix);

}

Location: Stylesheet.java

Content: 

/** 

 * Get a non-xslt element.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#stylesheet-element">stylesheet-element in

	 *      XSLT Specification</a>

 * @param name Qualified name of the element to get

 * @return The object associate with the given name

 */

public Object getNonXslTopLevel(QName name){

  return (null != m_NonXslTopLevel) ? m_NonXslTopLevel.get(name) : null;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:output" properties.

 * @see <a href="http://www.w3.org/TR/xslt#output">output in XSLT

	 *      Specification</a>

 * @return The number of OutputProperties objects contained in this stylesheet.

 */

public int getOutputCount(){

  return (null != m_output) ? m_output.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Return the output method

 */

public int getOutputMethod(){

  return _outputMethod;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:output" property.

 * @see <a href="http://www.w3.org/TR/xslt#output">output in XSLT

	 *      Specification</a>

 * @param i Index of OutputFormatExtended to get

 * @return non-null reference to an OutputProperties object.

 * @throws ArrayIndexOutOfBoundsException

 */

public OutputProperties getOutput(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_output)   throw new ArrayIndexOutOfBoundsException();

  return (OutputProperties)m_output.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:param" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @param qname non-null reference to qualified name of the parameter.

 * @return ElemParam with the given name in the list or null

 */

public ElemParam getParam(QName qname){

  if (null != m_topLevelVariables) {

    int n=getVariableOrParamCount();

    for (int i=0; i < n; i++) {

      ElemVariable var=getVariableOrParam(i);

      if ((var.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE) && (var.getName().equals(qname)))       return (ElemParam)var;

    }

  }

  return null;

}

Location: Stylesheet.java

Content: 

public Stylesheet getParentStylesheet(){

  return _parentStylesheet;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:preserve-space" properties.

 * @see <a href="http://www.w3.org/TR/xslt#strip">strip in XSLT

	 *      Specification</a>

 * @return the number of "xsl:preserve-space" properties.

 */

public int getPreserveSpaceCount(){

  return (null != m_whitespacePreservingElements) ? m_whitespacePreservingElements.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get a "xsl:preserve-space" property.

 * @see <a href="http://www.w3.org/TR/xslt#strip">strip in XSLT

	 *      Specification</a>

 * @param i Index of WhiteSpaceInfo to get

 * @return WhiteSpaceInfo at the given index

 * @throws ArrayIndexOutOfBoundsException

 */

public WhiteSpaceInfo getPreserveSpace(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_whitespacePreservingElements)   throw new ArrayIndexOutOfBoundsException();

  return (WhiteSpaceInfo)m_whitespacePreservingElements.elementAt(i);

}

Location: Stylesheet.java

Content: 

public SourceLoader getSourceLoader(){

  return _loader;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:strip-space" properties.

 * @see <a href="http://www.w3.org/TR/xslt#strip">strip in XSLT

	 *      Specification</a>

 * @return the number of "xsl:strip-space" properties.

 */

public int getStripSpaceCount(){

  return (null != m_whitespaceStrippingElements) ? m_whitespaceStrippingElements.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:strip-space" property.

 * @see <a href="http://www.w3.org/TR/xslt#strip">strip in XSLT

	 *      Specification</a>

 * @param i Index of WhiteSpaceInfo to get

 * @return WhiteSpaceInfo at given index

 * @throws ArrayIndexOutOfBoundsException

 */

public WhiteSpaceInfo getStripSpace(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_whitespaceStrippingElements)   throw new ArrayIndexOutOfBoundsException();

  return (WhiteSpaceInfo)m_whitespaceStrippingElements.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get the owning aggregated stylesheet, or this stylesheet if it is aggregated.

 * @return the owning aggregated stylesheet or itself

 */

public StylesheetComposed getStylesheetComposed(){

  Stylesheet sheet=this;

  while (!sheet.isAggregatedType()) {

    sheet=sheet.getStylesheetParent();

  }

  return (StylesheetComposed)sheet;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the parent of the stylesheet. This will be null if this is the root stylesheet.

 * @return the parent of the stylesheet.

 */

public Stylesheet getStylesheetParent(){

  return m_stylesheetParent;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the root of the stylesheet, where all the tables common to all stylesheets are kept.

 * @return the root of the stylesheet

 */

public StylesheetRoot getStylesheetRoot(){

  return m_stylesheetRoot;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:template" properties.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#section-Defining-Template-Rules">section-Defining-Template-Rules

	 *      in XSLT Specification</a>

 * @return the number of "xsl:template" properties.

 */

public int getTemplateCount(){

  return (null != m_templates) ? m_templates.size() : 0;

}

Location: Stylesheet.java

Content: 

public boolean getTemplateInlining(){

  return _templateInlining;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:template" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#section-Defining-Template-Rules">section-Defining-Template-Rules

	 *      in XSLT Specification</a>

 * @param i Index of ElemTemplate in the list to get

 * @return ElemTemplate at the given index in the list

 * @throws TransformerException

 */

public ElemTemplate getTemplate(int i) throws TransformerException {

  if (null == m_templates)   throw new ArrayIndexOutOfBoundsException();

  return (ElemTemplate)m_templates.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get the number of "xsl:variable" properties.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @return the number of "xsl:variable" properties.

 */

public int getVariableOrParamCount(){

  return (null != m_topLevelVariables) ? m_topLevelVariables.size() : 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:variable" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @param i Index of variable to get in the list

 * @return ElemVariable at the given index in the list

 * @throws ArrayIndexOutOfBoundsException

 */

public ElemVariable getVariableOrParam(int i) throws ArrayIndexOutOfBoundsException {

  if (null == m_topLevelVariables)   throw new ArrayIndexOutOfBoundsException();

  return (ElemVariable)m_topLevelVariables.elementAt(i);

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:variable" or "xsl:param" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @param qname non-null reference to the qualified name of the variable.

 * @return The ElemVariable with the given name in the list or null

 */

public ElemVariable getVariableOrParam(QName qname){

  if (null != m_topLevelVariables) {

    int n=getVariableOrParamCount();

    for (int i=0; i < n; i++) {

      ElemVariable var=(ElemVariable)getVariableOrParam(i);

      if (var.getName().equals(qname))       return var;

    }

  }

  return null;

}

Location: Stylesheet.java

Content: 

/** 

 * Get an "xsl:variable" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @param qname Qualified name of the xsl:variable to get

 * @return reference to the variable named by qname, or null if not found.

 */

public ElemVariable getVariable(QName qname){

  if (null != m_topLevelVariables) {

    int n=getVariableOrParamCount();

    for (int i=0; i < n; i++) {

      ElemVariable var=getVariableOrParam(i);

      if ((var.getXSLToken() == Constants.ELEMNAME_VARIABLE) && (var.getName().equals(qname)))       return var;

    }

  }

  return null;

}

Location: Stylesheet.java

Content: 

/** 

 * Get the "xmlns:xsl" property.

 * @see <a href="http://www.w3.org/TR/xslt#xslt-namespace">xslt-namespace in

	 *      XSLT Specification</a>

 * @return The value of the "xmlns:xsl" property.

 */

public String getXmlnsXsl(){

  return m_XmlnsXsl;

}

Location: Stylesheet.java

Content: 

/** 

 * Returns true if this stylesheet has global vars or params.

 */

public boolean hasGlobals(){

  return _globals.size() > 0;

}

Location: Stylesheet.java

Content: 

/** 

 * Returns true if at least one template in the stylesheet has params defined. Uses the variable <code>_hasLocalParams</code> to cache the result.

 */

public boolean hasLocalParams(){

  if (_hasLocalParams == null) {

    Vector templates=getAllValidTemplates();

    final int n=templates.size();

    for (int i=0; i < n; i++) {

      final Template template=(Template)templates.elementAt(i);

      if (template.hasParams()) {

        _hasLocalParams=Boolean.TRUE;

        return true;

      }

    }

    _hasLocalParams=Boolean.FALSE;

    return false;

  }

 else {

    return _hasLocalParams.booleanValue();

  }

}

Location: Stylesheet.java

Content: 

/** 

 * Tell if this can be cast to a StylesheetComposed, meaning, you can ask questions from getXXXComposed functions.

 * @return False if this is not a StylesheetComposed

 */

public boolean isAggregatedType(){

  return false;

}

Location: Stylesheet.java

Content: 

public boolean isExtension(String uri){

  return (_extensions.get(uri) != null);

}

Location: Stylesheet.java

Content: 

public boolean isMultiDocument(){

  return _multiDocument;

}

Location: Stylesheet.java

Content: 

/** 

 * Tell if this is the root of the stylesheet tree.

 * @return False is this is not the root of the stylesheet tree.

 */

public boolean isRoot(){

  return false;

}

Location: Stylesheet.java

Content: 

public boolean isSimplified(){

  return (_simplified);

}

Location: Stylesheet.java

Content: 

private QName makeStylesheetName(String prefix){

  return getParser().getQName(prefix + getXSLTC().nextStylesheetSerial());

}

Location: Stylesheet.java

Content: 

public void numberFormattingUsed(){

  _numberFormattingUsed=true;

  Stylesheet parent=getParentStylesheet();

  if (null != parent)   parent.numberFormattingUsed();

}

Location: Stylesheet.java

Content: 

/** 

 * Parse all direct children of the <xsl:stylesheet/> element.

 */

public final void parseOwnChildren(Parser parser){

  final SymbolTable stable=parser.getSymbolTable();

  final String excludePrefixes=getAttribute("exclude-result-prefixes");

  final String extensionPrefixes=getAttribute("extension-element-prefixes");

  stable.pushExcludedNamespacesContext();

  stable.excludeURI(Constants.XSLT_URI);

  stable.excludeNamespaces(excludePrefixes);

  stable.excludeNamespaces(extensionPrefixes);

  final Vector contents=getContents();

  final int count=contents.size();

  for (int i=0; i < count; i++) {

    SyntaxTreeNode child=(SyntaxTreeNode)contents.elementAt(i);

    if ((child instanceof VariableBase) || (child instanceof NamespaceAlias)) {

      parser.getSymbolTable().setCurrentNode(child);

      child.parseContents(parser);

    }

  }

  for (int i=0; i < count; i++) {

    SyntaxTreeNode child=(SyntaxTreeNode)contents.elementAt(i);

    if (!(child instanceof VariableBase) && !(child instanceof NamespaceAlias)) {

      parser.getSymbolTable().setCurrentNode(child);

      child.parseContents(parser);

    }

    if (!_templateInlining && (child instanceof Template)) {

      Template template=(Template)child;

      String name="template$dot$" + template.getPosition();

      template.setName(parser.getQName(name));

    }

  }

  stable.popExcludedNamespacesContext();

}

Location: Stylesheet.java

Content: 

/** 

 * Peephole optimization: Remove sequences of [ALOAD, POP].

 */

private void peepHoleOptimization(MethodGenerator methodGen){

  final String pattern="`aload'`pop'`instruction'";

  final InstructionList il=methodGen.getInstructionList();

  final InstructionFinder find=new InstructionFinder(il);

  for (Iterator iter=find.search(pattern); iter.hasNext(); ) {

    InstructionHandle[] match=(InstructionHandle[])iter.next();

    try {

      il.delete(match[0],match[1]);

    }

 catch (    TargetLostException e) {

    }

  }

}

Location: Stylesheet.java

Content: 

public void processModes(){

  if (_defaultMode == null)   _defaultMode=new Mode(null,this,Constants.EMPTYSTRING);

  _defaultMode.processPatterns(_keys);

  final Enumeration modes=_modes.elements();

  while (modes.hasMoreElements()) {

    final Mode mode=(Mode)modes.nextElement();

    mode.processPatterns(_keys);

  }

}

Location: Stylesheet.java

Content: 

/** 

 * Replace an "xsl:template" property. This is a hook for CompilingStylesheetHandler, to allow us to access a template, compile it, instantiate it, and replace the original with the compiled instance. ADDED 9/5/2000 to support compilation experiment

 * @param v Compiled template to replace with

 * @param i Index of template to be replaced

 * @throws TransformerException

 */

public void replaceTemplate(ElemTemplate v,int i) throws TransformerException {

  if (null == m_templates)   throw new ArrayIndexOutOfBoundsException();

  replaceChild(v,(ElemTemplateElement)m_templates.elementAt(i));

  m_templates.setElementAt(v,i);

  v.setStylesheet(this);

}

Location: Stylesheet.java

Content: 

/** 

 * This method returns a vector with variables/params and keys in the order in which they are to be compiled for initialization. The order is determined by analyzing the dependencies between them. The XSLT 1.0 spec does not allow a key to depend on a variable. However, for compatibility with Xalan interpretive, that type of dependency is allowed and, therefore, consider to determine the partial order.

 */

private Vector resolveDependencies(Vector input){

  Vector result=new Vector();

  while (input.size() > 0) {

    boolean changed=false;

    for (int i=0; i < input.size(); ) {

      final TopLevelElement vde=(TopLevelElement)input.elementAt(i);

      final Vector dep=vde.getDependencies();

      if (dep == null || result.containsAll(dep)) {

        result.addElement(vde);

        input.remove(i);

        changed=true;

      }

 else {

        i++;

      }

    }

    if (!changed) {

      ErrorMsg err=new ErrorMsg(ErrorMsg.CIRCULAR_VARIABLE_ERR,input.toString(),this);

      getParser().reportError(Constants.ERROR,err);

      return (result);

    }

  }

  return result;

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xsl:attribute-set" property.

 * @see <a href="http://www.w3.org/TR/xslt#attribute-sets">attribute-sets in

	 *      XSLT Specification</a>

 * @param attrSet ElemAttributeSet to add to the list of attribute sets

 */

public void setAttributeSet(ElemAttributeSet attrSet){

  if (null == m_attributeSets) {

    m_attributeSets=new Vector();

  }

  m_attributeSets.addElement(attrSet);

}

Location: Stylesheet.java

Content: 

public void setCallsNodeset(boolean flag){

  if (flag)   setMultiDocument(flag);

  _callsNodeset=flag;

}

Location: Stylesheet.java

Content: 

/** 

 * Process the xsl:decimal-format element.

 * @param edf Decimal-format element to push into stack

 */

public void setDecimalFormat(DecimalFormatProperties edf){

  if (null == m_DecimalFormatDeclarations)   m_DecimalFormatDeclarations=new Stack();

  m_DecimalFormatDeclarations.push(edf);

}

Location: Stylesheet.java

Content: 

public void setHasIdCall(boolean flag){

  _hasIdCall=flag;

}

Location: Stylesheet.java

Content: 

/** 

 * Set the base identifier with which this stylesheet is associated.

 * @param baseIdent the base identifier with which this stylesheet isassociated.

 */

public void setHref(String baseIdent){

  m_href=baseIdent;

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "id" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#section-Embedding-Stylesheets">section-Embedding-Stylesheets

	 *      in XSLT Specification</a>

 * @param v Value for the "id" property.

 */

public void setId(String v){

  m_Id=v;

}

Location: Stylesheet.java

Content: 

public void setImportingStylesheet(Stylesheet parent){

  _importedFrom=parent;

  parent.addIncludedStylesheet(this);

}

Location: Stylesheet.java

Content: 

public void setImportPrecedence(final int precedence){

  _importPrecedence=precedence;

  final Enumeration elements=elements();

  while (elements.hasMoreElements()) {

    SyntaxTreeNode child=(SyntaxTreeNode)elements.nextElement();

    if (child instanceof Include) {

      Stylesheet included=((Include)child).getIncludedStylesheet();

      if (included != null && included._includedFrom == this) {

        included.setImportPrecedence(precedence);

      }

    }

  }

  if (_importedFrom != null) {

    if (_importedFrom.getImportPrecedence() < precedence) {

      final Parser parser=getParser();

      final int nextPrecedence=parser.getNextImportPrecedence();

      _importedFrom.setImportPrecedence(nextPrecedence);

    }

  }

 else   if (_includedFrom != null) {

    if (_includedFrom.getImportPrecedence() != precedence)     _includedFrom.setImportPrecedence(precedence);

  }

}

Location: Stylesheet.java

Content: 

/** 

 * Add a stylesheet to the "import" list.

 * @see <a href="http://www.w3.org/TR/xslt#import">import in XSLT

	 *      Specification</a>

 * @param v Stylesheet to add to the import list

 */

public void setImport(StylesheetComposed v){

  if (null == m_imports)   m_imports=new Vector();

  m_imports.addElement(v);

}

Location: Stylesheet.java

Content: 

/** 

 * Add a stylesheet to the "include" list.

 * @see <a href="http://www.w3.org/TR/xslt#include">include in XSLT

	 *      Specification</a>

 * @param v Stylesheet to add to the "include" list

 */

public void setInclude(Stylesheet v){

  if (null == m_includes)   m_includes=new Vector();

  m_includes.addElement(v);

}

Location: Stylesheet.java

Content: 

public void setIncludingStylesheet(Stylesheet parent){

  _includedFrom=parent;

  parent.addIncludedStylesheet(this);

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xsl:key" property.

 * @see <a href="http://www.w3.org/TR/xslt#key">key in XSLT Specification</a>

 * @param v KeyDeclaration element to add to the list of key declarations

 */

public void setKey(KeyDeclaration v){

  if (null == m_keyDeclarations)   m_keyDeclarations=new Vector();

  m_keyDeclarations.addElement(v);

}

Location: Stylesheet.java

Content: 

/** 

 * Set the location information for this element.

 * @param locator SourceLocator object with location information

 */

public void setLocaterInfo(SourceLocator locator){

  if (null != locator) {

    m_publicId=locator.getPublicId();

    m_systemId=locator.getSystemId();

    if (null != m_systemId) {

      try {

        m_href=SystemIDResolver.getAbsoluteURI(m_systemId,null);

      }

 catch (      TransformerException se) {

      }

    }

    super.setLocaterInfo(locator);

  }

}

Location: Stylesheet.java

Content: 

public void setMultiDocument(boolean flag){

  _multiDocument=flag;

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xsl:namespace-alias" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#literal-result-element">literal-result-element

	 *      in XSLT Specification</a>

 * @param na NamespaceAlias elemeent to add to the list

 */

public void setNamespaceAlias(NamespaceAlias na){

  if (m_prefix_aliases == null)   m_prefix_aliases=new Vector();

  m_prefix_aliases.addElement(na);

}

Location: Stylesheet.java

Content: 

/** 

 * Set found a non-xslt element.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#stylesheet-element">stylesheet-element in

	 *      XSLT Specification</a>

 * @param name Qualified name of the element

 * @param obj  The element object

 */

public void setNonXslTopLevel(QName name,Object obj){

  if (null == m_NonXslTopLevel)   m_NonXslTopLevel=new Hashtable();

  m_NonXslTopLevel.put(name,obj);

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xsl:output" property.

 * @see <a href="http://www.w3.org/TR/xslt#output">output in XSLT

	 *      Specification</a>

 * @param v non-null reference to the OutputProperties object to be added to thecollection.

 */

public void setOutput(OutputProperties v){

  if (null == m_output) {

    m_output=new Vector();

  }

  m_output.addElement(v);

}

Location: Stylesheet.java

Content: 

/** 

 * Set an "xsl:param" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @param v A non-null ElemParam reference.

 */

public void setParam(ElemParam v){

  setVariable(v);

}

Location: Stylesheet.java

Content: 

public void setParentStylesheet(Stylesheet parent){

  _parentStylesheet=parent;

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xsl:preserve-space" property.

 * @see <a href="http://www.w3.org/TR/xslt#strip">strip in XSLT

	 *      Specification</a>

 * @param wsi WhiteSpaceInfo element to add to list

 */

public void setPreserveSpaces(WhiteSpaceInfo wsi){

  if (null == m_whitespacePreservingElements) {

    m_whitespacePreservingElements=new Vector();

  }

  m_whitespacePreservingElements.addElement(wsi);

}

Location: Stylesheet.java

Content: 

public void setSimplified(){

  _simplified=true;

}

Location: Stylesheet.java

Content: 

public void setSourceLoader(SourceLoader loader){

  _loader=loader;

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xsl:strip-space" properties.

 * @see <a href="http://www.w3.org/TR/xslt#strip">strip in XSLT

	 *      Specification</a>

 * @param wsi WhiteSpaceInfo element to add to list

 */

public void setStripSpaces(WhiteSpaceInfo wsi){

  if (null == m_whitespaceStrippingElements) {

    m_whitespaceStrippingElements=new Vector();

  }

  m_whitespaceStrippingElements.addElement(wsi);

}

Location: Stylesheet.java

Content: 

/** 

 * Set the parent of the stylesheet. This should be null if this is the root stylesheet.

 * @param v the parent of the stylesheet.

 */

public void setStylesheetParent(Stylesheet v){

  m_stylesheetParent=v;

}

Location: Stylesheet.java

Content: 

/** 

 * Set the root of the stylesheet, where all the tables common to all stylesheets are kept.

 * @param v the root of the stylesheet

 */

public void setStylesheetRoot(StylesheetRoot v){

  m_stylesheetRoot=v;

}

Location: Stylesheet.java

Content: 

public void setTemplateInlining(boolean flag){

  _templateInlining=flag;

}

Location: Stylesheet.java

Content: 

/** 

 * Set an "xsl:template" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#section-Defining-Template-Rules">section-Defining-Template-Rules

	 *      in XSLT Specification</a>

 * @param v ElemTemplate to add to list of templates

 */

public void setTemplate(ElemTemplate v){

  if (null == m_templates)   m_templates=new Vector();

  m_templates.addElement(v);

  v.setStylesheet(this);

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xsl:variable" property.

 * @see <a href=

	 *      "http://www.w3.org/TR/xslt#top-level-variables">top-level-variables in

	 *      XSLT Specification</a>

 * @param v ElemVariable object to add to list of top level variables

 */

public void setVariable(ElemVariable v){

  if (null == m_topLevelVariables)   m_topLevelVariables=new Vector();

  m_topLevelVariables.addElement(v);

}

Location: Stylesheet.java

Content: 

/** 

 * Set the "xmlns:xsl" property.

 * @see <a href="http://www.w3.org/TR/xslt#xslt-namespace">xslt-namespace in

	 *      XSLT Specification</a>

 * @param v The value to be set for the "xmlns:xsl" property.

 */

public void setXmlnsXsl(String v){

  m_XmlnsXsl=v;

}

Location: Stylesheet.java

Content: 

/** 

 * Constructor for a Stylesheet.

 * @param parent The including or importing stylesheet.

 */

public Stylesheet(Stylesheet parent){

  if (null != parent) {

    m_stylesheetParent=parent;

    m_stylesheetRoot=parent.getStylesheetRoot();

  }

}

Location: Stylesheet.java

Content: 

/** 

 * Translate the stylesheet into JVM bytecodes.

 */

public void translate(){

  _className=getXSLTC().getClassName();

  final ClassGenerator classGen=new ClassGenerator(_className,TRANSLET_CLASS,Constants.EMPTYSTRING,ACC_PUBLIC | ACC_SUPER,null,this);

  addDOMField(classGen);

  compileTransform(classGen);

  final Enumeration elements=elements();

  while (elements.hasMoreElements()) {

    Object element=elements.nextElement();

    if (element instanceof Template) {

      final Template template=(Template)element;

      getMode(template.getModeName()).addTemplate(template);

    }

 else     if (element instanceof AttributeSet) {

      ((AttributeSet)element).translate(classGen,null);

    }

 else     if (element instanceof Output) {

      Output output=(Output)element;

      if (output.enabled())       _lastOutputElement=output;

    }

 else {

    }

  }

  checkOutputMethod();

  processModes();

  compileModes(classGen);

  compileStaticInitializer(classGen);

  compileConstructor(classGen,_lastOutputElement);

  if (!getParser().errorsFound()) {

    getXSLTC().dumpClass(classGen.getJavaClass());

  }

}

