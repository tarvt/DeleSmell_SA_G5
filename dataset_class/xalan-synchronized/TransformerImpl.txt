Location: TransformerImpl.java

Content: 

/** 

 * Given an element and mode, find the corresponding template and process the contents.

 * @param xslInstruction The calling element.

 * @param template       The template to use if xsl:for-each, current templatefor apply-imports, or null.

 * @param child          The source context node.

 * @throws TransformerException

 * @return true if applied a template, false if not.

 * @xsl.usage advanced

 */

public boolean applyTemplateToNode(ElemTemplateElement xslInstruction,ElemTemplate template,int child) throws TransformerException {

  DTM dtm=m_xcontext.getDTM(child);

  short nodeType=dtm.getNodeType(child);

  boolean isDefaultTextRule=false;

  boolean isApplyImports=false;

  isApplyImports=((xslInstruction == null) ? false : xslInstruction.getXSLToken() == Constants.ELEMNAME_APPLY_IMPORTS);

  if (null == template || isApplyImports) {

    int maxImportLevel, endImportLevel=0;

    if (isApplyImports) {

      maxImportLevel=template.getStylesheetComposed().getImportCountComposed() - 1;

      endImportLevel=template.getStylesheetComposed().getEndImportCountComposed();

    }

 else {

      maxImportLevel=-1;

    }

    if (isApplyImports && (maxImportLevel == -1)) {

      template=null;

    }

 else {

      XPathContext xctxt=m_xcontext;

      try {

        xctxt.pushNamespaceContext(xslInstruction);

        QName mode=this.getMode();

        if (isApplyImports)         template=m_stylesheetRoot.getTemplateComposed(xctxt,child,mode,maxImportLevel,endImportLevel,m_quietConflictWarnings,dtm);

 else         template=m_stylesheetRoot.getTemplateComposed(xctxt,child,mode,m_quietConflictWarnings,dtm);

      }

  finally {

        xctxt.popNamespaceContext();

      }

    }

    if (null == template) {

switch (nodeType) {

case DTM.DOCUMENT_FRAGMENT_NODE:

case DTM.ELEMENT_NODE:

        template=m_stylesheetRoot.getDefaultRule();

      break;

case DTM.CDATA_SECTION_NODE:

case DTM.TEXT_NODE:

case DTM.ATTRIBUTE_NODE:

    template=m_stylesheetRoot.getDefaultTextRule();

  isDefaultTextRule=true;

break;

case DTM.DOCUMENT_NODE:

template=m_stylesheetRoot.getDefaultRootRule();

break;

default :

return false;

}

}

}

try {

pushElemTemplateElement(template);

m_xcontext.pushCurrentNode(child);

pushPairCurrentMatched(template,child);

if (!isApplyImports) {

DTMIterator cnl=new org.apache.xpath.NodeSetDTM(child,m_xcontext.getDTMManager());

m_xcontext.pushContextNodeList(cnl);

}

if (isDefaultTextRule) {

switch (nodeType) {

case DTM.CDATA_SECTION_NODE:

case DTM.TEXT_NODE:

ClonerToResultTree.cloneToResultTree(child,nodeType,dtm,getResultTreeHandler(),false);

break;

case DTM.ATTRIBUTE_NODE:

dtm.dispatchCharactersEvents(child,getResultTreeHandler(),false);

break;

}

}

 else {

if (m_debug) getTraceManager().fireTraceEvent(template);

m_xcontext.setSAXLocator(template);

m_xcontext.getVarStack().link(template.m_frameSize);

executeChildTemplates(template,true);

if (m_debug) getTraceManager().fireTraceEndEvent(template);

}

}

 catch (org.xml.sax.SAXException se) {

throw new TransformerException(se);

}

 finally {

if (!isDefaultTextRule) m_xcontext.getVarStack().unlink();

m_xcontext.popCurrentNode();

if (!isApplyImports) {

m_xcontext.popContextNodeList();

}

popCurrentMatched();

popElemTemplateElement();

}

return true;

}

Location: TransformerImpl.java

Content: 

/** 

 * Implements JAXP's Transformer.clearParameters() Clear all parameters set with setParameter. Clears the translet's parameter stack.

 */

public void clearParameters(){

  if (_isIdentity && _parameters != null) {

    _parameters.clear();

  }

 else {

    _translet.clearParameters();

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Internal method to create the initial set of properties. There are two layers of properties: the default layer and the base layer. The latter contains properties defined in the stylesheet or by the user using this API.

 */

private Properties createOutputProperties(Properties outputProperties){

  final Properties defaults=new Properties();

  setDefaults(defaults,"xml");

  final Properties base=new Properties(defaults);

  if (outputProperties != null) {

    final Enumeration names=outputProperties.propertyNames();

    while (names.hasMoreElements()) {

      final String name=(String)names.nextElement();

      base.setProperty(name,outputProperties.getProperty(name));

    }

  }

 else {

    base.setProperty(OutputKeys.ENCODING,_translet._encoding);

    if (_translet._method != null)     base.setProperty(OutputKeys.METHOD,_translet._method);

  }

  final String method=base.getProperty(OutputKeys.METHOD);

  if (method != null) {

    if (method.equals("html")) {

      setDefaults(defaults,"html");

    }

 else     if (method.equals("text")) {

      setDefaults(defaults,"text");

    }

  }

  return base;

}

Location: TransformerImpl.java

Content: 

/** 

 * Create a result ContentHandler from a Result object, based on the current OutputProperties.

 * @param outputTarget Where the transform result should go, should not be null.

 * @return A valid ContentHandler that will create the result tree when it isfed SAX events.

 * @throws TransformerException

 */

public SerializationHandler createSerializationHandler(Result outputTarget) throws TransformerException {

  SerializationHandler xoh=createSerializationHandler(outputTarget,getOutputFormat());

  return xoh;

}

Location: TransformerImpl.java

Content: 

/** 

 * Create a ContentHandler from a Result object and an OutputProperties.

 * @param outputTarget Where the transform result should go, should not be null.

 * @param format       The OutputProperties object that will containinstructions on how to serialize the output.

 * @return A valid ContentHandler that will create the result tree when it isfed SAX events.

 * @throws TransformerException

 */

public SerializationHandler createSerializationHandler(Result outputTarget,OutputProperties format) throws TransformerException {

  SerializationHandler xoh;

  org.w3c.dom.Node outputNode=null;

  if (outputTarget instanceof DOMResult) {

    outputNode=((DOMResult)outputTarget).getNode();

    org.w3c.dom.Node nextSibling=((DOMResult)outputTarget).getNextSibling();

    org.w3c.dom.Document doc;

    short type;

    if (null != outputNode) {

      type=outputNode.getNodeType();

      doc=(org.w3c.dom.Node.DOCUMENT_NODE == type) ? (org.w3c.dom.Document)outputNode : outputNode.getOwnerDocument();

    }

 else {

      boolean isSecureProcessing=m_stylesheetRoot.isSecureProcessing();

      doc=org.apache.xml.utils.DOMHelper.createDocument(isSecureProcessing);

      outputNode=doc;

      type=outputNode.getNodeType();

      ((DOMResult)outputTarget).setNode(outputNode);

    }

    DOMBuilder handler=(org.w3c.dom.Node.DOCUMENT_FRAGMENT_NODE == type) ? new DOMBuilder(doc,(org.w3c.dom.DocumentFragment)outputNode) : new DOMBuilder(doc,outputNode);

    if (nextSibling != null)     handler.setNextSibling(nextSibling);

    String encoding=format.getProperty(OutputKeys.ENCODING);

    xoh=new ToXMLSAXHandler(handler,(LexicalHandler)handler,encoding);

  }

 else   if (outputTarget instanceof SAXResult) {

    ContentHandler handler=((SAXResult)outputTarget).getHandler();

    if (null == handler)     throw new IllegalArgumentException("handler can not be null for a SAXResult");

    LexicalHandler lexHandler;

    if (handler instanceof LexicalHandler)     lexHandler=(LexicalHandler)handler;

 else     lexHandler=null;

    String encoding=format.getProperty(OutputKeys.ENCODING);

    String method=format.getProperty(OutputKeys.METHOD);

    ToXMLSAXHandler toXMLSAXHandler=new ToXMLSAXHandler(handler,lexHandler,encoding);

    toXMLSAXHandler.setShouldOutputNSAttr(false);

    xoh=toXMLSAXHandler;

    String publicID=format.getProperty(OutputKeys.DOCTYPE_PUBLIC);

    String systemID=format.getProperty(OutputKeys.DOCTYPE_SYSTEM);

    if (systemID != null)     xoh.setDoctypeSystem(systemID);

    if (publicID != null)     xoh.setDoctypePublic(publicID);

    if (handler instanceof TransformerClient) {

      XalanTransformState state=new XalanTransformState();

      ((TransformerClient)handler).setTransformState(state);

      ((ToSAXHandler)xoh).setTransformState(state);

    }

  }

 else   if (outputTarget instanceof StreamResult) {

    StreamResult sresult=(StreamResult)outputTarget;

    try {

      SerializationHandler serializer=(SerializationHandler)SerializerFactory.getSerializer(format.getProperties());

      if (null != sresult.getWriter())       serializer.setWriter(sresult.getWriter());

 else       if (null != sresult.getOutputStream())       serializer.setOutputStream(sresult.getOutputStream());

 else       if (null != sresult.getSystemId()) {

        String fileURL=sresult.getSystemId();

        if (fileURL.startsWith("file:///")) {

          if (fileURL.substring(8).indexOf(":") > 0)           fileURL=fileURL.substring(8);

 else           fileURL=fileURL.substring(7);

        }

 else         if (fileURL.startsWith("file:/")) {

          if (fileURL.substring(6).indexOf(":") > 0)           fileURL=fileURL.substring(6);

 else           fileURL=fileURL.substring(5);

        }

        m_outputStream=new java.io.FileOutputStream(fileURL);

        serializer.setOutputStream(m_outputStream);

        xoh=serializer;

      }

 else       throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED,null));

      xoh=serializer;

    }

 catch (    IOException ioe) {

      throw new TransformerException(ioe);

    }

  }

 else {

    throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,new Object[]{outputTarget.getClass().getName()}));

  }

  xoh.setTransformer(this);

  SourceLocator srcLocator=getStylesheet();

  xoh.setSourceLocator(srcLocator);

  return xoh;

}

Location: TransformerImpl.java

Content: 

/** 

 * Determines whether an EXSLT <code>func:result</code> instruction has been executed for the currently active EXSLT <code>func:function</code>.

 * @return <code>true</code> if and only if a <code>func:result</code>instruction has been executed

 */

public boolean currentFuncResultSeen(){

  return !m_currentFuncResult.empty() && m_currentFuncResult.peek() != null;

}

Location: TransformerImpl.java

Content: 

/** 

 * Tell if the current template rule is null, i.e. if we are directly within an apply-templates. Used for xsl:apply-imports.

 * @return True if the current template rule is null.

 */

public boolean currentTemplateRuleIsNull(){

  return ((!m_currentTemplateRuleIsNull.isEmpty()) && (m_currentTemplateRuleIsNull.peek() == true));

}

Location: TransformerImpl.java

Content: 

/** 

 * Execute each of the children of a template element.

 * @param elem           The ElemTemplateElement that contains the children thatshould execute.

 * @param shouldAddAttrs true if xsl:attributes should be executed.

 * @throws TransformerException

 * @xsl.usage advanced

 */

public void executeChildTemplates(ElemTemplateElement elem,boolean shouldAddAttrs) throws TransformerException {

  ElemTemplateElement t=elem.getFirstChildElem();

  if (null == t)   return;

  if (elem.hasTextLitOnly() && m_optimizer) {

    char[] chars=((ElemTextLiteral)t).getChars();

    try {

      this.pushElemTemplateElement(t);

      m_serializationHandler.characters(chars,0,chars.length);

    }

 catch (    SAXException se) {

      throw new TransformerException(se);

    }

 finally {

      this.popElemTemplateElement();

    }

    return;

  }

  XPathContext xctxt=m_xcontext;

  xctxt.pushSAXLocatorNull();

  int currentTemplateElementsTop=m_currentTemplateElements.size();

  m_currentTemplateElements.push(null);

  try {

    for (; t != null; t=t.getNextSiblingElem()) {

      if (!shouldAddAttrs && t.getXSLToken() == Constants.ELEMNAME_ATTRIBUTE)       continue;

      xctxt.setSAXLocator(t);

      m_currentTemplateElements.setElementAt(t,currentTemplateElementsTop);

      t.execute(this);

    }

  }

 catch (  RuntimeException re) {

    TransformerException te=new TransformerException(re);

    te.setLocator(t);

    throw te;

  }

 finally {

    m_currentTemplateElements.pop();

    xctxt.popSAXLocator();

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Execute each of the children of a template element.

 * @param elem    The ElemTemplateElement that contains the children that shouldexecute.

 * @param handler The ContentHandler to where the result events should be fed.

 * @throws TransformerException

 * @xsl.usage advanced

 */

public void executeChildTemplates(ElemTemplateElement elem,ContentHandler handler) throws TransformerException {

  SerializationHandler xoh=this.getSerializationHandler();

  SerializationHandler savedHandler=xoh;

  try {

    xoh.flushPending();

    LexicalHandler lex=null;

    if (handler instanceof LexicalHandler) {

      lex=(LexicalHandler)handler;

    }

    m_serializationHandler=new ToXMLSAXHandler(handler,lex,savedHandler.getEncoding());

    m_serializationHandler.setTransformer(this);

    executeChildTemplates(elem,true);

  }

 catch (  TransformerException e) {

    throw e;

  }

catch (  SAXException se) {

    throw new TransformerException(se);

  }

 finally {

    m_serializationHandler=savedHandler;

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Execute each of the children of a template element. This method is only for extension use.

 * @param elem    The ElemTemplateElement that contains the children that shouldexecute. NEEDSDOC @param context

 * @param mode    The current mode.

 * @param handler The ContentHandler to where the result events should be fed.

 * @throws TransformerException

 * @xsl.usage advanced

 */

public void executeChildTemplates(ElemTemplateElement elem,org.w3c.dom.Node context,QName mode,ContentHandler handler) throws TransformerException {

  XPathContext xctxt=m_xcontext;

  try {

    if (null != mode)     pushMode(mode);

    xctxt.pushCurrentNode(xctxt.getDTMHandleFromNode(context));

    executeChildTemplates(elem,handler);

  }

  finally {

    xctxt.popCurrentNode();

    if (null != mode)     popMode();

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * This will execute the following XSLT instructions from the snapshot point, after the stylesheet execution context has been reset from the snapshot point.

 * @param ts The snapshot of where to start execution

 * @throws TransformerException

 * @deprecated This is an internal tooling API that nobody seems to be using

 */

public void executeFromSnapshot(TransformSnapshot ts) throws TransformerException {

  ElemTemplateElement template=getMatchedTemplate();

  int child=getMatchedNode();

  pushElemTemplateElement(template);

  m_xcontext.pushCurrentNode(child);

  this.executeChildTemplates(template,true);

}

Location: TransformerImpl.java

Content: 

private void fatalError(Throwable throwable) throws TransformerException {

  if (throwable instanceof org.xml.sax.SAXParseException)   m_errorHandler.fatalError(new TransformerException(throwable.getMessage(),new SAXSourceLocator((org.xml.sax.SAXParseException)throwable)));

 else   m_errorHandler.fatalError(new TransformerException(throwable));

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the base URL of the source.

 * @return The base URL of the source tree, or null.

 */

public String getBaseURLOfSource(){

  return m_urlOfSource;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the table of counters, for optimized xsl:number support.

 * @return The CountersTable, never null.

 */

public CountersTable getCountersTable(){

  if (null == m_countersTable)   m_countersTable=new CountersTable();

  return m_countersTable;

}

Location: TransformerImpl.java

Content: 

/** 

 * Retrieves the current ElemTemplateElement that is being executed.

 * @return The current ElemTemplateElement that is executing, should notnormally be null.

 */

public ElemTemplateElement getCurrentElement(){

  return (m_currentTemplateElements.size() > 0) ? (ElemTemplateElement)m_currentTemplateElements.peek() : null;

}

Location: TransformerImpl.java

Content: 

/** 

 * This method retrieves the xsl:template that is in effect, which may be a matched template or a named template. <p> Please note that the ElemTemplate returned may be a default template, and thus may not have a template defined in the stylesheet. </p>

 * @return The current xsl:template, should not be null.

 */

public ElemTemplate getCurrentTemplate(){

  ElemTemplateElement elem=getCurrentElement();

  while ((null != elem) && (elem.getXSLToken() != Constants.ELEMNAME_TEMPLATE)) {

    elem=elem.getParentElem();

  }

  return (ElemTemplate)elem;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the count of how many elements are active.

 * @return The number of active elements on the currentTemplateElements stack.

 */

public ObjectStack getCurrentTemplateElements(){

  return m_currentTemplateElements;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the count of how many elements are active.

 * @return The number of active elements on the currentTemplateElements stack.

 */

public int getCurrentTemplateElementsCount(){

  return m_currentTemplateElements.size();

}

Location: TransformerImpl.java

Content: 

public boolean getDebug(){

  return m_debug;

}

Location: TransformerImpl.java

Content: 

/** 

 * Builds an internal DOM from a TrAX Source object

 */

private DOM getDOM(Source source) throws TransformerException {

  try {

    DOM dom=null;

    if (source != null) {

      DTMWSFilter wsfilter;

      if (_translet != null && _translet instanceof StripFilter) {

        wsfilter=new DOMWSFilter(_translet);

      }

 else {

        wsfilter=null;

      }

      boolean hasIdCall=(_translet != null) ? _translet.hasIdCall() : false;

      if (_dtmManager == null) {

        _dtmManager=(XSLTCDTMManager)_tfactory.getDTMManagerClass().newInstance();

      }

      dom=(DOM)_dtmManager.getDTM(source,false,wsfilter,true,false,false,0,hasIdCall);

    }

 else     if (_dom != null) {

      dom=_dom;

      _dom=null;

    }

 else {

      return null;

    }

    if (!_isIdentity) {

      _translet.prepassDocument(dom);

    }

    return dom;

  }

 catch (  Exception e) {

    if (_errorListener != null) {

      postErrorToListener(e.getMessage());

    }

    throw new TransformerException(e);

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the stack of ElemTemplateElements.

 * @return A copy of stack that contains the xsl element instructions, theearliest called in index zero, and the latest called in index size()-1.

 */

public Vector getElementCallstack(){

  Vector elems=new Vector();

  int nStackSize=m_currentTemplateElements.size();

  for (int i=0; i < nStackSize; i++) {

    ElemTemplateElement elem=(ElemTemplateElement)m_currentTemplateElements.elementAt(i);

    if (null != elem) {

      elems.addElement(elem);

    }

  }

  return elems;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the exception thrown by the secondary thread (normally the transform thread).

 * @return The thrown exception, or null if no exception was thrown.

 */

public Exception getExceptionThrown(){

  return m_exceptionThrown;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the extensions table object.

 * @return The extensions table.

 */

public ExtensionsTable getExtensionsTable(){

  return m_extensionsTable;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get a SAX2 ContentHandler for the input.

 * @return A valid ContentHandler, which should never be null, as long asgetFeature("http://xml.org/trax/features/sax/input") returns true.

 */

public ContentHandler getInputContentHandler(){

  return getInputContentHandler(false);

}

Location: TransformerImpl.java

Content: 

/** 

 * Get a SAX2 ContentHandler for the input.

 * @param doDocFrag true if a DocumentFragment should be created as the root,rather than a Document.

 * @return A valid ContentHandler, which should never be null, as long asgetFeature("http://xml.org/trax/features/sax/input") returns true.

 */

public ContentHandler getInputContentHandler(boolean doDocFrag){

  if (null == m_inputContentHandler) {

    m_inputContentHandler=new TransformerHandlerImpl(this,doDocFrag,m_urlOfSource);

  }

  return m_inputContentHandler;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get a SAX2 DeclHandler for the input.

 * @return A valid DeclHandler, which should never be null, as long asgetFeature("http://xml.org/trax/features/sax/input") returns true.

 */

public DeclHandler getInputDeclHandler(){

  if (m_inputContentHandler instanceof DeclHandler)   return (DeclHandler)m_inputContentHandler;

 else   return null;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get a SAX2 LexicalHandler for the input.

 * @return A valid LexicalHandler, which should never be null, as long asgetFeature("http://xml.org/trax/features/sax/input") returns true.

 */

public LexicalHandler getInputLexicalHandler(){

  if (m_inputContentHandler instanceof LexicalHandler)   return (LexicalHandler)m_inputContentHandler;

 else   return null;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the KeyManager object.

 * @return A reference to the KeyManager object, which should never be null.

 */

public KeyManager getKeyManager(){

  return m_keyManager;

}

Location: TransformerImpl.java

Content: 

/** 

 * Retrieves the node in the source tree that matched the template obtained via getMatchedTemplate().

 * @return The matched node that corresponds to the match attribute of thecurrent xsl:template.

 */

public int getMatchedNode(){

  return m_currentMatchedNodes.peepTail();

}

Location: TransformerImpl.java

Content: 

/** 

 * This method retrieves the xsl:template that was matched. Note that this may not be the same thing as the current template (which may be from getCurrentElement()), since a named template may be in effect.

 * @return The pushed template that was pushed via pushPairCurrentMatched.

 */

public ElemTemplate getMatchedTemplate(){

  return (ElemTemplate)m_currentMatchTemplates.peek();

}

Location: TransformerImpl.java

Content: 

/** 

 * NEEDSDOC Method getMode NEEDSDOC (getMode) @return

 */

public QName getMode(){

  return m_modes.isEmpty() ? null : (QName)m_modes.peek();

}

Location: TransformerImpl.java

Content: 

/** 

 * Return the message manager.

 * @return The message manager, never null.

 */

public MsgMgr getMsgMgr(){

  if (null == m_msgMgr)   m_msgMgr=new MsgMgr(this);

  return m_msgMgr;

}

Location: TransformerImpl.java

Content: 

/** 

 * @return Optimization flag

 */

public boolean getOptimize(){

  return m_optimizer;

}

Location: TransformerImpl.java

Content: 

/** 

 * Create an output handler for the transformation output based on the type and contents of the TrAX Result object passed to the transform() method.

 */

public SerializationHandler getOutputHandler(Result result) throws TransformerException {

  _method=(String)_properties.get(OutputKeys.METHOD);

  _encoding=(String)_properties.getProperty(OutputKeys.ENCODING);

  _tohFactory=TransletOutputHandlerFactory.newInstance();

  _tohFactory.setEncoding(_encoding);

  if (_method != null) {

    _tohFactory.setOutputMethod(_method);

  }

  if (_indentNumber >= 0) {

    _tohFactory.setIndentNumber(_indentNumber);

  }

  try {

    if (result instanceof SAXResult) {

      final SAXResult target=(SAXResult)result;

      final ContentHandler handler=target.getHandler();

      _tohFactory.setHandler(handler);

      LexicalHandler lexicalHandler=target.getLexicalHandler();

      if (lexicalHandler != null) {

        _tohFactory.setLexicalHandler(lexicalHandler);

      }

      _tohFactory.setOutputType(TransletOutputHandlerFactory.SAX);

      return _tohFactory.getSerializationHandler();

    }

 else     if (result instanceof DOMResult) {

      _tohFactory.setNode(((DOMResult)result).getNode());

      _tohFactory.setNextSibling(((DOMResult)result).getNextSibling());

      _tohFactory.setOutputType(TransletOutputHandlerFactory.DOM);

      return _tohFactory.getSerializationHandler();

    }

 else     if (result instanceof StreamResult) {

      final StreamResult target=(StreamResult)result;

      _tohFactory.setOutputType(TransletOutputHandlerFactory.STREAM);

      final Writer writer=target.getWriter();

      if (writer != null) {

        _tohFactory.setWriter(writer);

        return _tohFactory.getSerializationHandler();

      }

      final OutputStream ostream=target.getOutputStream();

      if (ostream != null) {

        _tohFactory.setOutputStream(ostream);

        return _tohFactory.getSerializationHandler();

      }

      String systemId=result.getSystemId();

      if (systemId == null) {

        ErrorMsg err=new ErrorMsg(ErrorMsg.JAXP_NO_RESULT_ERR);

        throw new TransformerException(err.toString());

      }

      URL url=null;

      if (systemId.startsWith("file:")) {

        url=new URL(systemId);

        _tohFactory.setOutputStream(_ostream=new FileOutputStream(url.getFile()));

        return _tohFactory.getSerializationHandler();

      }

 else       if (systemId.startsWith("http:")) {

        url=new URL(systemId);

        final URLConnection connection=url.openConnection();

        _tohFactory.setOutputStream(_ostream=connection.getOutputStream());

        return _tohFactory.getSerializationHandler();

      }

 else {

        url=new File(systemId).toURL();

        _tohFactory.setOutputStream(_ostream=new FileOutputStream(url.getFile()));

        return _tohFactory.getSerializationHandler();

      }

    }

  }

 catch (  UnknownServiceException e) {

    throw new TransformerException(e);

  }

catch (  ParserConfigurationException e) {

    throw new TransformerException(e);

  }

catch (  IOException e) {

    throw new TransformerException(e);

  }

  return null;

}

Location: TransformerImpl.java

Content: 

/** 

 * Implements JAXP's Transformer.getOutputProperties(). Returns a copy of the output properties for the transformation. This is a set of layered properties. The first layer contains properties set by calls to setOutputProperty() and setOutputProperties() on this class, and the output settings defined in the stylesheet's <xsl:output> element makes up the second level, while the default XSLT output settings are returned on the third level.

 * @return Properties in effect for this Transformer

 */

public Properties getOutputProperties(){

  return (Properties)_properties.clone();

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the value of a property, without using the default properties. This can be used to test if a property has been explicitly set by the stylesheet or user. NEEDSDOC @param qnameString

 * @return The value of the property, or null if not found.

 * @throws IllegalArgumentException If the property is not supported, and is notnamespaced.

 */

public String getOutputPropertyNoDefault(String qnameString) throws IllegalArgumentException {

  String value=null;

  OutputProperties props=getOutputFormat();

  value=(String)props.getProperties().get(qnameString);

  if (null == value) {

    if (!OutputProperties.isLegalPropertyKey(qnameString))     throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,new Object[]{qnameString}));

  }

  return value;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the original output target.

 * @return The Result object used to kick of the transform or null.

 */

public Result getOutputTarget(){

  return m_outputTarget;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get quietConflictWarnings property. If the quietConflictWarnings property is set to true, warnings about pattern conflicts won't be printed to the diagnostics stream.

 * @return True if this transformer should not report template match conflicts.

 */

public boolean getQuietConflictWarnings(){

  return m_quietConflictWarnings;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the SerializationHandler object.

 * @return The current SerializationHandler, which may not be the main resulttree manager.

 */

public SerializationHandler getResultTreeHandler(){

  return m_serializationHandler;

}

Location: TransformerImpl.java

Content: 

/** 

 * This will get a snapshot of the current executing context

 * @return TransformSnapshot object, snapshot of executing context

 * @deprecated This is an internal tooling API that nobody seems to be using

 */

public TransformSnapshot getSnapshot(){

  return new TransformSnapshotImpl(this);

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the object used to guard the stack from recursion.

 * @return The StackGuard object, which should never be null.

 * @xsl.usage internal

 */

public StackGuard getStackGuard(){

  return m_stackGuard;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the StringWriter pool, so that StringWriter objects may be reused.

 * @return The string writer pool, not null.

 * @xsl.usage internal

 */

public ObjectPool getStringWriterPool(){

  return m_stringWriterObjectPool;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the call stack of xsl:template elements.

 * @return A copy of stack that contains the xsl:template (ElemTemplate)instructions, the earliest called in index zero, and the latest called in index size()-1.

 */

public Vector getTemplateCallstack(){

  Vector elems=new Vector();

  int nStackSize=m_currentTemplateElements.size();

  for (int i=0; i < nStackSize; i++) {

    ElemTemplateElement elem=(ElemTemplateElement)m_currentTemplateElements.elementAt(i);

    if (null != elem && (elem.getXSLToken() != Constants.ELEMNAME_TEMPLATE)) {

      elems.addElement(elem);

    }

  }

  return elems;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get an instance of the trace manager for this transformation. This object can be used to set trace listeners on various events during the transformation.

 * @return A reference to the TraceManager, never null.

 */

public TraceManager getTraceManager(){

  return m_traceManager;

}

Location: TransformerImpl.java

Content: 

/** 

 * Returns the  {@link org.apache.xalan.xsltc.trax.TransformerFactoryImpl} objectthat create this <code>Transformer</code>.

 */

protected TransformerFactoryImpl getTransformerFactory(){

  return _tfactory;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the thread that the transform process is on.

 * @return The thread that the transform process is on, or null.

 * @xsl.usage internal

 */

public Thread getTransformThread(){

  return m_transformThread;

}

Location: TransformerImpl.java

Content: 

/** 

 * Returns the translet wrapped inside this Transformer or null if this is the identity transform.

 */

protected AbstractTranslet getTranslet(){

  return _translet;

}

Location: TransformerImpl.java

Content: 

/** 

 * Returns the {@link org.apache.xalan.xsltc.runtime.output.TransletOutputHandlerFactory}object that create the <code>TransletOutputHandler</code>.

 */

protected TransletOutputHandlerFactory getTransletOutputHandlerFactory(){

  return _tohFactory;

}

Location: TransformerImpl.java

Content: 

/** 

 * Return true if the transform was initiated from the transform method, otherwise it was probably done from a pure parse events. NEEDSDOC ($objectName$) @return

 */

public boolean hasTransformThreadErrorCatcher(){

  return m_hasTransformThreadErrorCatcher;

}

Location: TransformerImpl.java

Content: 

/** 

 * Initializer method.

 * @param transformer non-null transformer instance

 * @param realHandler Content Handler instance

 */

public void init(ToXMLSAXHandler h,Transformer transformer,ContentHandler realHandler){

  h.setTransformer(transformer);

  h.setContentHandler(realHandler);

}

Location: TransformerImpl.java

Content: 

/** 

 * Checks if a given output property is default (2nd layer only)

 */

private boolean isDefaultProperty(String name,Properties properties){

  return (properties.get(name) == null);

}

Location: TransformerImpl.java

Content: 

public boolean isIdentity(){

  return _isIdentity;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get true if the parser events should be on the main thread, false if not. Experimental. Can not be set right now.

 * @return true if the parser events should be on the main thread, false if not.

 * @xsl.usage experimental

 */

public boolean isParserEventsOnMain(){

  return m_parserEventsOnMain;

}

Location: TransformerImpl.java

Content: 

/** 

 * Check to see if this is a recursive attribute definition.

 * @param attrSet A non-null ElemAttributeSet reference.

 * @return true if the attribute set is recursive.

 */

public boolean isRecursiveAttrSet(ElemAttributeSet attrSet){

  if (null == m_attrSetStack) {

    m_attrSetStack=new Stack();

  }

  if (!m_attrSetStack.empty()) {

    int loc=m_attrSetStack.search(attrSet);

    if (loc > -1) {

      return true;

    }

  }

  return false;

}

Location: TransformerImpl.java

Content: 

/** 

 * Tell if the transform method is completed.

 * @return True if transformNode has completed, or an exception was thrown.

 */

public boolean isTransformDone(){

synchronized (this) {

    return m_isTransformDone;

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * The translet stores all CDATA sections set in the <xsl:output> element in a Hashtable. This method will re-construct the whitespace separated list of elements given in the <xsl:output> element.

 */

private String makeCDATAString(Hashtable cdata){

  if (cdata == null)   return null;

  StringBuffer result=new StringBuffer();

  Enumeration elements=cdata.keys();

  if (elements.hasMoreElements()) {

    result.append((String)elements.nextElement());

    while (elements.hasMoreElements()) {

      String element=(String)elements.nextElement();

      result.append(' ');

      result.append(element);

    }

  }

  return (result.toString());

}

Location: TransformerImpl.java

Content: 

/** 

 * Pops the result of the currently active EXSLT <code>func:function</code>.

 * @return the value of the <code>func:function</code>

 */

public Object popCurrentFuncResult(){

  return m_currentFuncResult.pop();

}

Location: TransformerImpl.java

Content: 

/** 

 * Pop the elements that were pushed via pushPairCurrentMatched.

 */

public void popCurrentMatched(){

  m_currentMatchTemplates.pop();

  m_currentMatchedNodes.pop();

}

Location: TransformerImpl.java

Content: 

/** 

 * Push true if the current template rule is null, false otherwise.

 */

public void popCurrentTemplateRuleIsNull(){

  m_currentTemplateRuleIsNull.pop();

}

Location: TransformerImpl.java

Content: 

/** 

 * Pop the current executing attribute set.

 */

public void popElemAttributeSet(){

  m_attrSetStack.pop();

}

Location: TransformerImpl.java

Content: 

/** 

 * Pop the current template element.

 */

public void popElemTemplateElement(){

  m_currentTemplateElements.pop();

}

Location: TransformerImpl.java

Content: 

/** 

 * NEEDSDOC Method popMode

 */

public void popMode(){

  m_modes.pop();

}

Location: TransformerImpl.java

Content: 

/** 

 * Inform TrAX error listener of an error

 */

private void postErrorToListener(String message){

  try {

    _errorListener.error(new TransformerException(message));

  }

 catch (  TransformerException e) {

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * From a secondary thread, post the exception, so that it can be picked up from the main thread.

 * @param e The exception that was thrown.

 */

void postExceptionFromThread(Exception e){

  m_isTransformDone=true;

  m_exceptionThrown=e;

  ;

synchronized (this) {

    notifyAll();

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Inform TrAX error listener of a warning

 */

private void postWarningToListener(String message){

  try {

    _errorListener.warning(new TransformerException(message));

  }

 catch (  TransformerException e) {

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the keys for the xsl:sort elements. Note: Should this go into ElemForEach?

 * @param foreach           Valid ElemForEach element, not null.

 * @param sourceNodeContext The current node context in the source tree, neededto evaluate the Attribute Value Templates.

 * @return A Vector of NodeSortKeys, or null.

 * @throws TransformerException

 * @xsl.usage advanced

 */

public Vector processSortKeys(ElemForEach foreach,int sourceNodeContext) throws TransformerException {

  Vector keys=null;

  XPathContext xctxt=m_xcontext;

  int nElems=foreach.getSortElemCount();

  if (nElems > 0)   keys=new Vector();

  for (int i=0; i < nElems; i++) {

    ElemSort sort=foreach.getSortElem(i);

    if (m_debug)     getTraceManager().fireTraceEvent(sort);

    String langString=(null != sort.getLang()) ? sort.getLang().evaluate(xctxt,sourceNodeContext,foreach) : null;

    String dataTypeString=sort.getDataType().evaluate(xctxt,sourceNodeContext,foreach);

    if (dataTypeString.indexOf(":") >= 0)     System.out.println("TODO: Need to write the hooks for QNAME sort data type");

 else     if (!(dataTypeString.equalsIgnoreCase(Constants.ATTRVAL_DATATYPE_TEXT)) && !(dataTypeString.equalsIgnoreCase(Constants.ATTRVAL_DATATYPE_NUMBER)))     foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,new Object[]{Constants.ATTRNAME_DATATYPE,dataTypeString});

    boolean treatAsNumbers=((null != dataTypeString) && dataTypeString.equals(Constants.ATTRVAL_DATATYPE_NUMBER)) ? true : false;

    String orderString=sort.getOrder().evaluate(xctxt,sourceNodeContext,foreach);

    if (!(orderString.equalsIgnoreCase(Constants.ATTRVAL_ORDER_ASCENDING)) && !(orderString.equalsIgnoreCase(Constants.ATTRVAL_ORDER_DESCENDING)))     foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,new Object[]{Constants.ATTRNAME_ORDER,orderString});

    boolean descending=((null != orderString) && orderString.equals(Constants.ATTRVAL_ORDER_DESCENDING)) ? true : false;

    AVT caseOrder=sort.getCaseOrder();

    boolean caseOrderUpper;

    if (null != caseOrder) {

      String caseOrderString=caseOrder.evaluate(xctxt,sourceNodeContext,foreach);

      if (!(caseOrderString.equalsIgnoreCase(Constants.ATTRVAL_CASEORDER_UPPER)) && !(caseOrderString.equalsIgnoreCase(Constants.ATTRVAL_CASEORDER_LOWER)))       foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,new Object[]{Constants.ATTRNAME_CASEORDER,caseOrderString});

      caseOrderUpper=((null != caseOrderString) && caseOrderString.equals(Constants.ATTRVAL_CASEORDER_UPPER)) ? true : false;

    }

 else {

      caseOrderUpper=false;

    }

    keys.addElement(new NodeSortKey(this,sort.getSelect(),treatAsNumbers,descending,langString,caseOrderUpper,foreach));

    if (m_debug)     getTraceManager().fireTraceEndEvent(sort);

  }

  return keys;

}

Location: TransformerImpl.java

Content: 

/** 

 * Push a funcion result for the currently active EXSLT <code>func:function</code>.

 * @param val the result of executing an EXSLT <code>func:result</code>instruction for the current <code>func:function</code>.

 */

public void pushCurrentFuncResult(Object val){

  m_currentFuncResult.push(val);

}

Location: TransformerImpl.java

Content: 

/** 

 * Push true if the current template rule is null, false otherwise.

 * @param b True if the we are executing an xsl:for-each (orxsl:call-template?).

 */

public void pushCurrentTemplateRuleIsNull(boolean b){

  m_currentTemplateRuleIsNull.push(b);

}

Location: TransformerImpl.java

Content: 

/** 

 * Push an executing attribute set, so we can check for recursive attribute definitions.

 * @param attrSet A non-null ElemAttributeSet reference.

 */

public void pushElemAttributeSet(ElemAttributeSet attrSet){

  m_attrSetStack.push(attrSet);

}

Location: TransformerImpl.java

Content: 

/** 

 * Push the current template element.

 * @param elem The current ElemTemplateElement (may be null, and then set viasetCurrentElement).

 */

public void pushElemTemplateElement(ElemTemplateElement elem){

  m_currentTemplateElements.push(elem);

}

Location: TransformerImpl.java

Content: 

/** 

 * Internal -- push the global variables from the Stylesheet onto the context's runtime variable stack. <p> If we encounter a variable that is already defined in the variable stack, we ignore it. This is because the second variable definition will be at a lower import precedence. Presumably, global"variables at the same import precedence with the same name will have been caught during the recompose process. <p> However, if we encounter a parameter that is already defined in the variable stack, we need to see if this is a parameter whose value was supplied by a setParameter call. If so, we need to "receive" the one already in the stack, ignoring this one. If it is just an earlier xsl:param or xsl:variable definition, we ignore it using the same reasoning as explained above for the variable.

 * @param contextNode The root of the source tree, can't be null.

 * @throws TransformerException

 */

protected void pushGlobalVars(int contextNode) throws TransformerException {

  XPathContext xctxt=m_xcontext;

  VariableStack vs=xctxt.getVarStack();

  StylesheetRoot sr=getStylesheet();

  Vector vars=sr.getVariablesAndParamsComposed();

  int i=vars.size();

  vs.link(i);

  while (--i >= 0) {

    ElemVariable v=(ElemVariable)vars.elementAt(i);

    XObject xobj=new XUnresolvedVariable(v,contextNode,this,vs.getStackFrame(),0,true);

    if (null == vs.elementAt(i))     vs.setGlobalVariable(i,xobj);

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * NEEDSDOC Method pushMode NEEDSDOC @param mode

 */

public void pushMode(QName mode){

  m_modes.push(mode);

}

Location: TransformerImpl.java

Content: 

/** 

 * Push both the current xsl:template or xsl:for-each onto the stack, along with the child node that was matched. (Note: should this only be used for xsl:templates?? -sb)

 * @param template xsl:template or xsl:for-each.

 * @param child    The child that was matched.

 */

public void pushPairCurrentMatched(ElemTemplateElement template,int child){

  m_currentMatchTemplates.push(template);

  m_currentMatchedNodes.push(child);

}

Location: TransformerImpl.java

Content: 

/** 

 * NEEDSDOC Method replaceOrPushUserParam NEEDSDOC @param qname NEEDSDOC @param xval

 */

private void replaceOrPushUserParam(QName qname,XObject xval){

  int n=m_userParams.size();

  for (int i=n - 1; i >= 0; i--) {

    Arg arg=(Arg)m_userParams.elementAt(i);

    if (arg.getQName().equals(qname)) {

      m_userParams.setElementAt(new Arg(qname,xval,true),i);

      return;

    }

  }

  m_userParams.addElement(new Arg(qname,xval,true));

}

Location: TransformerImpl.java

Content: 

/** 

 * This will reset the stylesheet execution context from the snapshot point.

 * @param ts The snapshot of where to start execution

 * @deprecated This is an internal tooling API that nobody seems to be using

 */

public void resetToStylesheet(TransformSnapshot ts){

  ((TransformSnapshotImpl)ts).apply(this);

}

Location: TransformerImpl.java

Content: 

/** 

 * Reset parameters that the user specified for the transformation. Called during transformer.reset() after we have cleared the variable stack. We need to make sure that user params are reset so that the transformer object can be reused.

 */

private void resetUserParameters(){

  try {

    if (null == m_userParams)     return;

    int n=m_userParams.size();

    for (int i=n - 1; i >= 0; i--) {

      Arg arg=(Arg)m_userParams.elementAt(i);

      QName name=arg.getQName();

      String s1=name.getNamespace();

      String s2=name.getLocalPart();

      setParameter(s2,s1,arg.getVal().object());

    }

  }

 catch (  java.util.NoSuchElementException nsee) {

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * This class should only be used as a DOMCache for the translet if the URIResolver has been set. The method implements XSLTC's DOMCache interface, which is used to plug in an external document loader into a translet. This method acts as an adapter between TrAX's URIResolver interface and XSLTC's DOMCache interface. This approach is simple, but removes the possibility of using external document caches with XSLTC.

 * @param baseURI  The base URI used by the document call.

 * @param href     The href argument passed to the document function.

 * @param translet A reference to the translet requesting the document

 */

public DOM retrieveDocument(String baseURI,String href,Translet translet){

  try {

    if (href.length() == 0) {

      href=baseURI;

    }

    Source resolvedSource=_uriResolver.resolve(href,baseURI);

    if (resolvedSource == null) {

      StreamSource streamSource=new StreamSource(SystemIDResolver.getAbsoluteURI(href,baseURI));

      return getDOM(streamSource);

    }

    return getDOM(resolvedSource);

  }

 catch (  TransformerException e) {

    if (_errorListener != null)     postErrorToListener("File not found: " + e.getMessage());

    return (null);

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Called by this.transform() if isParserEventsOnMain()==false. Similar with runTransformThread(), but no priority is set and setTransformThread is not set.

 */

public void runTransformThread(){

  ThreadControllerWrapper.runThread(this,-1);

}

Location: TransformerImpl.java

Content: 

/** 

 * Called by SourceTreeHandler to start the transformation in a separate thread NEEDSDOC @param priority

 */

public void runTransformThread(int priority){

  Thread t=ThreadControllerWrapper.runThread(this,priority);

  this.setTransformThread(t);

}

Location: TransformerImpl.java

Content: 

/** 

 * Called by CoRoutineSAXParser. Launches the CoroutineSAXParser in a thread, and prepares it to invoke the parser from that thread upon request.

 */

public static void runTransformThread(Runnable runnable){

  ThreadControllerWrapper.runThread(runnable,-1);

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the base URL of the source. NEEDSDOC @param base

 * @return The base URL of the source tree, or null.

 */

public void setBaseURLOfSource(String base){

  m_urlOfSource=base;

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the top of the current template elements stack.

 * @param e The current ElemTemplateElement about to be executed.

 */

public void setCurrentElement(ElemTemplateElement e){

  m_currentTemplateElements.setTop(e);

}

Location: TransformerImpl.java

Content: 

/** 

 * Internal method to get the default properties from the serializer factory and set them on the property object.

 * @param props  a java.util.Property object on which the properties are set.

 * @param method The output method type, one of "xml", "text", "html" ...

 */

private void setDefaults(Properties props,String method){

  final Properties method_props=OutputPropertiesFactory.getDefaultMethodProperties(method);

{

    final Enumeration names=method_props.propertyNames();

    while (names.hasMoreElements()) {

      final String name=(String)names.nextElement();

      props.setProperty(name,method_props.getProperty(name));

    }

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the internal DOM that will be used for the next transformation

 */

protected void setDOM(DOM dom){

  _dom=dom;

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the exception thrown by the secondary thread (normally the transform thread).

 * @param e The thrown exception, or null if no exception was thrown.

 */

public void setExceptionThrown(Exception e){

  m_exceptionThrown=e;

}

Location: TransformerImpl.java

Content: 

/** 

 * If the stylesheet contains extensions, set the extensions table object.

 * @param sroot The stylesheet.

 * @throws javax.xml.transform.TransformerException

 */

void setExtensionsTable(StylesheetRoot sroot) throws javax.xml.transform.TransformerException {

  try {

    if (sroot.getExtensions() != null)     if (!sroot.isSecureProcessing())     m_extensionsTable=new ExtensionsTable(sroot);

  }

 catch (  javax.xml.transform.TransformerException te) {

    te.printStackTrace();

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Set if the transform method is completed.

 * @param done True if transformNode has completed, or an exception was thrown.

 */

public void setIsTransformDone(boolean done){

synchronized (this) {

    m_isTransformDone=done;

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the output properties for the transformation. These properties will override properties set in the templates with xsl:output.

 * @param oformat A valid OutputProperties object (which will not be mutated),or null.

 */

public void setOutputFormat(OutputProperties oformat){

  m_outputFormat=oformat;

}

Location: TransformerImpl.java

Content: 

/** 

 * Implements JAXP's Transformer.setOutputProperties(). Set the output properties for the transformation. These properties will override properties set in the Templates with xsl:output. Unrecognised properties will be quitely ignored.

 * @param properties The properties to use for the Transformer

 * @throws IllegalArgumentException Never, errors are ignored

 */

public void setOutputProperties(Properties properties) throws IllegalArgumentException {

  if (properties != null) {

    final Enumeration names=properties.propertyNames();

    while (names.hasMoreElements()) {

      final String name=(String)names.nextElement();

      if (isDefaultProperty(name,properties))       continue;

      if (validOutputProperty(name)) {

        _properties.setProperty(name,properties.getProperty(name));

      }

 else {

        ErrorMsg err=new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR,name);

        throw new IllegalArgumentException(err.toString());

      }

    }

  }

 else {

    _properties=_propertiesClone;

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the original output target. This is useful when using a SAX transform and supplying a ContentHandler or when the URI of the output target should not be the same as the systemID of the original output target. NEEDSDOC @param outputTarget

 */

public void setOutputTarget(Result outputTarget){

  m_outputTarget=outputTarget;

}

Location: TransformerImpl.java

Content: 

/** 

 * Set a bag of parameters for the transformation. Note that these will not be additive, they will replace the existing set of parameters. NEEDSDOC @param params

 */

public void setParameters(Properties params){

  clearParameters();

  Enumeration names=params.propertyNames();

  while (names.hasMoreElements()) {

    String name=params.getProperty((String)names.nextElement());

    StringTokenizer tokenizer=new StringTokenizer(name,"{}",false);

    try {

      String s1=tokenizer.nextToken();

      String s2=tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

      if (null == s2)       setParameter(s1,null,params.getProperty(name));

 else       setParameter(s2,s1,params.getProperty(name));

    }

 catch (    java.util.NoSuchElementException nsee) {

    }

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Set a parameter for the templates.

 * @param name      The name of the parameter.

 * @param namespace The namespace of the parameter.

 * @param value     The value object. This can be any valid Java object -- it'sup to the processor to provide the proper coersion to the object, or simply pass it on for use in extensions.

 */

public void setParameter(String name,String namespace,Object value){

  VariableStack varstack=getXPathContext().getVarStack();

  QName qname=new QName(namespace,name);

  XObject xobject=XObject.create(value,getXPathContext());

  StylesheetRoot sroot=m_stylesheetRoot;

  Vector vars=sroot.getVariablesAndParamsComposed();

  int i=vars.size();

  while (--i >= 0) {

    ElemVariable variable=(ElemVariable)vars.elementAt(i);

    if (variable.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE && variable.getName().equals(qname)) {

      varstack.setGlobalVariable(i,xobject);

    }

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * If the quietConflictWarnings property is set to true, warnings about pattern conflicts won't be printed to the diagnostics stream. False by default. (Currently setting this property will have no effect.)

 * @param b true if conflict warnings should be suppressed.

 */

public void setQuietConflictWarnings(boolean b){

  m_quietConflictWarnings=b;

}

Location: TransformerImpl.java

Content: 

/** 

 * NEEDSDOC Method setShouldReset NEEDSDOC @param shouldReset

 */

public void setShouldReset(boolean shouldReset){

  m_shouldReset=shouldReset;

}

Location: TransformerImpl.java

Content: 

/** 

 * This is just a way to set the document for run().

 * @param doc A non-null reference to the root of the tree to be transformed.

 */

public void setSourceTreeDocForThread(int doc){

  m_doc=doc;

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the stylesheet for this processor. If this is set, then the process calls that take only the input .xml will use this instead of looking for a stylesheet PI. Also, setting the stylesheet is needed if you are going to use the processor as a SAX ContentHandler.

 * @param stylesheetRoot A non-null StylesheetRoot object, or null if you wishto clear the stylesheet reference.

 */

public void setStylesheet(StylesheetRoot stylesheetRoot){

  m_stylesheetRoot=stylesheetRoot;

}

Location: TransformerImpl.java

Content: 

/** 

 * Get the thread that the transform process is on.

 * @param t The transform thread, may be null.

 * @xsl.usage internal

 */

public void setTransformThread(Thread t){

  m_transformThread=t;

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the input source for the source tree, which is needed if the parse thread is not the main thread, in order for the parse thread's run method to get to the input source.

 * @param source The input source for the source tree.

 */

public void setXMLSource(Source source){

  m_xmlSource=source;

}

Location: TransformerImpl.java

Content: 

/** 

 * Set the execution context for XPath.

 * @param xcontext A non-null reference to the XPathContext associated with thistransformer.

 * @xsl.usage internal

 */

public void setXPathContext(XPathContext xcontext){

  m_xcontext=xcontext;

}

Location: TransformerImpl.java

Content: 

/** 

 * NEEDSDOC Method stopTransformation

 */

public void stopTransformation(){

}

Location: TransformerImpl.java

Content: 

/** 

 * Internal method to pass any properties to the translet prior to initiating the transformation

 */

private void transferOutputProperties(AbstractTranslet translet){

  if (_properties == null)   return;

  Enumeration names=_properties.propertyNames();

  while (names.hasMoreElements()) {

    String name=(String)names.nextElement();

    String value=(String)_properties.get(name);

    if (value == null)     continue;

    if (name.equals(OutputKeys.ENCODING)) {

      translet._encoding=value;

    }

 else     if (name.equals(OutputKeys.METHOD)) {

      translet._method=value;

    }

 else     if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {

      translet._doctypePublic=value;

    }

 else     if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {

      translet._doctypeSystem=value;

    }

 else     if (name.equals(OutputKeys.MEDIA_TYPE)) {

      translet._mediaType=value;

    }

 else     if (name.equals(OutputKeys.STANDALONE)) {

      translet._standalone=value;

    }

 else     if (name.equals(OutputKeys.VERSION)) {

      translet._version=value;

    }

 else     if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {

      translet._omitHeader=(value != null && value.toLowerCase().equals("yes"));

    }

 else     if (name.equals(OutputKeys.INDENT)) {

      translet._indent=(value != null && value.toLowerCase().equals("yes"));

    }

 else     if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {

      if (value != null) {

        translet._cdata=null;

        StringTokenizer e=new StringTokenizer(value);

        while (e.hasMoreTokens()) {

          translet.addCdataElement(e.nextToken());

        }

      }

    }

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * This method is used to pass any properties to the output handler when running the identity transform.

 */

public void transferOutputProperties(SerializationHandler handler){

  if (_properties == null)   return;

  String doctypePublic=null;

  String doctypeSystem=null;

  Enumeration names=_properties.propertyNames();

  while (names.hasMoreElements()) {

    String name=(String)names.nextElement();

    String value=(String)_properties.get(name);

    if (value == null)     continue;

    if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {

      doctypePublic=value;

    }

 else     if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {

      doctypeSystem=value;

    }

 else     if (name.equals(OutputKeys.MEDIA_TYPE)) {

      handler.setMediaType(value);

    }

 else     if (name.equals(OutputKeys.STANDALONE)) {

      handler.setStandalone(value);

    }

 else     if (name.equals(OutputKeys.VERSION)) {

      handler.setVersion(value);

    }

 else     if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {

      handler.setOmitXMLDeclaration(value != null && value.toLowerCase().equals("yes"));

    }

 else     if (name.equals(OutputKeys.INDENT)) {

      handler.setIndent(value != null && value.toLowerCase().equals("yes"));

    }

 else     if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {

      if (value != null) {

        StringTokenizer e=new StringTokenizer(value);

        Vector uriAndLocalNames=null;

        while (e.hasMoreTokens()) {

          final String token=e.nextToken();

          int lastcolon=token.lastIndexOf(':');

          String uri;

          String localName;

          if (lastcolon > 0) {

            uri=token.substring(0,lastcolon);

            localName=token.substring(lastcolon + 1);

          }

 else {

            uri=null;

            localName=token;

          }

          if (uriAndLocalNames == null) {

            uriAndLocalNames=new Vector();

          }

          uriAndLocalNames.addElement(uri);

          uriAndLocalNames.addElement(localName);

        }

        handler.setCdataSectionElements(uriAndLocalNames);

      }

    }

  }

  if (doctypePublic != null || doctypeSystem != null) {

    handler.setDoctype(doctypeSystem,doctypePublic);

  }

}

Location: TransformerImpl.java

Content: 

protected TransformerImpl(Properties outputProperties,int indentNumber,TransformerFactoryImpl tfactory){

  this(null,outputProperties,indentNumber,tfactory);

  _isIdentity=true;

}

Location: TransformerImpl.java

Content: 

/** 

 * Construct a TransformerImpl.

 * @param stylesheet The root of the stylesheet tree.

 */

public TransformerImpl(StylesheetRoot stylesheet){

  m_optimizer=stylesheet.getOptimizer();

  m_incremental=stylesheet.getIncremental();

  m_source_location=stylesheet.getSource_location();

  setStylesheet(stylesheet);

  XPathContext xPath=new XPathContext(this);

  xPath.setIncremental(m_incremental);

  xPath.getDTMManager().setIncremental(m_incremental);

  xPath.setSource_location(m_source_location);

  xPath.getDTMManager().setSource_location(m_source_location);

  if (stylesheet.isSecureProcessing())   xPath.setSecureProcessing(true);

  setXPathContext(xPath);

  getXPathContext().setNamespaceContext(stylesheet);

  m_stackGuard=new StackGuard(this);

}

Location: TransformerImpl.java

Content: 

protected TransformerImpl(Translet translet,Properties outputProperties,int indentNumber,TransformerFactoryImpl tfactory){

  _translet=(AbstractTranslet)translet;

  _properties=createOutputProperties(outputProperties);

  _propertiesClone=(Properties)_properties.clone();

  _indentNumber=indentNumber;

  _tfactory=tfactory;

}

Location: TransformerImpl.java

Content: 

private void transformIdentity(Source source,SerializationHandler handler) throws Exception {

  if (source != null) {

    _sourceSystemId=source.getSystemId();

  }

  if (source instanceof StreamSource) {

    final StreamSource stream=(StreamSource)source;

    final InputStream streamInput=stream.getInputStream();

    final Reader streamReader=stream.getReader();

    final XMLReader reader=_readerManager.getXMLReader();

    try {

      try {

        reader.setProperty(LEXICAL_HANDLER_PROPERTY,handler);

      }

 catch (      SAXException e) {

      }

      reader.setContentHandler(handler);

      InputSource input;

      if (streamInput != null) {

        input=new InputSource(streamInput);

        input.setSystemId(_sourceSystemId);

      }

 else       if (streamReader != null) {

        input=new InputSource(streamReader);

        input.setSystemId(_sourceSystemId);

      }

 else       if (_sourceSystemId != null) {

        input=new InputSource(_sourceSystemId);

      }

 else {

        ErrorMsg err=new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);

        throw new TransformerException(err.toString());

      }

      reader.parse(input);

    }

  finally {

      _readerManager.releaseXMLReader(reader);

    }

  }

 else   if (source instanceof SAXSource) {

    final SAXSource sax=(SAXSource)source;

    XMLReader reader=sax.getXMLReader();

    final InputSource input=sax.getInputSource();

    boolean userReader=true;

    try {

      if (reader == null) {

        reader=_readerManager.getXMLReader();

        userReader=false;

      }

      try {

        reader.setProperty(LEXICAL_HANDLER_PROPERTY,handler);

      }

 catch (      SAXException e) {

      }

      reader.setContentHandler(handler);

      reader.parse(input);

    }

  finally {

      if (!userReader) {

        _readerManager.releaseXMLReader(reader);

      }

    }

  }

 else   if (source instanceof DOMSource) {

    final DOMSource domsrc=(DOMSource)source;

    new DOM2TO(domsrc.getNode(),handler).parse();

  }

 else   if (source instanceof XSLTCSource) {

    final DOM dom=((XSLTCSource)source).getDOM(null,_translet);

    ((SAXImpl)dom).copy(handler);

  }

 else {

    ErrorMsg err=new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);

    throw new TransformerException(err.toString());

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Process the source node to the output result, if the processor supports the "http://xml.org/trax/features/dom/input" feature. %REVIEW% Do we need a Node version of this?

 * @param node The input source node, which can be any valid DTM node.

 * @throws TransformerException

 */

public void transformNode(int node) throws TransformerException {

  setExtensionsTable(getStylesheet());

synchronized (m_serializationHandler) {

    m_hasBeenReset=false;

    XPathContext xctxt=getXPathContext();

    DTM dtm=xctxt.getDTM(node);

    try {

      pushGlobalVars(node);

      StylesheetRoot stylesheet=this.getStylesheet();

      int n=stylesheet.getGlobalImportCount();

      for (int i=0; i < n; i++) {

        StylesheetComposed imported=stylesheet.getGlobalImport(i);

        int includedCount=imported.getIncludeCountComposed();

        for (int j=-1; j < includedCount; j++) {

          Stylesheet included=imported.getIncludeComposed(j);

          included.runtimeInit(this);

          for (ElemTemplateElement child=included.getFirstChildElem(); child != null; child=child.getNextSiblingElem()) {

            child.runtimeInit(this);

          }

        }

      }

      DTMIterator dtmIter=new org.apache.xpath.axes.SelfIteratorNoPredicate();

      dtmIter.setRoot(node,xctxt);

      xctxt.pushContextNodeList(dtmIter);

      try {

        this.applyTemplateToNode(null,null,node);

      }

  finally {

        xctxt.popContextNodeList();

      }

      if (null != m_serializationHandler) {

        m_serializationHandler.endDocument();

      }

    }

 catch (    Exception se) {

      while (se instanceof org.apache.xml.utils.WrappedRuntimeException) {

        Exception e=((org.apache.xml.utils.WrappedRuntimeException)se).getException();

        if (null != e)         se=e;

      }

      if (null != m_serializationHandler) {

        try {

          if (se instanceof org.xml.sax.SAXParseException)           m_serializationHandler.fatalError((org.xml.sax.SAXParseException)se);

 else           if (se instanceof TransformerException) {

            TransformerException te=((TransformerException)se);

            SAXSourceLocator sl=new SAXSourceLocator(te.getLocator());

            m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(te.getMessage(),sl,te));

          }

 else {

            m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(se.getMessage(),new SAXSourceLocator(),se));

          }

        }

 catch (        Exception e) {

        }

      }

      if (se instanceof TransformerException) {

        m_errorHandler.fatalError((TransformerException)se);

      }

 else       if (se instanceof org.xml.sax.SAXParseException) {

        m_errorHandler.fatalError(new TransformerException(se.getMessage(),new SAXSourceLocator((org.xml.sax.SAXParseException)se),se));

      }

 else {

        m_errorHandler.fatalError(new TransformerException(se));

      }

    }

 finally {

      this.reset();

    }

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Process the source node to the output result, if the processor supports the "http://xml.org/trax/features/dom/input" feature. %REVIEW% Do we need a Node version of this?

 * @param node         The input source node, which can be any valid DTM node.

 * @param outputTarget The output source target.

 * @throws TransformerException

 */

public void transformNode(int node,Result outputTarget) throws TransformerException {

  SerializationHandler xoh=createSerializationHandler(outputTarget);

  this.setSerializationHandler(xoh);

  m_outputTarget=outputTarget;

  transformNode(node);

}

Location: TransformerImpl.java

Content: 

/** 

 * Given a stylesheet element, create a result tree fragment from it's contents. The fragment will also use the shared DTM system, but will obtain its space from the global variable pool rather than the dynamic variable stack. This allows late binding of XUnresolvedVariables without the risk that their content will be discarded when the variable stack is popped.

 * @param templateParent The template element that holds the fragment.

 * @return the NodeHandle for the root node of the resulting RTF.

 * @throws TransformerException

 * @xsl.usage advanced

 */

public int transformToGlobalRTF(ElemTemplateElement templateParent) throws TransformerException {

  DTM dtmFrag=m_xcontext.getGlobalRTFDTM();

  return transformToRTF(templateParent,dtmFrag);

}

Location: TransformerImpl.java

Content: 

/** 

 * Given a stylesheet element, create a result tree fragment from it's contents. The fragment will be built within the shared RTF DTM system used as a variable stack.

 * @param templateParent The template element that holds the fragment.

 * @return the NodeHandle for the root node of the resulting RTF.

 * @throws TransformerException

 * @xsl.usage advanced

 */

public int transformToRTF(ElemTemplateElement templateParent) throws TransformerException {

  DTM dtmFrag=m_xcontext.getRTFDTM();

  return transformToRTF(templateParent,dtmFrag);

}

Location: TransformerImpl.java

Content: 

/** 

 * Given a stylesheet element, create a result tree fragment from it's contents.

 * @param templateParent The template element that holds the fragment.

 * @param dtmFrag        The DTM to write the RTF into

 * @return the NodeHandle for the root node of the resulting RTF.

 * @throws TransformerException

 * @xsl.usage advanced

 */

private int transformToRTF(ElemTemplateElement templateParent,DTM dtmFrag) throws TransformerException {

  XPathContext xctxt=m_xcontext;

  ContentHandler rtfHandler=dtmFrag.getContentHandler();

  int resultFragment;

  SerializationHandler savedRTreeHandler=this.m_serializationHandler;

  ToSAXHandler h=new ToXMLSAXHandler();

  h.setContentHandler(rtfHandler);

  h.setTransformer(this);

  m_serializationHandler=h;

  SerializationHandler rth=m_serializationHandler;

  try {

    rth.startDocument();

    rth.flushPending();

    try {

      executeChildTemplates(templateParent,true);

      rth.flushPending();

      resultFragment=dtmFrag.getDocument();

    }

  finally {

      rth.endDocument();

    }

  }

 catch (  org.xml.sax.SAXException se) {

    throw new TransformerException(se);

  }

 finally {

    this.m_serializationHandler=savedRTreeHandler;

  }

  return resultFragment;

}

Location: TransformerImpl.java

Content: 

/** 

 * Take the contents of a template element, process it, and convert it to a string.

 * @param elem The parent element whose children will be output as a string.

 * @return The stringized result of executing the elements children.

 * @throws TransformerException

 * @xsl.usage advanced

 */

public String transformToString(ElemTemplateElement elem) throws TransformerException {

  ElemTemplateElement firstChild=elem.getFirstChildElem();

  if (null == firstChild)   return "";

  if (elem.hasTextLitOnly() && m_optimizer) {

    return ((ElemTextLiteral)firstChild).getNodeValue();

  }

  SerializationHandler savedRTreeHandler=this.m_serializationHandler;

  StringWriter sw=(StringWriter)m_stringWriterObjectPool.getInstance();

  m_serializationHandler=(ToTextStream)m_textResultHandlerObjectPool.getInstance();

  if (null == m_serializationHandler) {

    Serializer serializer=org.apache.xml.serializer.SerializerFactory.getSerializer(m_textformat.getProperties());

    m_serializationHandler=(SerializationHandler)serializer;

  }

  m_serializationHandler.setTransformer(this);

  m_serializationHandler.setWriter(sw);

  String result;

  try {

    executeChildTemplates(elem,true);

    this.m_serializationHandler.endDocument();

    result=sw.toString();

  }

 catch (  org.xml.sax.SAXException se) {

    throw new TransformerException(se);

  }

 finally {

    sw.getBuffer().setLength(0);

    try {

      sw.close();

    }

 catch (    Exception ioe) {

    }

    m_stringWriterObjectPool.freeInstance(sw);

    m_serializationHandler.reset();

    m_textResultHandlerObjectPool.freeInstance(m_serializationHandler);

    m_serializationHandler=savedRTreeHandler;

  }

  return result;

}

Location: TransformerImpl.java

Content: 

/** 

 * Process the source tree to SAX parse events.

 * @param source The input for the source tree.

 * @throws TransformerException

 */

public void transform(Source source) throws TransformerException {

  transform(source,true);

}

Location: TransformerImpl.java

Content: 

/** 

 * Process the source tree to SAX parse events.

 * @param source        The input for the source tree.

 * @param shouldRelease Flag indicating whether to release DTMManager.

 * @throws TransformerException

 */

public void transform(Source source,boolean shouldRelease) throws TransformerException {

  try {

    if (getXPathContext().getNamespaceContext() == null) {

      getXPathContext().setNamespaceContext(getStylesheet());

    }

    String base=source.getSystemId();

    if (null == base) {

      base=m_stylesheetRoot.getBaseIdentifier();

    }

    if (null == base) {

      String currentDir="";

      try {

        currentDir=System.getProperty("user.dir");

      }

 catch (      SecurityException se) {

      }

      if (currentDir.startsWith(java.io.File.separator))       base="file://" + currentDir;

 else       base="file:///" + currentDir;

      base=base + java.io.File.separatorChar + source.getClass().getName();

    }

    setBaseURLOfSource(base);

    DTMManager mgr=m_xcontext.getDTMManager();

    if ((source instanceof StreamSource && source.getSystemId() == null && ((StreamSource)source).getInputStream() == null && ((StreamSource)source).getReader() == null) || (source instanceof SAXSource && ((SAXSource)source).getInputSource() == null && ((SAXSource)source).getXMLReader() == null) || (source instanceof DOMSource && ((DOMSource)source).getNode() == null)) {

      try {

        DocumentBuilderFactory builderF=DocumentBuilderFactory.newInstance();

        DocumentBuilder builder=builderF.newDocumentBuilder();

        String systemID=source.getSystemId();

        source=new DOMSource(builder.newDocument());

        if (systemID != null) {

          source.setSystemId(systemID);

        }

      }

 catch (      ParserConfigurationException e) {

        fatalError(e);

      }

    }

    DTM dtm=mgr.getDTM(source,false,this,true,true);

    dtm.setDocumentBaseURI(base);

    boolean hardDelete=true;

    try {

      this.transformNode(dtm.getDocument());

    }

  finally {

      if (shouldRelease)       mgr.release(dtm,hardDelete);

    }

    Exception e=getExceptionThrown();

    if (null != e) {

      if (e instanceof javax.xml.transform.TransformerException) {

        throw (javax.xml.transform.TransformerException)e;

      }

 else       if (e instanceof org.apache.xml.utils.WrappedRuntimeException) {

        fatalError(((org.apache.xml.utils.WrappedRuntimeException)e).getException());

      }

 else {

        throw new javax.xml.transform.TransformerException(e);

      }

    }

 else     if (null != m_serializationHandler) {

      m_serializationHandler.endDocument();

    }

  }

 catch (  org.apache.xml.utils.WrappedRuntimeException wre) {

    Throwable throwable=wre.getException();

    while (throwable instanceof org.apache.xml.utils.WrappedRuntimeException) {

      throwable=((org.apache.xml.utils.WrappedRuntimeException)throwable).getException();

    }

    fatalError(throwable);

  }

catch (  org.xml.sax.SAXParseException spe) {

    fatalError(spe);

  }

catch (  org.xml.sax.SAXException se) {

    m_errorHandler.fatalError(new TransformerException(se));

  }

 finally {

    m_hasTransformThreadErrorCatcher=false;

    reset();

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Implements JAXP's Transformer.transform()

 * @param source Contains the input XML document

 * @param result Will contain the output from the transformation

 * @throws TransformerException

 */

public void transform(Source source,Result result) throws TransformerException {

  if (!_isIdentity) {

    if (_translet == null) {

      ErrorMsg err=new ErrorMsg(ErrorMsg.JAXP_NO_TRANSLET_ERR);

      throw new TransformerException(err.toString());

    }

    transferOutputProperties(_translet);

  }

  final SerializationHandler toHandler=getOutputHandler(result);

  if (toHandler == null) {

    ErrorMsg err=new ErrorMsg(ErrorMsg.JAXP_NO_HANDLER_ERR);

    throw new TransformerException(err.toString());

  }

  if (_uriResolver != null && !_isIdentity) {

    _translet.setDOMCache(this);

  }

  if (_isIdentity) {

    transferOutputProperties(toHandler);

  }

  transform(source,toHandler,_encoding);

  if (result instanceof DOMResult) {

    ((DOMResult)result).setNode(_tohFactory.getNode());

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Process the source tree to the output result.

 * @param xmlSource     The input for the source tree.

 * @param outputTarget  The output source target.

 * @param shouldRelease Flag indicating whether to release DTMManager.

 * @throws TransformerException

 */

public void transform(Source xmlSource,Result outputTarget,boolean shouldRelease) throws TransformerException {

synchronized (m_reentryGuard) {

    SerializationHandler xoh=createSerializationHandler(outputTarget);

    this.setSerializationHandler(xoh);

    m_outputTarget=outputTarget;

    transform(xmlSource,shouldRelease);

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Internal transformation method - uses the internal APIs of XSLTC

 */

private void transform(Source source,SerializationHandler handler,String encoding) throws TransformerException {

  try {

    if ((source instanceof StreamSource && source.getSystemId() == null && ((StreamSource)source).getInputStream() == null && ((StreamSource)source).getReader() == null) || (source instanceof SAXSource && ((SAXSource)source).getInputSource() == null && ((SAXSource)source).getXMLReader() == null) || (source instanceof DOMSource && ((DOMSource)source).getNode() == null)) {

      DocumentBuilderFactory builderF=DocumentBuilderFactory.newInstance();

      DocumentBuilder builder=builderF.newDocumentBuilder();

      String systemID=source.getSystemId();

      source=new DOMSource(builder.newDocument());

      if (systemID != null) {

        source.setSystemId(systemID);

      }

    }

    if (_isIdentity) {

      transformIdentity(source,handler);

    }

 else {

      _translet.transform(getDOM(source),handler);

    }

  }

 catch (  TransletException e) {

    if (_errorListener != null)     postErrorToListener(e.getMessage());

    throw new TransformerException(e);

  }

catch (  RuntimeException e) {

    if (_errorListener != null)     postErrorToListener(e.getMessage());

    throw new TransformerException(e);

  }

catch (  Exception e) {

    if (_errorListener != null)     postErrorToListener(e.getMessage());

    throw new TransformerException(e);

  }

 finally {

    _dtmManager=null;

  }

  if (_ostream != null) {

    try {

      _ostream.close();

    }

 catch (    IOException e) {

    }

    _ostream=null;

  }

}

Location: TransformerImpl.java

Content: 

/** 

 * Verifies if a given output property name is a property defined in the JAXP 1.1 / TrAX spec

 */

private boolean validOutputProperty(String name){

  return (name.equals(OutputKeys.ENCODING) || name.equals(OutputKeys.METHOD) || name.equals(OutputKeys.INDENT)|| name.equals(OutputKeys.DOCTYPE_PUBLIC)|| name.equals(OutputKeys.DOCTYPE_SYSTEM)|| name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)|| name.equals(OutputKeys.MEDIA_TYPE)|| name.equals(OutputKeys.OMIT_XML_DECLARATION)|| name.equals(OutputKeys.STANDALONE)|| name.equals(OutputKeys.VERSION)|| name.charAt(0) == '{');

}

Location: TransformerImpl.java

Content: 

/** 

 * Used by SourceTreeHandler to wait until the transform completes

 * @throws SAXException

 */

public void waitTransformThread() throws SAXException {

  Thread transformThread=this.getTransformThread();

  if (null != transformThread) {

    try {

      ThreadControllerWrapper.waitThread(transformThread,this);

      if (!this.hasTransformThreadErrorCatcher()) {

        Exception e=this.getExceptionThrown();

        if (null != e) {

          e.printStackTrace();

          throw new org.xml.sax.SAXException(e);

        }

      }

      this.setTransformThread(null);

    }

 catch (    InterruptedException ie) {

    }

  }

}

