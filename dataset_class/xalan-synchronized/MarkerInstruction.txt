Location: MarkerInstruction.java

Content: 

/** 

 * {@link org.apache.bcel.generic.Visitor}s will know nothing about this kind of {@link org.apche.bcel.generic.Instruction}, so this method does nothing.

 */

public void accept(Visitor v){

}

Location: MarkerInstruction.java

Content: 

/** 

 * The number of JVM stack entries consumed by the instruction. This instruction is just a place holder, so it does not consume any stack entries.

 * @param cpg The {@link org.apache.bcel.generic.ConstantPoolGen} for thecurrent  {@link org.apache.bcel.generic.ClassGen}

 * @return <code>0</code> always

 */

final public int consumeStack(ConstantPoolGen cpg){

  return 0;

}

Location: MarkerInstruction.java

Content: 

/** 

 * Produce a copy of the instruction. By default a  {@link MarkerInstruction} hasno parameters, so the base implementation of  {@link #copy()} returns theinstruction itself.

 * @return The instruction itself.

 */

public Instruction copy(){

  return this;

}

Location: MarkerInstruction.java

Content: 

/** 

 * Dump instruction as byte code to stream out. A  {@link MarkerInstruction} hasno effect on the generated byte code so it is never emitted to the output stream.

 * @param out Output stream

 */

final public void dump(DataOutputStream out) throws IOException {

}

Location: MarkerInstruction.java

Content: 

/** 

 * Zero-argument constructor. Sets the opcode to an invalid value and sets the length to zero, as it will not be written as part of the generated byte code.

 */

public MarkerInstruction(){

  super(Constants.UNDEFINED,(short)0);

}

Location: MarkerInstruction.java

Content: 

/** 

 * The number of JVM stack entries produced by the instruction. This instruction is just a place holder, so it does not produce any stack entries.

 * @param cpg The {@link org.apache.bcel.generic.ConstantPoolGen} for thecurrent  {@link org.apache.bcel.generic.ClassGen}

 * @return <code>0</code> always

 */

final public int produceStack(ConstantPoolGen cpg){

  return 0;

}

