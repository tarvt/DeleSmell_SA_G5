Location: MethodGenerator.java

Content: 

/** 

 * Add a pre-compiled pattern to this mode.

 */

public void addInstructionList(Pattern pattern,InstructionList ilist){

  _preCompiled.put(pattern,ilist);

}

Location: MethodGenerator.java

Content: 

public LocalVariableGen addLocalVariable2(String name,Type type,InstructionHandle start){

  LocalVariableGen lvg=super.addLocalVariable(name,type,_slotAllocator.allocateSlot(type),start,null);

  getLocalVariableRegistry().registerLocalVariable(lvg);

  return lvg;

}

Location: MethodGenerator.java

Content: 

/** 

 * Allocates a local variable. If the slot allocator has already been initialized, then call addLocalVariable2() so that the new variable is known to the allocator. Failing to do this may cause the allocator to return a slot that is already in use.

 */

public LocalVariableGen addLocalVariable(String name,Type type,InstructionHandle start,InstructionHandle end){

  LocalVariableGen lvg;

  if (_allocatorInit) {

    lvg=addLocalVariable2(name,type,start);

  }

 else {

    lvg=super.addLocalVariable(name,type,start,end);

    getLocalVariableRegistry().registerLocalVariable(lvg);

  }

  return lvg;

}

Location: MethodGenerator.java

Content: 

public final Instruction attribute(){

  return _attribute;

}

Location: MethodGenerator.java

Content: 

public final Instruction endElement(){

  return _endElement;

}

Location: MethodGenerator.java

Content: 

/** 

 * Find the outlineable chunks in this method that would be the best choices to outline, based on size and position in the method.

 * @param classGen        The {@link ClassGen} with which the generated methodswill be associated

 * @param totalMethodSize the size of the bytecode in the original method

 * @return a <code>java.util.ArrayList</code> containing the{@link MethodGenerator.Chunk}s that may be outlined from this method

 */

private ArrayList getCandidateChunks(ClassGenerator classGen,int totalMethodSize){

  Iterator instructions=getInstructionList().iterator();

  ArrayList candidateChunks=new ArrayList();

  ArrayList currLevelChunks=new ArrayList();

  Stack subChunkStack=new Stack();

  boolean openChunkAtCurrLevel=false;

  boolean firstInstruction=true;

  InstructionHandle currentHandle;

  if (m_openChunks != 0) {

    String msg=(new ErrorMsg(ErrorMsg.OUTLINE_ERR_UNBALANCED_MARKERS)).toString();

    throw new InternalError(msg);

  }

  do {

    currentHandle=instructions.hasNext() ? (InstructionHandle)instructions.next() : null;

    Instruction inst=(currentHandle != null) ? currentHandle.getInstruction() : null;

    if (firstInstruction) {

      openChunkAtCurrLevel=true;

      currLevelChunks.add(currentHandle);

      firstInstruction=false;

    }

    if (inst instanceof OutlineableChunkStart) {

      if (openChunkAtCurrLevel) {

        subChunkStack.push(currLevelChunks);

        currLevelChunks=new ArrayList();

      }

      openChunkAtCurrLevel=true;

      currLevelChunks.add(currentHandle);

    }

 else     if (currentHandle == null || inst instanceof OutlineableChunkEnd) {

      ArrayList nestedSubChunks=null;

      if (!openChunkAtCurrLevel) {

        nestedSubChunks=currLevelChunks;

        currLevelChunks=(ArrayList)subChunkStack.pop();

      }

      InstructionHandle chunkStart=(InstructionHandle)currLevelChunks.get(currLevelChunks.size() - 1);

      int chunkEndPosition=(currentHandle != null) ? currentHandle.getPosition() : totalMethodSize;

      int chunkSize=chunkEndPosition - chunkStart.getPosition();

      if (chunkSize <= TARGET_METHOD_SIZE) {

        currLevelChunks.add(currentHandle);

      }

 else {

        if (!openChunkAtCurrLevel) {

          int childChunkCount=nestedSubChunks.size() / 2;

          if (childChunkCount > 0) {

            Chunk[] childChunks=new Chunk[childChunkCount];

            for (int i=0; i < childChunkCount; i++) {

              InstructionHandle start=(InstructionHandle)nestedSubChunks.get(i * 2);

              InstructionHandle end=(InstructionHandle)nestedSubChunks.get(i * 2 + 1);

              childChunks[i]=new Chunk(start,end);

            }

            ArrayList mergedChildChunks=mergeAdjacentChunks(childChunks);

            for (int i=0; i < mergedChildChunks.size(); i++) {

              Chunk mergedChunk=(Chunk)mergedChildChunks.get(i);

              int mergedSize=mergedChunk.getChunkSize();

              if (mergedSize >= MINIMUM_OUTLINEABLE_CHUNK_SIZE && mergedSize <= TARGET_METHOD_SIZE) {

                candidateChunks.add(mergedChunk);

              }

            }

          }

        }

        currLevelChunks.remove(currLevelChunks.size() - 1);

      }

      openChunkAtCurrLevel=((currLevelChunks.size() & 0x1) == 1);

    }

  }

 while (currentHandle != null);

  return candidateChunks;

}

Location: MethodGenerator.java

Content: 

/** 

 * <p> Get all  {@link Method}s generated by this  {@link MethodGenerator}. The {@link MethodGen#getMethod()} only returns a single <code>Method</code>object. This method takes into account the Java Virtual Machine Specification limit of 64KB on the size of a method, and may return more than one <code>Method</code>. </p> <p> If the code associated with the <code>MethodGenerator</code> would exceed the 64KB limit, this method will attempt to split the code in the {@link InstructionList} associated with this <code>MethodGenerator</code>into several methods. </p>

 * @param classGen the {@link ClassGenerator} of which these methods are members

 * @return an array of all the <code>Method</code>s generated

 */

Method[] getGeneratedMethods(ClassGenerator classGen){

  Method[] generatedMethods;

  InstructionList il=getInstructionList();

  InstructionHandle last=il.getEnd();

  il.setPositions();

  int instructionListSize=last.getPosition() + last.getInstruction().getLength();

  if (instructionListSize > MAX_BRANCH_TARGET_OFFSET) {

    boolean ilChanged=widenConditionalBranchTargetOffsets();

    if (ilChanged) {

      il.setPositions();

      last=il.getEnd();

      instructionListSize=last.getPosition() + last.getInstruction().getLength();

    }

  }

  if (instructionListSize > MAX_METHOD_SIZE) {

    generatedMethods=outlineChunks(classGen,instructionListSize);

  }

 else {

    generatedMethods=new Method[]{getThisMethod()};

  }

  return generatedMethods;

}

Location: MethodGenerator.java

Content: 

/** 

 * Get the instruction list for a pre-compiled pattern. Used by test sequences to avoid compiling patterns more than once.

 */

public InstructionList getInstructionList(Pattern pattern){

  return (InstructionList)_preCompiled.get(pattern);

}

Location: MethodGenerator.java

Content: 

private LocalVariableRegistry getLocalVariableRegistry(){

  if (_localVariableRegistry == null) {

    _localVariableRegistry=new LocalVariableRegistry();

  }

  return _localVariableRegistry;

}

Location: MethodGenerator.java

Content: 

public LocalVariableGen getLocalVariable(String name){

  return getLocalVariableRegistry().lookUpByName(name);

}

Location: MethodGenerator.java

Content: 

protected Method getThisMethod(){

  stripAttributes(true);

  setMaxLocals();

  setMaxStack();

  removeNOPs();

  return getMethod();

}

Location: MethodGenerator.java

Content: 

/** 

 * by default context node is the same as current node. MK437 

 */

public Instruction loadContextNode(){

  return loadCurrentNode();

}

Location: MethodGenerator.java

Content: 

/** 

 * Helper method to generate an instance of a subclass of {@link LoadInstruction} based on the specified {@link Type} that will loadthe specified local variable

 * @param index the JVM stack frame index of the variable that is to be loaded

 * @param type  the {@link Type} of the variable

 * @return the generated {@link LoadInstruction}

 */

private static Instruction loadLocal(int index,Type type){

  if (type == Type.BOOLEAN) {

    return new ILOAD(index);

  }

 else   if (type == Type.INT) {

    return new ILOAD(index);

  }

 else   if (type == Type.SHORT) {

    return new ILOAD(index);

  }

 else   if (type == Type.LONG) {

    return new LLOAD(index);

  }

 else   if (type == Type.BYTE) {

    return new ILOAD(index);

  }

 else   if (type == Type.CHAR) {

    return new ILOAD(index);

  }

 else   if (type == Type.FLOAT) {

    return new FLOAD(index);

  }

 else   if (type == Type.DOUBLE) {

    return new DLOAD(index);

  }

 else {

    return new ALOAD(index);

  }

}

Location: MethodGenerator.java

Content: 

/** 

 * Mark the end of an outlineable chunk of code. See {@link OutlineableChunkStart} for more information.

 */

public void markChunkEnd(){

  getInstructionList().append(OutlineableChunkEnd.OUTLINEABLECHUNKEND);

  m_openChunks--;

  if (m_openChunks < 0) {

    String msg=(new ErrorMsg(ErrorMsg.OUTLINE_ERR_UNBALANCED_MARKERS)).toString();

    throw new InternalError(msg);

  }

}

Location: MethodGenerator.java

Content: 

/** 

 * Mark the end of the method's  {@link InstructionList} as the start of anoutlineable chunk of code. The outlineable chunk begins after the {@link InstructionHandle} that is at the end of the method's{@link InstructionList}, or at the start of the method if the <code>InstructionList</code> is empty. See  {@link OutlineableChunkStart} formore information.

 */

public void markChunkStart(){

  getInstructionList().append(OutlineableChunkStart.OUTLINEABLECHUNKSTART);

  m_totalChunks++;

  m_openChunks++;

}

Location: MethodGenerator.java

Content: 

/** 

 * Merge adjacent sibling chunks to produce larger candidate chunks for outlining

 * @param chunks array of sibling {@link MethodGenerator.Chunk}s that are under consideration for outlining. Chunks must be in the order encountered in the  {@link InstructionList}

 * @return a <code>java.util.ArrayList</code> of<code>MethodGenerator.Chunk</code>s maximally merged

 */

private ArrayList mergeAdjacentChunks(Chunk[] chunks){

  int[] adjacencyRunStart=new int[chunks.length];

  int[] adjacencyRunLength=new int[chunks.length];

  boolean[] chunkWasMerged=new boolean[chunks.length];

  int maximumRunOfChunks=0;

  int startOfCurrentRun;

  int numAdjacentRuns=0;

  ArrayList mergedChunks=new ArrayList();

  startOfCurrentRun=0;

  for (int i=1; i < chunks.length; i++) {

    if (!chunks[i - 1].isAdjacentTo(chunks[i])) {

      int lengthOfRun=i - startOfCurrentRun;

      if (maximumRunOfChunks < lengthOfRun) {

        maximumRunOfChunks=lengthOfRun;

      }

      if (lengthOfRun > 1) {

        adjacencyRunLength[numAdjacentRuns]=lengthOfRun;

        adjacencyRunStart[numAdjacentRuns]=startOfCurrentRun;

        numAdjacentRuns++;

      }

      startOfCurrentRun=i;

    }

  }

  if (chunks.length - startOfCurrentRun > 1) {

    int lengthOfRun=chunks.length - startOfCurrentRun;

    if (maximumRunOfChunks < lengthOfRun) {

      maximumRunOfChunks=lengthOfRun;

    }

    adjacencyRunLength[numAdjacentRuns]=chunks.length - startOfCurrentRun;

    adjacencyRunStart[numAdjacentRuns]=startOfCurrentRun;

    numAdjacentRuns++;

  }

  for (int numToMerge=maximumRunOfChunks; numToMerge > 1; numToMerge--) {

    for (int run=0; run < numAdjacentRuns; run++) {

      int runStart=adjacencyRunStart[run];

      int runEnd=runStart + adjacencyRunLength[run] - 1;

      boolean foundChunksToMerge=false;

      for (int mergeStart=runStart; mergeStart + numToMerge - 1 <= runEnd && !foundChunksToMerge; mergeStart++) {

        int mergeEnd=mergeStart + numToMerge - 1;

        int mergeSize=0;

        for (int j=mergeStart; j <= mergeEnd; j++) {

          mergeSize=mergeSize + chunks[j].getChunkSize();

        }

        if (mergeSize <= TARGET_METHOD_SIZE) {

          foundChunksToMerge=true;

          for (int j=mergeStart; j <= mergeEnd; j++) {

            chunkWasMerged[j]=true;

          }

          mergedChunks.add(new Chunk(chunks[mergeStart].getChunkStart(),chunks[mergeEnd].getChunkEnd()));

          adjacencyRunLength[run]=adjacencyRunStart[run] - mergeStart;

          int trailingRunLength=runEnd - mergeEnd;

          if (trailingRunLength >= 2) {

            adjacencyRunStart[numAdjacentRuns]=mergeEnd + 1;

            adjacencyRunLength[numAdjacentRuns]=trailingRunLength;

            numAdjacentRuns++;

          }

        }

      }

    }

  }

  for (int i=0; i < chunks.length; i++) {

    if (!chunkWasMerged[i]) {

      mergedChunks.add(chunks[i]);

    }

  }

  return mergedChunks;

}

Location: MethodGenerator.java

Content: 

public MethodGenerator(int access_flags,Type return_type,Type[] arg_types,String[] arg_names,String method_name,String class_name,InstructionList il,ConstantPoolGen cpg){

  super(access_flags,return_type,arg_types,arg_names,method_name,class_name,il,cpg);

  _astoreHandler=new ASTORE(HANDLER_INDEX);

  _aloadHandler=new ALOAD(HANDLER_INDEX);

  _astoreIterator=new ASTORE(ITERATOR_INDEX);

  _aloadIterator=new ALOAD(ITERATOR_INDEX);

  _aloadDom=new ALOAD(DOM_INDEX);

  _astoreDom=new ASTORE(DOM_INDEX);

  final int startElement=cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,"startElement",START_ELEMENT_SIG);

  _startElement=new INVOKEINTERFACE(startElement,2);

  final int endElement=cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,"endElement",END_ELEMENT_SIG);

  _endElement=new INVOKEINTERFACE(endElement,2);

  final int attribute=cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,"addAttribute","(" + STRING_SIG + STRING_SIG+ ")V");

  _attribute=new INVOKEINTERFACE(attribute,3);

  final int uniqueAttribute=cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,"addUniqueAttribute","(" + STRING_SIG + STRING_SIG+ "I)V");

  _uniqueAttribute=new INVOKEINTERFACE(uniqueAttribute,4);

  final int namespace=cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,"namespaceAfterStartElement","(" + STRING_SIG + STRING_SIG+ ")V");

  _namespace=new INVOKEINTERFACE(namespace,3);

  int index=cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,"startDocument","()V");

  _startDocument=new INVOKEINTERFACE(index,1);

  index=cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,"endDocument","()V");

  _endDocument=new INVOKEINTERFACE(index,1);

  index=cpg.addInterfaceMethodref(NODE_ITERATOR,SET_START_NODE,SET_START_NODE_SIG);

  _setStartNode=new INVOKEINTERFACE(index,2);

  index=cpg.addInterfaceMethodref(NODE_ITERATOR,"reset","()" + NODE_ITERATOR_SIG);

  _reset=new INVOKEINTERFACE(index,1);

  index=cpg.addInterfaceMethodref(NODE_ITERATOR,NEXT,NEXT_SIG);

  _nextNode=new INVOKEINTERFACE(index,1);

  _slotAllocator=new SlotAllocator();

  _slotAllocator.initialize(getLocalVariableRegistry().getLocals(false));

  _allocatorInit=true;

}

Location: MethodGenerator.java

Content: 

public final Instruction namespace(){

  return _namespace;

}

Location: MethodGenerator.java

Content: 

/** 

 * Determines whether a particular variable is in use at a particular offset in the byte code for this method. <p> <b>Preconditions:</b> <ul> <li>The  {@link InstructionList#setPositions()} has been called for the{@link InstructionList} associated with this {@link MethodGenerator}.</li> </ul> </p>

 * @param lvg    the {@link LocalVariableGen} for the variable

 * @param offset the position in the byte code

 * @return <code>true</code> if and only if the specified variable is in use atthe particular byte code offset.

 */

boolean offsetInLocalVariableGenRange(LocalVariableGen lvg,int offset){

  InstructionHandle lvgStart=lvg.getStart();

  InstructionHandle lvgEnd=lvg.getEnd();

  if (lvgStart == null) {

    lvgStart=getInstructionList().getStart();

  }

  if (lvgEnd == null) {

    lvgEnd=getInstructionList().getEnd();

  }

  return ((lvgStart.getPosition() <= offset) && (lvgEnd.getPosition() + lvgEnd.getInstruction().getLength() >= offset));

}

Location: MethodGenerator.java

Content: 

/** 

 * Breaks up the IL for this  {@link MethodGenerator} into separate outlinedmethods so that no method exceeds the 64KB limit on the length of the byte code associated with a method.

 * @param classGen           The {@link ClassGen} with which the generatedmethods will be associated

 * @param originalMethodSize The number of bytes of bytecode represented by the{@link InstructionList} of this method

 * @return an array of the outlined <code>Method</code>s and the original methoditself

 */

public Method[] outlineChunks(ClassGenerator classGen,int originalMethodSize){

  ArrayList methodsOutlined=new ArrayList();

  int currentMethodSize=originalMethodSize;

  int outlinedCount=0;

  boolean moreMethodsOutlined;

  String originalMethodName=getName();

  if (originalMethodName.equals("<init>")) {

    originalMethodName="$lt$init$gt$";

  }

 else   if (originalMethodName.equals("<clinit>")) {

    originalMethodName="$lt$clinit$gt$";

  }

  do {

    ArrayList candidateChunks=getCandidateChunks(classGen,currentMethodSize);

    Collections.sort(candidateChunks);

    moreMethodsOutlined=false;

    for (int i=candidateChunks.size() - 1; i >= 0 && currentMethodSize > TARGET_METHOD_SIZE; i--) {

      Chunk chunkToOutline=(Chunk)candidateChunks.get(i);

      methodsOutlined.add(outline(chunkToOutline.getChunkStart(),chunkToOutline.getChunkEnd(),originalMethodName + "$outline$" + outlinedCount,classGen));

      outlinedCount++;

      moreMethodsOutlined=true;

      InstructionList il=getInstructionList();

      InstructionHandle lastInst=il.getEnd();

      il.setPositions();

      currentMethodSize=lastInst.getPosition() + lastInst.getInstruction().getLength();

    }

  }

 while (moreMethodsOutlined && currentMethodSize > TARGET_METHOD_SIZE);

  if (currentMethodSize > MAX_METHOD_SIZE) {

    String msg=(new ErrorMsg(ErrorMsg.OUTLINE_ERR_METHOD_TOO_BIG)).toString();

    throw new InternalError(msg);

  }

  Method[] methodsArr=new Method[methodsOutlined.size() + 1];

  methodsOutlined.toArray(methodsArr);

  methodsArr[methodsOutlined.size()]=getThisMethod();

  return methodsArr;

}

Location: MethodGenerator.java

Content: 

/** 

 * Given an outlineable chunk of code in the current  {@link MethodGenerator}move ("outline") the chunk to a new method, and replace the chunk in the old method with a reference to that new method. No  {@link OutlineableChunkStart}or  {@link OutlineableChunkEnd} instructions are copied.

 * @param first              The {@link InstructionHandle} of the firstinstruction in the chunk to outline

 * @param last               The <code>InstructionHandle</code> of the lastinstruction in the chunk to outline

 * @param outlinedMethodName The name of the new method

 * @param classGen           The {@link ClassGenerator} of which the originaland new methods will be members

 * @return The new {@link Method} containing the outlined code.

 */

private Method outline(InstructionHandle first,InstructionHandle last,String outlinedMethodName,ClassGenerator classGen){

  if (getExceptionHandlers().length != 0) {

    String msg=(new ErrorMsg(ErrorMsg.OUTLINE_ERR_TRY_CATCH)).toString();

    throw new InternalError(msg);

  }

  int outlineChunkStartOffset=first.getPosition();

  int outlineChunkEndOffset=last.getPosition() + last.getInstruction().getLength();

  ConstantPoolGen cpg=getConstantPool();

  final InstructionList newIL=new InstructionList();

  final XSLTC xsltc=classGen.getParser().getXSLTC();

  final String argTypeName=xsltc.getHelperClassName();

  final Type[] argTypes=new Type[]{(new ObjectType(argTypeName)).toJCType()};

  final String argName="copyLocals";

  final String[] argNames=new String[]{argName};

  int methodAttributes=ACC_PRIVATE | ACC_FINAL;

  final boolean isStaticMethod=(getAccessFlags() & ACC_STATIC) != 0;

  if (isStaticMethod) {

    methodAttributes=methodAttributes | ACC_STATIC;

  }

  final MethodGenerator outlinedMethodGen=new MethodGenerator(methodAttributes,org.apache.bcel.generic.Type.VOID,argTypes,argNames,outlinedMethodName,getClassName(),newIL,cpg);

  ClassGenerator copyAreaCG=new ClassGenerator(argTypeName,OBJECT_CLASS,argTypeName + ".java",ACC_FINAL | ACC_PUBLIC | ACC_SUPER,null,classGen.getStylesheet()){

    public boolean isExternal(){

      return true;

    }

  }

;

  ConstantPoolGen copyAreaCPG=copyAreaCG.getConstantPool();

  copyAreaCG.addEmptyConstructor(ACC_PUBLIC);

  int copyAreaFieldCount=0;

  InstructionHandle limit=last.getNext();

  InstructionList oldMethCopyInIL=new InstructionList();

  InstructionList oldMethCopyOutIL=new InstructionList();

  InstructionList newMethCopyInIL=new InstructionList();

  InstructionList newMethCopyOutIL=new InstructionList();

  InstructionHandle outlinedMethodCallSetup=oldMethCopyInIL.append(new NEW(cpg.addClass(argTypeName)));

  oldMethCopyInIL.append(InstructionConstants.DUP);

  oldMethCopyInIL.append(InstructionConstants.DUP);

  oldMethCopyInIL.append(new INVOKESPECIAL(cpg.addMethodref(argTypeName,"<init>","()V")));

  InstructionHandle outlinedMethodRef;

  if (isStaticMethod) {

    outlinedMethodRef=oldMethCopyOutIL.append(new INVOKESTATIC(cpg.addMethodref(classGen.getClassName(),outlinedMethodName,outlinedMethodGen.getSignature())));

  }

 else {

    oldMethCopyOutIL.append(InstructionConstants.THIS);

    oldMethCopyOutIL.append(InstructionConstants.SWAP);

    outlinedMethodRef=oldMethCopyOutIL.append(new INVOKEVIRTUAL(cpg.addMethodref(classGen.getClassName(),outlinedMethodName,outlinedMethodGen.getSignature())));

  }

  boolean chunkStartTargetMappingsPending=false;

  InstructionHandle pendingTargetMappingHandle=null;

  InstructionHandle lastCopyHandle=null;

  HashMap targetMap=new HashMap();

  HashMap localVarMap=new HashMap();

  HashMap revisedLocalVarStart=new HashMap();

  HashMap revisedLocalVarEnd=new HashMap();

  for (InstructionHandle ih=first; ih != limit; ih=ih.getNext()) {

    Instruction inst=ih.getInstruction();

    if (inst instanceof MarkerInstruction) {

      if (ih.hasTargeters()) {

        if (inst instanceof OutlineableChunkEnd) {

          targetMap.put(ih,lastCopyHandle);

        }

 else {

          if (!chunkStartTargetMappingsPending) {

            chunkStartTargetMappingsPending=true;

            pendingTargetMappingHandle=ih;

          }

        }

      }

    }

 else {

      Instruction c=inst.copy();

      if (c instanceof BranchInstruction) {

        lastCopyHandle=newIL.append((BranchInstruction)c);

      }

 else {

        lastCopyHandle=newIL.append(c);

      }

      if (c instanceof LocalVariableInstruction || c instanceof RET) {

        IndexedInstruction lvi=(IndexedInstruction)c;

        int oldLocalVarIndex=lvi.getIndex();

        LocalVariableGen oldLVG=getLocalVariableRegistry().lookupRegisteredLocalVariable(oldLocalVarIndex,ih.getPosition());

        LocalVariableGen newLVG=(LocalVariableGen)localVarMap.get(oldLVG);

        if (localVarMap.get(oldLVG) == null) {

          boolean copyInLocalValue=offsetInLocalVariableGenRange(oldLVG,(outlineChunkStartOffset != 0) ? outlineChunkStartOffset - 1 : 0);

          boolean copyOutLocalValue=offsetInLocalVariableGenRange(oldLVG,outlineChunkEndOffset + 1);

          if (copyInLocalValue || copyOutLocalValue) {

            String varName=oldLVG.getName();

            Type varType=oldLVG.getType();

            newLVG=outlinedMethodGen.addLocalVariable(varName,varType,null,null);

            int newLocalVarIndex=newLVG.getIndex();

            String varSignature=varType.getSignature();

            localVarMap.put(oldLVG,newLVG);

            copyAreaFieldCount++;

            String copyAreaFieldName="field" + copyAreaFieldCount;

            copyAreaCG.addField(new Field(ACC_PUBLIC,copyAreaCPG.addUtf8(copyAreaFieldName),copyAreaCPG.addUtf8(varSignature),null,copyAreaCPG.getConstantPool()));

            int fieldRef=cpg.addFieldref(argTypeName,copyAreaFieldName,varSignature);

            if (copyInLocalValue) {

              oldMethCopyInIL.append(InstructionConstants.DUP);

              InstructionHandle copyInLoad=oldMethCopyInIL.append(loadLocal(oldLocalVarIndex,varType));

              oldMethCopyInIL.append(new PUTFIELD(fieldRef));

              if (!copyOutLocalValue) {

                revisedLocalVarEnd.put(oldLVG,copyInLoad);

              }

              newMethCopyInIL.append(InstructionConstants.ALOAD_1);

              newMethCopyInIL.append(new GETFIELD(fieldRef));

              newMethCopyInIL.append(storeLocal(newLocalVarIndex,varType));

            }

            if (copyOutLocalValue) {

              newMethCopyOutIL.append(InstructionConstants.ALOAD_1);

              newMethCopyOutIL.append(loadLocal(newLocalVarIndex,varType));

              newMethCopyOutIL.append(new PUTFIELD(fieldRef));

              oldMethCopyOutIL.append(InstructionConstants.DUP);

              oldMethCopyOutIL.append(new GETFIELD(fieldRef));

              InstructionHandle copyOutStore=oldMethCopyOutIL.append(storeLocal(oldLocalVarIndex,varType));

              if (!copyInLocalValue) {

                revisedLocalVarStart.put(oldLVG,copyOutStore);

              }

            }

          }

        }

      }

      if (ih.hasTargeters()) {

        targetMap.put(ih,lastCopyHandle);

      }

      if (chunkStartTargetMappingsPending) {

        do {

          targetMap.put(pendingTargetMappingHandle,lastCopyHandle);

          pendingTargetMappingHandle=pendingTargetMappingHandle.getNext();

        }

 while (pendingTargetMappingHandle != ih);

        chunkStartTargetMappingsPending=false;

      }

    }

  }

  InstructionHandle ih=first;

  InstructionHandle ch=newIL.getStart();

  while (ch != null) {

    Instruction i=ih.getInstruction();

    Instruction c=ch.getInstruction();

    if (i instanceof BranchInstruction) {

      BranchInstruction bc=(BranchInstruction)c;

      BranchInstruction bi=(BranchInstruction)i;

      InstructionHandle itarget=bi.getTarget();

      InstructionHandle newTarget=(InstructionHandle)targetMap.get(itarget);

      bc.setTarget(newTarget);

      if (bi instanceof Select) {

        InstructionHandle[] itargets=((Select)bi).getTargets();

        InstructionHandle[] ctargets=((Select)bc).getTargets();

        for (int j=0; j < itargets.length; j++) {

          ctargets[j]=(InstructionHandle)targetMap.get(itargets[j]);

        }

      }

    }

 else     if (i instanceof LocalVariableInstruction || i instanceof RET) {

      IndexedInstruction lvi=(IndexedInstruction)c;

      int oldLocalVarIndex=lvi.getIndex();

      LocalVariableGen oldLVG=getLocalVariableRegistry().lookupRegisteredLocalVariable(oldLocalVarIndex,ih.getPosition());

      LocalVariableGen newLVG=(LocalVariableGen)localVarMap.get(oldLVG);

      int newLocalVarIndex;

      if (newLVG == null) {

        String varName=oldLVG.getName();

        Type varType=oldLVG.getType();

        newLVG=outlinedMethodGen.addLocalVariable(varName,varType,null,null);

        newLocalVarIndex=newLVG.getIndex();

        localVarMap.put(oldLVG,newLVG);

        revisedLocalVarStart.put(oldLVG,outlinedMethodRef);

        revisedLocalVarEnd.put(oldLVG,outlinedMethodRef);

      }

 else {

        newLocalVarIndex=newLVG.getIndex();

      }

      lvi.setIndex(newLocalVarIndex);

    }

    if (ih.hasTargeters()) {

      InstructionTargeter[] targeters=ih.getTargeters();

      for (int idx=0; idx < targeters.length; idx++) {

        InstructionTargeter targeter=targeters[idx];

        if (targeter instanceof LocalVariableGen && ((LocalVariableGen)targeter).getEnd() == ih) {

          Object newLVG=localVarMap.get(targeter);

          if (newLVG != null) {

            outlinedMethodGen.removeLocalVariable((LocalVariableGen)newLVG);

          }

        }

      }

    }

    if (!(i instanceof MarkerInstruction)) {

      ch=ch.getNext();

    }

    ih=ih.getNext();

  }

  oldMethCopyOutIL.append(InstructionConstants.POP);

  Iterator revisedLocalVarStartPairIter=revisedLocalVarStart.entrySet().iterator();

  while (revisedLocalVarStartPairIter.hasNext()) {

    Map.Entry lvgRangeStartPair=(Map.Entry)revisedLocalVarStartPairIter.next();

    LocalVariableGen lvg=(LocalVariableGen)lvgRangeStartPair.getKey();

    InstructionHandle startInst=(InstructionHandle)lvgRangeStartPair.getValue();

    lvg.setStart(startInst);

  }

  Iterator revisedLocalVarEndPairIter=revisedLocalVarEnd.entrySet().iterator();

  while (revisedLocalVarEndPairIter.hasNext()) {

    Map.Entry lvgRangeEndPair=(Map.Entry)revisedLocalVarEndPairIter.next();

    LocalVariableGen lvg=(LocalVariableGen)lvgRangeEndPair.getKey();

    InstructionHandle endInst=(InstructionHandle)lvgRangeEndPair.getValue();

    lvg.setEnd(endInst);

  }

  xsltc.dumpClass(copyAreaCG.getJavaClass());

  InstructionList oldMethodIL=getInstructionList();

  oldMethodIL.insert(first,oldMethCopyInIL);

  oldMethodIL.insert(first,oldMethCopyOutIL);

  newIL.insert(newMethCopyInIL);

  newIL.append(newMethCopyOutIL);

  newIL.append(InstructionConstants.RETURN);

  try {

    oldMethodIL.delete(first,last);

  }

 catch (  TargetLostException e) {

    InstructionHandle[] targets=e.getTargets();

    for (int i=0; i < targets.length; i++) {

      InstructionHandle lostTarget=targets[i];

      InstructionTargeter[] targeters=lostTarget.getTargeters();

      for (int j=0; j < targeters.length; j++) {

        if (targeters[j] instanceof LocalVariableGen) {

          LocalVariableGen lvgTargeter=(LocalVariableGen)targeters[j];

          if (lvgTargeter.getStart() == lostTarget) {

            lvgTargeter.setStart(outlinedMethodRef);

          }

          if (lvgTargeter.getEnd() == lostTarget) {

            lvgTargeter.setEnd(outlinedMethodRef);

          }

        }

 else {

          targeters[j].updateTarget(lostTarget,outlinedMethodCallSetup);

        }

      }

    }

  }

  String[] exceptions=getExceptions();

  for (int i=0; i < exceptions.length; i++) {

    outlinedMethodGen.addException(exceptions[i]);

  }

  return outlinedMethodGen.getThisMethod();

}

Location: MethodGenerator.java

Content: 

public void removeLocalVariable(LocalVariableGen lvg){

  _slotAllocator.releaseSlot(lvg);

  getLocalVariableRegistry().removeByNameTracking(lvg);

  super.removeLocalVariable(lvg);

}

Location: MethodGenerator.java

Content: 

public void setMaxLocals(){

  int maxLocals=super.getMaxLocals();

  final LocalVariableGen[] localVars=super.getLocalVariables();

  if (localVars != null) {

    if (localVars.length > maxLocals)     maxLocals=localVars.length;

  }

  if (maxLocals < 5)   maxLocals=5;

  super.setMaxLocals(maxLocals);

}

Location: MethodGenerator.java

Content: 

public final Instruction setStartNode(){

  return _setStartNode;

}

Location: MethodGenerator.java

Content: 

public final Instruction startElement(){

  return _startElement;

}

Location: MethodGenerator.java

Content: 

public Instruction storeContextNode(){

  return storeCurrentNode();

}

Location: MethodGenerator.java

Content: 

public Instruction storeDOM(){

  return _astoreDom;

}

Location: MethodGenerator.java

Content: 

/** 

 * Helper method to generate an instance of a subclass of {@link StoreInstruction} based on the specified {@link Type} that will storea value in the specified local variable

 * @param index the JVM stack frame index of the variable that is to be stored

 * @param type  the {@link Type} of the variable

 * @return the generated {@link StoredInstruction}

 */

private static Instruction storeLocal(int index,Type type){

  if (type == Type.BOOLEAN) {

    return new ISTORE(index);

  }

 else   if (type == Type.INT) {

    return new ISTORE(index);

  }

 else   if (type == Type.SHORT) {

    return new ISTORE(index);

  }

 else   if (type == Type.LONG) {

    return new LSTORE(index);

  }

 else   if (type == Type.BYTE) {

    return new ISTORE(index);

  }

 else   if (type == Type.CHAR) {

    return new ISTORE(index);

  }

 else   if (type == Type.FLOAT) {

    return new FSTORE(index);

  }

 else   if (type == Type.DOUBLE) {

    return new DSTORE(index);

  }

 else {

    return new ASTORE(index);

  }

}

Location: MethodGenerator.java

Content: 

public final Instruction uniqueAttribute(){

  return _uniqueAttribute;

}

Location: MethodGenerator.java

Content: 

/** 

 * <p> Rewrites branches to avoid the JVM limits of relative branch offsets. There is no need to invoke this method if the bytecode for the {@link MethodGenerator} does not exceed 32KB.</p> <p> The Java Virtual Machine Specification permits the code portion of a method to be up to 64KB in length. However, some control transfer instructions specify relative offsets as a signed 16-bit quantity, limiting the range to a subset of the instructions that might be in a method. </p> <p> The <code>TABLESWITCH</code> and <code>LOOKUPSWITCH</code> instructions always use 32-bit signed relative offsets, so they are immune to this problem. </p> <p> The <code>GOTO</code> and <code>JSR</code> instructions come in two forms, one of which uses 16-bit relative offsets, and the other of which uses 32-bit relative offsets. The BCEL library decides whether to use the wide form of <code>GOTO</code> or <code>JSR</code>instructions based on the relative offset of the target of the instruction without any intervention by the user of the library. </p> <p> This leaves the various conditional branch instructions, <code>IFEQ</code>, <code>IFNULL</code>, <code>IF_ICMPEQ</code>, <em>et al.</em>, all of which use 16-bit signed relative offsets, with no 32-bit wide form available. </p> <p> This method scans the  {@link InstructionList} associated with this{@link MethodGenerator} and finds all conditional branch instructions thatmight exceed the 16-bit limitation for relative branch offsets. The logic of each such instruction is inverted, and made to target the instruction which follows it. An unconditional branch to the original target of the instruction is then inserted between the conditional branch and the instruction which previously followed it. The unconditional branch is permitted to have a 16-bit or a 32-bit relative offset, as described above. For example, <code> 1234:   NOP ... 55278:  IFEQ -54044 55280:  NOP </code> is rewritten as <code> 1234:   NOP ... 55278:  IFNE 7 55280:  GOTO_W -54046 55285:  NOP </code> </p> <p> <b>Preconditions:</b> <ul> <li>The  {@link InstructionList#setPositions()} has been called for the<code>InstructionList</code> associated with this <code>MethodGenerator</code>.</li> </ul> </p> <p> <b>Postconditions:</b> <ul> <li>Any further changes to the <code>InstructionList</code> for this <code>MethodGenerator</code> will invalidate the changes made by this method.</li> </ul> </p>

 * @return <code>true</code> if the <code>InstructionList</code> was modified;<code>false</code> otherwise

 * @see The Java Virtual Machine Specification, Second Edition

 */

boolean widenConditionalBranchTargetOffsets(){

  boolean ilChanged=false;

  int maxOffsetChange=0;

  InstructionList il=getInstructionList();

  for (InstructionHandle ih=il.getStart(); ih != null; ih=ih.getNext()) {

    Instruction inst=ih.getInstruction();

switch (inst.getOpcode()) {

case Constants.GOTO:

case Constants.JSR:

      maxOffsetChange=maxOffsetChange + 2;

    break;

case Constants.TABLESWITCH:

case Constants.LOOKUPSWITCH:

  maxOffsetChange=maxOffsetChange + 3;

break;

case Constants.IF_ACMPEQ:

case Constants.IF_ACMPNE:

case Constants.IF_ICMPEQ:

case Constants.IF_ICMPGE:

case Constants.IF_ICMPGT:

case Constants.IF_ICMPLE:

case Constants.IF_ICMPLT:

case Constants.IF_ICMPNE:

case Constants.IFEQ:

case Constants.IFGE:

case Constants.IFGT:

case Constants.IFLE:

case Constants.IFLT:

case Constants.IFNE:

case Constants.IFNONNULL:

case Constants.IFNULL:

maxOffsetChange=maxOffsetChange + 5;

break;

}

}

for (InstructionHandle ih=il.getStart(); ih != null; ih=ih.getNext()) {

Instruction inst=ih.getInstruction();

if (inst instanceof IfInstruction) {

IfInstruction oldIfInst=(IfInstruction)inst;

BranchHandle oldIfHandle=(BranchHandle)ih;

InstructionHandle target=oldIfInst.getTarget();

int relativeTargetOffset=target.getPosition() - oldIfHandle.getPosition();

if ((relativeTargetOffset - maxOffsetChange < MIN_BRANCH_TARGET_OFFSET) || (relativeTargetOffset + maxOffsetChange > MAX_BRANCH_TARGET_OFFSET)) {

InstructionHandle nextHandle=oldIfHandle.getNext();

IfInstruction invertedIfInst=oldIfInst.negate();

BranchHandle invertedIfHandle=il.append(oldIfHandle,invertedIfInst);

BranchHandle gotoHandle=il.append(invertedIfHandle,new GOTO(target));

if (nextHandle == null) {

nextHandle=il.append(gotoHandle,NOP);

}

invertedIfHandle.updateTarget(target,nextHandle);

if (oldIfHandle.hasTargeters()) {

InstructionTargeter[] targeters=oldIfHandle.getTargeters();

for (int i=0; i < targeters.length; i++) {

InstructionTargeter targeter=targeters[i];

if (targeter instanceof LocalVariableGen) {

  LocalVariableGen lvg=(LocalVariableGen)targeter;

  if (lvg.getStart() == oldIfHandle) {

    lvg.setStart(invertedIfHandle);

  }

 else   if (lvg.getEnd() == oldIfHandle) {

    lvg.setEnd(gotoHandle);

  }

}

 else {

  targeter.updateTarget(oldIfHandle,invertedIfHandle);

}

}

}

try {

il.delete(oldIfHandle);

}

 catch (TargetLostException tle) {

String msg=new ErrorMsg(ErrorMsg.OUTLINE_ERR_DELETED_TARGET,tle.getMessage()).toString();

throw new InternalError(msg);

}

ih=gotoHandle;

ilChanged=true;

}

}

}

return ilChanged;

}

