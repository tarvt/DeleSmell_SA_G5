Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator over an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @return an iterator over the array

 * @throws NullPointerException if array is null

 */

public static <E>ResettableIterator<E> arrayIterator(final E... array){

  return new ObjectArrayIterator<>(array);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator over the end part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @return an iterator over part of the array

 * @throws IndexOutOfBoundsException if start is less than zero or greaterthan the length of the array

 * @throws NullPointerException if array is null

 */

public static <E>ResettableIterator<E> arrayIterator(final E[] array,final int start){

  return new ObjectArrayIterator<>(array,start);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator over part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @param end  the index to finish iterating at

 * @return an iterator over part of the array

 * @throws IndexOutOfBoundsException if array bounds are invalid

 * @throws IllegalArgumentException if end is before start

 * @throws NullPointerException if array is null

 */

public static <E>ResettableIterator<E> arrayIterator(final E[] array,final int start,final int end){

  return new ObjectArrayIterator<>(array,start,end);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator over an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @return a list iterator over the array

 * @throws NullPointerException if array is null

 */

public static <E>ResettableListIterator<E> arrayListIterator(final E... array){

  return new ObjectArrayListIterator<>(array);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator over the end part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @return a list iterator over part of the array

 * @throws IndexOutOfBoundsException if start is less than zero

 * @throws NullPointerException if array is null

 */

public static <E>ResettableListIterator<E> arrayListIterator(final E[] array,final int start){

  return new ObjectArrayListIterator<>(array,start);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator over part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @param end  the index to finish iterating at

 * @return a list iterator over part of the array

 * @throws IndexOutOfBoundsException if array bounds are invalid

 * @throws IllegalArgumentException if end is before start

 * @throws NullPointerException if array is null

 */

public static <E>ResettableListIterator<E> arrayListIterator(final E[] array,final int start,final int end){

  return new ObjectArrayListIterator<>(array,start,end);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an enumeration that wraps an iterator.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new enumeration

 * @throws NullPointerException if iterator is null

 */

public static <E>Enumeration<E> asEnumeration(final Iterator<? extends E> iterator){

  return new IteratorEnumeration<>(Objects.requireNonNull(iterator,"iterator"));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an  {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can beused for a single iteration.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new, single use {@link Iterable}

 * @throws NullPointerException if iterator is null

 */

public static <E>Iterable<E> asIterable(final Iterator<? extends E> iterator){

  Objects.requireNonNull(iterator,"iterator");

  return new IteratorIterable<>(iterator,false);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an iterator view of the given enumeration.

 * @param < E > the element type

 * @param enumeration  the enumeration to use, may not be null

 * @return a new iterator

 * @throws NullPointerException if enumeration is null

 */

public static <E>Iterator<E> asIterator(final Enumeration<? extends E> enumeration){

  return new EnumerationIterator<>(Objects.requireNonNull(enumeration,"enumeration"));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an iterator view of the given enumeration that will remove elements from the specified collection.

 * @param < E > the element type

 * @param enumeration  the enumeration to use, may not be null

 * @param removeCollection  the collection to remove elements from, may not be null

 * @return a new iterator

 * @throws NullPointerException if enumeration or removeCollection is null

 */

public static <E>Iterator<E> asIterator(final Enumeration<? extends E> enumeration,final Collection<? super E> removeCollection){

  return new EnumerationIterator<>(Objects.requireNonNull(enumeration,"enumeration"),Objects.requireNonNull(removeCollection,"removeCollection"));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterable that wraps an iterator.  The returned iterable can be used for multiple iterations.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new, multiple use iterable

 * @throws NullPointerException if iterator is null

 */

public static <E>Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator){

  Objects.requireNonNull(iterator,"iterator");

  return new IteratorIterable<>(iterator,true);

}

Location: IteratorUtils.java

Content: 

/** 

 * Decorates the specified iterator to return at most the given number of elements.

 * @param < E > the element type

 * @param iterator  the iterator to decorate

 * @param max  the maximum number of elements returned by this iterator

 * @return a new bounded iterator

 * @throws NullPointerException if the iterator is null

 * @throws IllegalArgumentException if max is negative

 * @since 4.1

 */

public static <E>BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,final long max){

  return boundedIterator(iterator,0,max);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that iterates through a collections of  {@link Iterator}s one after another.

 * @param < E > the element type

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators collection is null or contains a null

 * @throws ClassCastException if the iterators collection contains the wrong object type

 */

public static <E>Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators){

  return new IteratorChain<>(iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that iterates through an array of  {@link Iterator}s one after another.

 * @param < E > the element type

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators array is null or contains a null

 */

public static <E>Iterator<E> chainedIterator(final Iterator<? extends E>... iterators){

  return new IteratorChain<>(iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that iterates through two  {@link Iterator}s one after another.

 * @param < E > the element type

 * @param iterator1  the first iterator to use, not null

 * @param iterator2  the second iterator to use, not null

 * @return a combination iterator over the iterators

 * @throws NullPointerException if either iterator is null

 */

public static <E>Iterator<E> chainedIterator(final Iterator<? extends E> iterator1,final Iterator<? extends E> iterator2){

  return new IteratorChain<>(iterator1,iterator2);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an ordered iteration over the elements contained in a collection of  {@link Iterator}s. <p> Given two ordered  {@link Iterator}s  {@code A} and {@code B}, the  {@link Iterator#next()} method will return the lesser of{@code A.next()} and {@code B.next()} and so on.<p> The comparator is optional. If null is specified then natural order is used.

 * @param < E > the element type

 * @param comparator  the comparator to use, may be null for natural order

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators collection is null or contains a null

 * @throws ClassCastException if the iterators collection contains the wrong object type

 */

public static <E>Iterator<E> collatedIterator(final Comparator<? super E> comparator,final Collection<Iterator<? extends E>> iterators){

  @SuppressWarnings("unchecked") final Comparator<E> comp=comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>)comparator;

  return new CollatingIterator<>(comp,iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an ordered iteration over the elements contained in an array of  {@link Iterator}s. <p> Given two ordered  {@link Iterator}s  {@code A} and {@code B}, the  {@link Iterator#next()} method will return the lesser of{@code A.next()} and {@code B.next()} and so on.<p> The comparator is optional. If null is specified then natural order is used.

 * @param < E > the element type

 * @param comparator  the comparator to use, may be null for natural order

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators array is null or contains a null value

 */

public static <E>Iterator<E> collatedIterator(final Comparator<? super E> comparator,final Iterator<? extends E>... iterators){

  @SuppressWarnings("unchecked") final Comparator<E> comp=comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>)comparator;

  return new CollatingIterator<>(comp,iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an ordered iteration over the elements contained in a collection of ordered  {@link Iterator}s. <p> Given two ordered  {@link Iterator}s  {@code A} and {@code B}, the  {@link Iterator#next()} method will return the lesser of{@code A.next()} and {@code B.next()}. <p> The comparator is optional. If null is specified then natural order is used.

 * @param < E > the element type

 * @param comparator  the comparator to use, may be null for natural order

 * @param iterator1  the first iterators to use, not null

 * @param iterator2  the first iterators to use, not null

 * @return a combination iterator over the iterators

 * @throws NullPointerException if either iterator is null

 */

public static <E>Iterator<E> collatedIterator(final Comparator<? super E> comparator,final Iterator<? extends E> iterator1,final Iterator<? extends E> iterator2){

  @SuppressWarnings("unchecked") final Comparator<E> comp=comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>)comparator;

  return new CollatingIterator<>(comp,iterator1,iterator2);

}

Location: IteratorUtils.java

Content: 

/** 

 * Checks if the object is contained in the given iterator. <p> A  {@code null} or empty iterator returns false.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the iterator to check, may be null

 * @param object  the object to check

 * @return true if the object is contained in the iterator, false otherwise

 * @since 4.1

 */

public static <E>boolean contains(final Iterator<E> iterator,final Object object){

  return matchesAny(iterator,EqualPredicate.equalPredicate(object));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that filters another iterator. <p> The returned iterator will only return objects that match the specified filtering predicate.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @param predicate  the predicate to use as a filter, not null

 * @return a new filtered iterator

 * @throws NullPointerException if either parameter is null

 */

public static <E>Iterator<E> filteredIterator(final Iterator<? extends E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(iterator,"iterator");

  Objects.requireNonNull(predicate,"predicate");

  return new FilterIterator<>(iterator,predicate);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator that filters another list iterator. <p> The returned iterator will only return objects that match the specified filtering predicate.

 * @param < E > the element type

 * @param listIterator  the list iterator to use, not null

 * @param predicate  the predicate to use as a filter, not null

 * @return a new filtered iterator

 * @throws NullPointerException if either parameter is null

 */

public static <E>ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(listIterator,"listIterator");

  Objects.requireNonNull(predicate,"predicate");

  return new FilterListIterator<>(listIterator,predicate);

}

Location: IteratorUtils.java

Content: 

/** 

 * Finds the first element in the given iterator which matches the given predicate. <p> A  {@code null} or empty iterator returns null.

 * @param < E > the element type

 * @param iterator  the iterator to search, may be null

 * @param predicate  the predicate to use, must not be null

 * @return the first element of the iterator which matches the predicate or null if none could be found

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>E find(final Iterator<E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(predicate,"predicate");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      if (predicate.evaluate(element)) {

        return element;

      }

    }

  }

  return null;

}

Location: IteratorUtils.java

Content: 

/** 

 * Shortcut for  {@code get(iterator, 0)}. <p> Returns the  {@code first} value in {@link Iterator}, throwing {@code IndexOutOfBoundsException} if there is no such element.</p> <p> The Iterator is advanced to  {@code 0} (or to the end, if{@code 0} exceeds the number of entries) as a side effect of this method.</p>

 * @param < E > the type of object in the {@link Iterator}

 * @param iterator the iterator to get a value from

 * @return the first object

 * @throws IndexOutOfBoundsException if the request is invalid

 * @since 4.2

 */

public static <E>E first(final Iterator<E> iterator){

  return get(iterator,0);

}

Location: IteratorUtils.java

Content: 

/** 

 * Executes the given closure on each but the last element in the iterator. <p> If the input iterator is null no change is made.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the iterator to get the input from, may be null

 * @param closure  the closure to perform, may not be null

 * @return the last element in the iterator, or null if iterator is null or empty

 * @throws NullPointerException if closure is null

 * @since 4.1

 */

public static <E>E forEachButLast(final Iterator<E> iterator,final Closure<? super E> closure){

  Objects.requireNonNull(closure,"closure");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      if (!iterator.hasNext()) {

        return element;

      }

      closure.execute(element);

    }

  }

  return null;

}

Location: IteratorUtils.java

Content: 

/** 

 * Applies the closure to each element of the provided iterator.

 * @param < E > the element type

 * @param iterator  the iterator to use, may be null

 * @param closure  the closure to apply to each element, may not be null

 * @throws NullPointerException if closure is null

 * @since 4.1

 */

public static <E>void forEach(final Iterator<E> iterator,final Closure<? super E> closure){

  Objects.requireNonNull(closure,"closure");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      closure.execute(element);

    }

  }

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a suitable Iterator for the given object. <p> This method can handle objects as follows <ul> <li>null - empty iterator <li>Iterator - returned directly <li>Enumeration - wrapped <li>Collection - iterator from collection returned <li>Map - values iterator returned <li>Dictionary - values (elements) enumeration returned as iterator <li>array - iterator over array returned <li>object with iterator() public method accessed by reflection <li>object - singleton iterator <li>NodeList - iterator over the list <li>Node - iterator over the child nodes </ul>

 * @param obj  the object to convert to an iterator

 * @return a suitable iterator, never null

 */

public static Iterator<?> getIterator(final Object obj){

  if (obj == null) {

    return emptyIterator();

  }

  if (obj instanceof Iterator) {

    return (Iterator<?>)obj;

  }

  if (obj instanceof Iterable) {

    return ((Iterable<?>)obj).iterator();

  }

  if (obj instanceof Object[]) {

    return new ObjectArrayIterator<>((Object[])obj);

  }

  if (obj instanceof Enumeration) {

    return new EnumerationIterator<>((Enumeration<?>)obj);

  }

  if (obj instanceof Map) {

    return ((Map<?,?>)obj).values().iterator();

  }

  if (obj instanceof NodeList) {

    return new NodeListIterator((NodeList)obj);

  }

  if (obj instanceof Node) {

    return new NodeListIterator((Node)obj);

  }

  if (obj instanceof Dictionary) {

    return new EnumerationIterator<>(((Dictionary<?,?>)obj).elements());

  }

  if (obj.getClass().isArray()) {

    return new ArrayIterator<>(obj);

  }

  try {

    final Method method=obj.getClass().getMethod("iterator",(Class[])null);

    if (Iterator.class.isAssignableFrom(method.getReturnType())) {

      final Iterator<?> it=(Iterator<?>)method.invoke(obj,(Object[])null);

      if (it != null) {

        return it;

      }

    }

  }

 catch (  final RuntimeException|NoSuchMethodException|IllegalAccessException|InvocationTargetException e) {

  }

  return singletonIterator(obj);

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns the index of the first element in the specified iterator that matches the given predicate. <p> A  {@code null} or empty iterator returns -1.

 * @param < E > the element type

 * @param iterator  the iterator to search, may be null

 * @param predicate  the predicate to use, may not be null

 * @return the index of the first element which matches the predicate or -1 if none matches

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>int indexOf(final Iterator<E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(predicate,"predicate");

  if (iterator != null) {

    for (int index=0; iterator.hasNext(); index++) {

      final E element=iterator.next();

      if (predicate.evaluate(element)) {

        return index;

      }

    }

  }

  return CollectionUtils.INDEX_NOT_FOUND;

}

Location: IteratorUtils.java

Content: 

/** 

 * Checks if the given iterator is empty. <p> A  {@code null} or empty iterator returns true.

 * @param iterator  the {@link Iterator} to use, may be null

 * @return true if the iterator is exhausted or null, false otherwise

 * @since 4.1

 */

public static boolean isEmpty(final Iterator<?> iterator){

  return iterator == null || !iterator.hasNext();

}

Location: IteratorUtils.java

Content: 

/** 

 * Don't allow instances.

 */

private IteratorUtils(){

}

Location: IteratorUtils.java

Content: 

/** 

 * Answers true if a predicate is true for every element of an iterator. <p> A  {@code null} or empty iterator returns true.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the {@link Iterator} to use, may be null

 * @param predicate  the predicate to use, may not be null

 * @return true if every element of the collection matches the predicate or if thecollection is empty, false otherwise

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>boolean matchesAll(final Iterator<E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(predicate,"predicate");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      if (!predicate.evaluate(element)) {

        return false;

      }

    }

  }

  return true;

}

Location: IteratorUtils.java

Content: 

/** 

 * Answers true if a predicate is true for any element of the iterator. <p> A  {@code null} or empty iterator returns false.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the {@link Iterator} to use, may be null

 * @param predicate  the predicate to use, may not be null

 * @return true if any element of the collection matches the predicate, false otherwise

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>boolean matchesAny(final Iterator<E> iterator,final Predicate<? super E> predicate){

  return indexOf(iterator,predicate) != -1;

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns the number of elements contained in the given iterator. <p> A  {@code null} or empty iterator returns {@code 0}.

 * @param iterator  the iterator to check, may be null

 * @return the number of elements contained in the iterator

 * @since 4.1

 */

public static int size(final Iterator<?> iterator){

  int size=0;

  if (iterator != null) {

    while (iterator.hasNext()) {

      iterator.next();

      size++;

    }

  }

  return size;

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an array based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, this is converted to an array.

 * @param iterator  the iterator to use, not null

 * @return an array of the iterator contents

 * @throws NullPointerException if iterator parameter is null

 */

public static Object[] toArray(final Iterator<?> iterator){

  Objects.requireNonNull(iterator,"iterator");

  final List<?> list=toList(iterator,100);

  return list.toArray();

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an array based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, this is converted to an array.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @param arrayClass  the class of array to create

 * @return an array of the iterator contents

 * @throws NullPointerException if iterator parameter or arrayClass is null

 * @throws ArrayStoreException if the arrayClass is invalid

 */

public static <E>E[] toArray(final Iterator<? extends E> iterator,final Class<E> arrayClass){

  Objects.requireNonNull(iterator,"iterator");

  Objects.requireNonNull(arrayClass,"arrayClass");

  final List<E> list=toList(iterator,100);

  @SuppressWarnings("unchecked") final E[] array=(E[])Array.newInstance(arrayClass,list.size());

  return list.toArray(array);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator based on a simple iterator. <p> As the wrapped Iterator is traversed, a LinkedList of its values is cached, permitting all required operations of ListIterator.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new iterator

 * @throws NullPointerException if iterator parameter is null

 */

public static <E>ListIterator<E> toListIterator(final Iterator<? extends E> iterator){

  Objects.requireNonNull(iterator,"iterator");

  return new ListIteratorWrapper<>(iterator);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, the list is returned.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @return a list of the iterator contents

 * @throws NullPointerException if iterator parameter is null

 */

public static <E>List<E> toList(final Iterator<? extends E> iterator){

  return toList(iterator,10);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, the list is returned.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @param estimatedSize  the initial size of the ArrayList

 * @return a list of the iterator contents

 * @throws NullPointerException if iterator parameter is null

 * @throws IllegalArgumentException if the size is less than 1

 */

public static <E>List<E> toList(final Iterator<? extends E> iterator,final int estimatedSize){

  Objects.requireNonNull(iterator,"iterator");

  if (estimatedSize < 1) {

    throw new IllegalArgumentException("Estimated size must be greater than 0");

  }

  final List<E> list=new ArrayList<>(estimatedSize);

  while (iterator.hasNext()) {

    list.add(iterator.next());

  }

  return list;

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns a string representation of the elements of the specified iterator. <p> The string representation consists of a list of the iterator's elements, enclosed in square brackets ( {@code "[]"}). Adjacent elements are separated by the characters  {@code ", "} (a comma followed by a space). Elements areconverted to strings as by  {@code String.valueOf(Object)}.

 * @param < E > the element type

 * @param iterator  the iterator to convert to a string, may be null

 * @return a string representation of {@code iterator}

 * @since 4.1

 */

public static <E>String toString(final Iterator<E> iterator){

  return toString(iterator,TransformerUtils.stringValueTransformer(),DEFAULT_TOSTRING_DELIMITER,CollectionUtils.DEFAULT_TOSTRING_PREFIX,CollectionUtils.DEFAULT_TOSTRING_SUFFIX);

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns a string representation of the elements of the specified iterator. <p> The string representation consists of a list of the iterable's elements, enclosed in square brackets ( {@code "[]"}). Adjacent elements are separated by the characters  {@code ", "} (a comma followed by a space). Elements areconverted to strings as by using the provided  {@code transformer}.

 * @param < E > the element type

 * @param iterator  the iterator to convert to a string, may be null

 * @param transformer  the transformer used to get a string representation of an element

 * @return a string representation of {@code iterator}

 * @throws NullPointerException if {@code transformer} is null

 * @since 4.1

 */

public static <E>String toString(final Iterator<E> iterator,final Transformer<? super E,String> transformer){

  return toString(iterator,transformer,DEFAULT_TOSTRING_DELIMITER,CollectionUtils.DEFAULT_TOSTRING_PREFIX,CollectionUtils.DEFAULT_TOSTRING_SUFFIX);

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns a string representation of the elements of the specified iterator. <p> The string representation consists of a list of the iterator's elements, enclosed by the provided  {@code prefix} and {@code suffix}. Adjacent elements are separated by the provided  {@code delimiter}. Elements are converted to strings as by using the provided  {@code transformer}.

 * @param < E > the element type

 * @param iterator  the iterator to convert to a string, may be null

 * @param transformer  the transformer used to get a string representation of an element

 * @param delimiter  the string to delimit elements

 * @param prefix  the prefix, prepended to the string representation

 * @param suffix  the suffix, appended to the string representation

 * @return a string representation of {@code iterator}

 * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null

 * @since 4.1

 */

public static <E>String toString(final Iterator<E> iterator,final Transformer<? super E,String> transformer,final String delimiter,final String prefix,final String suffix){

  Objects.requireNonNull(transformer,"transformer");

  Objects.requireNonNull(delimiter,"delimiter");

  Objects.requireNonNull(prefix,"prefix");

  Objects.requireNonNull(suffix,"suffix");

  final StringBuilder stringBuilder=new StringBuilder(prefix);

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      stringBuilder.append(transformer.transform(element));

      stringBuilder.append(delimiter);

    }

    if (stringBuilder.length() > prefix.length()) {

      stringBuilder.setLength(stringBuilder.length() - delimiter.length());

    }

  }

  stringBuilder.append(suffix);

  return stringBuilder.toString();

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that transforms the elements of another iterator. <p> The transformation occurs during the next() method and the underlying iterator is unaffected by the transformation.

 * @param < I > the input type

 * @param < O > the output type

 * @param iterator  the iterator to use, not null

 * @param transformer  the transform to use, not null

 * @return a new transforming iterator

 * @throws NullPointerException if either parameter is null

 */

public static <I,O>Iterator<O> transformedIterator(final Iterator<? extends I> iterator,final Transformer<? super I,? extends O> transformer){

  Objects.requireNonNull(iterator,"iterator");

  Objects.requireNonNull(transformer,"transformer");

  return new TransformIterator<>(iterator,transformer);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator over an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @return an iterator over the array

 * @throws NullPointerException if array is null

 */

public static <E>ResettableIterator<E> arrayIterator(final E... array){

  return new ObjectArrayIterator<>(array);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator over the end part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @return an iterator over part of the array

 * @throws IndexOutOfBoundsException if start is less than zero or greaterthan the length of the array

 * @throws NullPointerException if array is null

 */

public static <E>ResettableIterator<E> arrayIterator(final E[] array,final int start){

  return new ObjectArrayIterator<>(array,start);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator over part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @param end  the index to finish iterating at

 * @return an iterator over part of the array

 * @throws IndexOutOfBoundsException if array bounds are invalid

 * @throws IllegalArgumentException if end is before start

 * @throws NullPointerException if array is null

 */

public static <E>ResettableIterator<E> arrayIterator(final E[] array,final int start,final int end){

  return new ObjectArrayIterator<>(array,start,end);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator over an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @return a list iterator over the array

 * @throws NullPointerException if array is null

 */

public static <E>ResettableListIterator<E> arrayListIterator(final E... array){

  return new ObjectArrayListIterator<>(array);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator over the end part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @return a list iterator over part of the array

 * @throws IndexOutOfBoundsException if start is less than zero

 * @throws NullPointerException if array is null

 */

public static <E>ResettableListIterator<E> arrayListIterator(final E[] array,final int start){

  return new ObjectArrayListIterator<>(array,start);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator over part of an object array.

 * @param < E > the element type

 * @param array  the array over which to iterate

 * @param start  the index to start iterating at

 * @param end  the index to finish iterating at

 * @return a list iterator over part of the array

 * @throws IndexOutOfBoundsException if array bounds are invalid

 * @throws IllegalArgumentException if end is before start

 * @throws NullPointerException if array is null

 */

public static <E>ResettableListIterator<E> arrayListIterator(final E[] array,final int start,final int end){

  return new ObjectArrayListIterator<>(array,start,end);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an enumeration that wraps an iterator.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new enumeration

 * @throws NullPointerException if iterator is null

 */

public static <E>Enumeration<E> asEnumeration(final Iterator<? extends E> iterator){

  return new IteratorEnumeration<>(Objects.requireNonNull(iterator,"iterator"));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an  {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can beused for a single iteration.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new, single use {@link Iterable}

 * @throws NullPointerException if iterator is null

 */

public static <E>Iterable<E> asIterable(final Iterator<? extends E> iterator){

  Objects.requireNonNull(iterator,"iterator");

  return new IteratorIterable<>(iterator,false);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an iterator view of the given enumeration.

 * @param < E > the element type

 * @param enumeration  the enumeration to use, may not be null

 * @return a new iterator

 * @throws NullPointerException if enumeration is null

 */

public static <E>Iterator<E> asIterator(final Enumeration<? extends E> enumeration){

  return new EnumerationIterator<>(Objects.requireNonNull(enumeration,"enumeration"));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an iterator view of the given enumeration that will remove elements from the specified collection.

 * @param < E > the element type

 * @param enumeration  the enumeration to use, may not be null

 * @param removeCollection  the collection to remove elements from, may not be null

 * @return a new iterator

 * @throws NullPointerException if enumeration or removeCollection is null

 */

public static <E>Iterator<E> asIterator(final Enumeration<? extends E> enumeration,final Collection<? super E> removeCollection){

  return new EnumerationIterator<>(Objects.requireNonNull(enumeration,"enumeration"),Objects.requireNonNull(removeCollection,"removeCollection"));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterable that wraps an iterator.  The returned iterable can be used for multiple iterations.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new, multiple use iterable

 * @throws NullPointerException if iterator is null

 */

public static <E>Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator){

  Objects.requireNonNull(iterator,"iterator");

  return new IteratorIterable<>(iterator,true);

}

Location: IteratorUtils.java

Content: 

/** 

 * Decorates the specified iterator to return at most the given number of elements.

 * @param < E > the element type

 * @param iterator  the iterator to decorate

 * @param max  the maximum number of elements returned by this iterator

 * @return a new bounded iterator

 * @throws NullPointerException if the iterator is null

 * @throws IllegalArgumentException if max is negative

 * @since 4.1

 */

public static <E>BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,final long max){

  return boundedIterator(iterator,0,max);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that iterates through a collections of  {@link Iterator}s one after another.

 * @param < E > the element type

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators collection is null or contains a null

 * @throws ClassCastException if the iterators collection contains the wrong object type

 */

public static <E>Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators){

  return new IteratorChain<>(iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that iterates through an array of  {@link Iterator}s one after another.

 * @param < E > the element type

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators array is null or contains a null

 */

public static <E>Iterator<E> chainedIterator(final Iterator<? extends E>... iterators){

  return new IteratorChain<>(iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that iterates through two  {@link Iterator}s one after another.

 * @param < E > the element type

 * @param iterator1  the first iterator to use, not null

 * @param iterator2  the second iterator to use, not null

 * @return a combination iterator over the iterators

 * @throws NullPointerException if either iterator is null

 */

public static <E>Iterator<E> chainedIterator(final Iterator<? extends E> iterator1,final Iterator<? extends E> iterator2){

  return new IteratorChain<>(iterator1,iterator2);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an ordered iteration over the elements contained in a collection of  {@link Iterator}s. <p> Given two ordered  {@link Iterator}s  {@code A} and {@code B}, the  {@link Iterator#next()} method will return the lesser of{@code A.next()} and {@code B.next()} and so on.<p> The comparator is optional. If null is specified then natural order is used.

 * @param < E > the element type

 * @param comparator  the comparator to use, may be null for natural order

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators collection is null or contains a null

 * @throws ClassCastException if the iterators collection contains the wrong object type

 */

public static <E>Iterator<E> collatedIterator(final Comparator<? super E> comparator,final Collection<Iterator<? extends E>> iterators){

  @SuppressWarnings("unchecked") final Comparator<E> comp=comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>)comparator;

  return new CollatingIterator<>(comp,iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an ordered iteration over the elements contained in an array of  {@link Iterator}s. <p> Given two ordered  {@link Iterator}s  {@code A} and {@code B}, the  {@link Iterator#next()} method will return the lesser of{@code A.next()} and {@code B.next()} and so on.<p> The comparator is optional. If null is specified then natural order is used.

 * @param < E > the element type

 * @param comparator  the comparator to use, may be null for natural order

 * @param iterators  the iterators to use, not null or empty or contain nulls

 * @return a combination iterator over the iterators

 * @throws NullPointerException if iterators array is null or contains a null value

 */

public static <E>Iterator<E> collatedIterator(final Comparator<? super E> comparator,final Iterator<? extends E>... iterators){

  @SuppressWarnings("unchecked") final Comparator<E> comp=comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>)comparator;

  return new CollatingIterator<>(comp,iterators);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that provides an ordered iteration over the elements contained in a collection of ordered  {@link Iterator}s. <p> Given two ordered  {@link Iterator}s  {@code A} and {@code B}, the  {@link Iterator#next()} method will return the lesser of{@code A.next()} and {@code B.next()}. <p> The comparator is optional. If null is specified then natural order is used.

 * @param < E > the element type

 * @param comparator  the comparator to use, may be null for natural order

 * @param iterator1  the first iterators to use, not null

 * @param iterator2  the first iterators to use, not null

 * @return a combination iterator over the iterators

 * @throws NullPointerException if either iterator is null

 */

public static <E>Iterator<E> collatedIterator(final Comparator<? super E> comparator,final Iterator<? extends E> iterator1,final Iterator<? extends E> iterator2){

  @SuppressWarnings("unchecked") final Comparator<E> comp=comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>)comparator;

  return new CollatingIterator<>(comp,iterator1,iterator2);

}

Location: IteratorUtils.java

Content: 

/** 

 * Checks if the object is contained in the given iterator. <p> A  {@code null} or empty iterator returns false.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the iterator to check, may be null

 * @param object  the object to check

 * @return true if the object is contained in the iterator, false otherwise

 * @since 4.1

 */

public static <E>boolean contains(final Iterator<E> iterator,final Object object){

  return matchesAny(iterator,EqualPredicate.equalPredicate(object));

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that filters another iterator. <p> The returned iterator will only return objects that match the specified filtering predicate.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @param predicate  the predicate to use as a filter, not null

 * @return a new filtered iterator

 * @throws NullPointerException if either parameter is null

 */

public static <E>Iterator<E> filteredIterator(final Iterator<? extends E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(iterator,"iterator");

  Objects.requireNonNull(predicate,"predicate");

  return new FilterIterator<>(iterator,predicate);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator that filters another list iterator. <p> The returned iterator will only return objects that match the specified filtering predicate.

 * @param < E > the element type

 * @param listIterator  the list iterator to use, not null

 * @param predicate  the predicate to use as a filter, not null

 * @return a new filtered iterator

 * @throws NullPointerException if either parameter is null

 */

public static <E>ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(listIterator,"listIterator");

  Objects.requireNonNull(predicate,"predicate");

  return new FilterListIterator<>(listIterator,predicate);

}

Location: IteratorUtils.java

Content: 

/** 

 * Finds the first element in the given iterator which matches the given predicate. <p> A  {@code null} or empty iterator returns null.

 * @param < E > the element type

 * @param iterator  the iterator to search, may be null

 * @param predicate  the predicate to use, must not be null

 * @return the first element of the iterator which matches the predicate or null if none could be found

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>E find(final Iterator<E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(predicate,"predicate");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      if (predicate.evaluate(element)) {

        return element;

      }

    }

  }

  return null;

}

Location: IteratorUtils.java

Content: 

/** 

 * Shortcut for  {@code get(iterator, 0)}. <p> Returns the  {@code first} value in {@link Iterator}, throwing {@code IndexOutOfBoundsException} if there is no such element.</p> <p> The Iterator is advanced to  {@code 0} (or to the end, if{@code 0} exceeds the number of entries) as a side effect of this method.</p>

 * @param < E > the type of object in the {@link Iterator}

 * @param iterator the iterator to get a value from

 * @return the first object

 * @throws IndexOutOfBoundsException if the request is invalid

 * @since 4.2

 */

public static <E>E first(final Iterator<E> iterator){

  return get(iterator,0);

}

Location: IteratorUtils.java

Content: 

/** 

 * Executes the given closure on each but the last element in the iterator. <p> If the input iterator is null no change is made.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the iterator to get the input from, may be null

 * @param closure  the closure to perform, may not be null

 * @return the last element in the iterator, or null if iterator is null or empty

 * @throws NullPointerException if closure is null

 * @since 4.1

 */

public static <E>E forEachButLast(final Iterator<E> iterator,final Closure<? super E> closure){

  Objects.requireNonNull(closure,"closure");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      if (!iterator.hasNext()) {

        return element;

      }

      closure.execute(element);

    }

  }

  return null;

}

Location: IteratorUtils.java

Content: 

/** 

 * Applies the closure to each element of the provided iterator.

 * @param < E > the element type

 * @param iterator  the iterator to use, may be null

 * @param closure  the closure to apply to each element, may not be null

 * @throws NullPointerException if closure is null

 * @since 4.1

 */

public static <E>void forEach(final Iterator<E> iterator,final Closure<? super E> closure){

  Objects.requireNonNull(closure,"closure");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      closure.execute(element);

    }

  }

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a suitable Iterator for the given object. <p> This method can handle objects as follows <ul> <li>null - empty iterator <li>Iterator - returned directly <li>Enumeration - wrapped <li>Collection - iterator from collection returned <li>Map - values iterator returned <li>Dictionary - values (elements) enumeration returned as iterator <li>array - iterator over array returned <li>object with iterator() public method accessed by reflection <li>object - singleton iterator <li>NodeList - iterator over the list <li>Node - iterator over the child nodes </ul>

 * @param obj  the object to convert to an iterator

 * @return a suitable iterator, never null

 */

public static Iterator<?> getIterator(final Object obj){

  if (obj == null) {

    return emptyIterator();

  }

  if (obj instanceof Iterator) {

    return (Iterator<?>)obj;

  }

  if (obj instanceof Iterable) {

    return ((Iterable<?>)obj).iterator();

  }

  if (obj instanceof Object[]) {

    return new ObjectArrayIterator<>((Object[])obj);

  }

  if (obj instanceof Enumeration) {

    return new EnumerationIterator<>((Enumeration<?>)obj);

  }

  if (obj instanceof Map) {

    return ((Map<?,?>)obj).values().iterator();

  }

  if (obj instanceof NodeList) {

    return new NodeListIterator((NodeList)obj);

  }

  if (obj instanceof Node) {

    return new NodeListIterator((Node)obj);

  }

  if (obj instanceof Dictionary) {

    return new EnumerationIterator<>(((Dictionary<?,?>)obj).elements());

  }

  if (obj.getClass().isArray()) {

    return new ArrayIterator<>(obj);

  }

  try {

    final Method method=obj.getClass().getMethod("iterator",(Class[])null);

    if (Iterator.class.isAssignableFrom(method.getReturnType())) {

      final Iterator<?> it=(Iterator<?>)method.invoke(obj,(Object[])null);

      if (it != null) {

        return it;

      }

    }

  }

 catch (  final RuntimeException|NoSuchMethodException|IllegalAccessException|InvocationTargetException e) {

  }

  return singletonIterator(obj);

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns the index of the first element in the specified iterator that matches the given predicate. <p> A  {@code null} or empty iterator returns -1.

 * @param < E > the element type

 * @param iterator  the iterator to search, may be null

 * @param predicate  the predicate to use, may not be null

 * @return the index of the first element which matches the predicate or -1 if none matches

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>int indexOf(final Iterator<E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(predicate,"predicate");

  if (iterator != null) {

    for (int index=0; iterator.hasNext(); index++) {

      final E element=iterator.next();

      if (predicate.evaluate(element)) {

        return index;

      }

    }

  }

  return CollectionUtils.INDEX_NOT_FOUND;

}

Location: IteratorUtils.java

Content: 

/** 

 * Checks if the given iterator is empty. <p> A  {@code null} or empty iterator returns true.

 * @param iterator  the {@link Iterator} to use, may be null

 * @return true if the iterator is exhausted or null, false otherwise

 * @since 4.1

 */

public static boolean isEmpty(final Iterator<?> iterator){

  return iterator == null || !iterator.hasNext();

}

Location: IteratorUtils.java

Content: 

/** 

 * Don't allow instances.

 */

private IteratorUtils(){

}

Location: IteratorUtils.java

Content: 

/** 

 * Answers true if a predicate is true for every element of an iterator. <p> A  {@code null} or empty iterator returns true.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the {@link Iterator} to use, may be null

 * @param predicate  the predicate to use, may not be null

 * @return true if every element of the collection matches the predicate or if thecollection is empty, false otherwise

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>boolean matchesAll(final Iterator<E> iterator,final Predicate<? super E> predicate){

  Objects.requireNonNull(predicate,"predicate");

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      if (!predicate.evaluate(element)) {

        return false;

      }

    }

  }

  return true;

}

Location: IteratorUtils.java

Content: 

/** 

 * Answers true if a predicate is true for any element of the iterator. <p> A  {@code null} or empty iterator returns false.

 * @param < E > the type of object the {@link Iterator} contains

 * @param iterator  the {@link Iterator} to use, may be null

 * @param predicate  the predicate to use, may not be null

 * @return true if any element of the collection matches the predicate, false otherwise

 * @throws NullPointerException if predicate is null

 * @since 4.1

 */

public static <E>boolean matchesAny(final Iterator<E> iterator,final Predicate<? super E> predicate){

  return indexOf(iterator,predicate) != -1;

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns the number of elements contained in the given iterator. <p> A  {@code null} or empty iterator returns {@code 0}.

 * @param iterator  the iterator to check, may be null

 * @return the number of elements contained in the iterator

 * @since 4.1

 */

public static int size(final Iterator<?> iterator){

  int size=0;

  if (iterator != null) {

    while (iterator.hasNext()) {

      iterator.next();

      size++;

    }

  }

  return size;

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an array based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, this is converted to an array.

 * @param iterator  the iterator to use, not null

 * @return an array of the iterator contents

 * @throws NullPointerException if iterator parameter is null

 */

public static Object[] toArray(final Iterator<?> iterator){

  Objects.requireNonNull(iterator,"iterator");

  final List<?> list=toList(iterator,100);

  return list.toArray();

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an array based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, this is converted to an array.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @param arrayClass  the class of array to create

 * @return an array of the iterator contents

 * @throws NullPointerException if iterator parameter or arrayClass is null

 * @throws ArrayStoreException if the arrayClass is invalid

 */

public static <E>E[] toArray(final Iterator<? extends E> iterator,final Class<E> arrayClass){

  Objects.requireNonNull(iterator,"iterator");

  Objects.requireNonNull(arrayClass,"arrayClass");

  final List<E> list=toList(iterator,100);

  @SuppressWarnings("unchecked") final E[] array=(E[])Array.newInstance(arrayClass,list.size());

  return list.toArray(array);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list iterator based on a simple iterator. <p> As the wrapped Iterator is traversed, a LinkedList of its values is cached, permitting all required operations of ListIterator.

 * @param < E > the element type

 * @param iterator  the iterator to use, may not be null

 * @return a new iterator

 * @throws NullPointerException if iterator parameter is null

 */

public static <E>ListIterator<E> toListIterator(final Iterator<? extends E> iterator){

  Objects.requireNonNull(iterator,"iterator");

  return new ListIteratorWrapper<>(iterator);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, the list is returned.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @return a list of the iterator contents

 * @throws NullPointerException if iterator parameter is null

 */

public static <E>List<E> toList(final Iterator<? extends E> iterator){

  return toList(iterator,10);

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets a list based on an iterator. <p> As the wrapped Iterator is traversed, an ArrayList of its values is created. At the end, the list is returned.

 * @param < E > the element type

 * @param iterator  the iterator to use, not null

 * @param estimatedSize  the initial size of the ArrayList

 * @return a list of the iterator contents

 * @throws NullPointerException if iterator parameter is null

 * @throws IllegalArgumentException if the size is less than 1

 */

public static <E>List<E> toList(final Iterator<? extends E> iterator,final int estimatedSize){

  Objects.requireNonNull(iterator,"iterator");

  if (estimatedSize < 1) {

    throw new IllegalArgumentException("Estimated size must be greater than 0");

  }

  final List<E> list=new ArrayList<>(estimatedSize);

  while (iterator.hasNext()) {

    list.add(iterator.next());

  }

  return list;

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns a string representation of the elements of the specified iterator. <p> The string representation consists of a list of the iterator's elements, enclosed in square brackets ( {@code "[]"}). Adjacent elements are separated by the characters  {@code ", "} (a comma followed by a space). Elements areconverted to strings as by  {@code String.valueOf(Object)}.

 * @param < E > the element type

 * @param iterator  the iterator to convert to a string, may be null

 * @return a string representation of {@code iterator}

 * @since 4.1

 */

public static <E>String toString(final Iterator<E> iterator){

  return toString(iterator,TransformerUtils.stringValueTransformer(),DEFAULT_TOSTRING_DELIMITER,CollectionUtils.DEFAULT_TOSTRING_PREFIX,CollectionUtils.DEFAULT_TOSTRING_SUFFIX);

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns a string representation of the elements of the specified iterator. <p> The string representation consists of a list of the iterable's elements, enclosed in square brackets ( {@code "[]"}). Adjacent elements are separated by the characters  {@code ", "} (a comma followed by a space). Elements areconverted to strings as by using the provided  {@code transformer}.

 * @param < E > the element type

 * @param iterator  the iterator to convert to a string, may be null

 * @param transformer  the transformer used to get a string representation of an element

 * @return a string representation of {@code iterator}

 * @throws NullPointerException if {@code transformer} is null

 * @since 4.1

 */

public static <E>String toString(final Iterator<E> iterator,final Transformer<? super E,String> transformer){

  return toString(iterator,transformer,DEFAULT_TOSTRING_DELIMITER,CollectionUtils.DEFAULT_TOSTRING_PREFIX,CollectionUtils.DEFAULT_TOSTRING_SUFFIX);

}

Location: IteratorUtils.java

Content: 

/** 

 * Returns a string representation of the elements of the specified iterator. <p> The string representation consists of a list of the iterator's elements, enclosed by the provided  {@code prefix} and {@code suffix}. Adjacent elements are separated by the provided  {@code delimiter}. Elements are converted to strings as by using the provided  {@code transformer}.

 * @param < E > the element type

 * @param iterator  the iterator to convert to a string, may be null

 * @param transformer  the transformer used to get a string representation of an element

 * @param delimiter  the string to delimit elements

 * @param prefix  the prefix, prepended to the string representation

 * @param suffix  the suffix, appended to the string representation

 * @return a string representation of {@code iterator}

 * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null

 * @since 4.1

 */

public static <E>String toString(final Iterator<E> iterator,final Transformer<? super E,String> transformer,final String delimiter,final String prefix,final String suffix){

  Objects.requireNonNull(transformer,"transformer");

  Objects.requireNonNull(delimiter,"delimiter");

  Objects.requireNonNull(prefix,"prefix");

  Objects.requireNonNull(suffix,"suffix");

  final StringBuilder stringBuilder=new StringBuilder(prefix);

  if (iterator != null) {

    while (iterator.hasNext()) {

      final E element=iterator.next();

      stringBuilder.append(transformer.transform(element));

      stringBuilder.append(delimiter);

    }

    if (stringBuilder.length() > prefix.length()) {

      stringBuilder.setLength(stringBuilder.length() - delimiter.length());

    }

  }

  stringBuilder.append(suffix);

  return stringBuilder.toString();

}

Location: IteratorUtils.java

Content: 

/** 

 * Gets an iterator that transforms the elements of another iterator. <p> The transformation occurs during the next() method and the underlying iterator is unaffected by the transformation.

 * @param < I > the input type

 * @param < O > the output type

 * @param iterator  the iterator to use, not null

 * @param transformer  the transform to use, not null

 * @return a new transforming iterator

 * @throws NullPointerException if either parameter is null

 */

public static <I,O>Iterator<O> transformedIterator(final Iterator<? extends I> iterator,final Transformer<? super I,? extends O> transformer){

  Objects.requireNonNull(iterator,"iterator");

  Objects.requireNonNull(transformer,"transformer");

  return new TransformIterator<>(iterator,transformer);

}

