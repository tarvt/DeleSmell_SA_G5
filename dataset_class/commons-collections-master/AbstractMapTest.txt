Location: AbstractMapTest.java

Content: 

/** 

 * JUnit constructor.

 * @param testName  the test name

 */

public AbstractMapTest(final String testName){

  super(testName);

}

Location: AbstractMapTest.java

Content: 

/** 

 * Helper method to add all the mappings described by {@link #getSampleKeys()} and {@link #getSampleValues()}.

 */

public void addSampleMappings(final Map<? super K,? super V> m){

  final K[] keys=getSampleKeys();

  final V[] values=getSampleValues();

  for (int i=0; i < keys.length; i++) {

    try {

      m.put(keys[i],values[i]);

    }

 catch (    final NullPointerException exception) {

      assertTrue("NullPointerException only allowed to be thrown " + "if either the key or value is null.",keys[i] == null || values[i] == null);

      assertTrue("NullPointerException on null key, but " + "isAllowNullKey is not overridden to return false.",keys[i] == null || !isAllowNullKey());

      assertTrue("NullPointerException on null value, but " + "isAllowNullValue is not overridden to return false.",values[i] == null || !isAllowNullValue());

      fail("Unknown reason for NullPointer.");

    }

  }

  assertEquals("size must reflect number of mappings added.",keys.length,m.size());

}

Location: AbstractMapTest.java

Content: 

public boolean areEqualElementsDistinguishable(){

  return false;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Bulk test  {@link Map#entrySet()}.  This method runs through all of the tests in  {@link AbstractSetTest}. After modification operations,  {@link #verify()} is invoked to ensurethat the map and the other collection views are still valid.

 * @return a {@link AbstractSetTest} instance for testing the map's entry set

 */

public BulkTest bulkTestMapEntrySet(){

  return new TestMapEntrySet();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Bulk test  {@link Map#keySet()}.  This method runs through all of the tests in  {@link AbstractSetTest}. After modification operations,  {@link #verify()} is invoked to ensurethat the map and the other collection views are still valid.

 * @return a {@link AbstractSetTest} instance for testing the map's key set

 */

public BulkTest bulkTestMapKeySet(){

  return new TestMapKeySet();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Bulk test  {@link Map#values()}.  This method runs through all of the tests in  {@link AbstractCollectionTest}. After modification operations,  {@link #verify()} is invoked to ensurethat the map and the other collection views are still valid.

 * @return a {@link AbstractCollectionTest} instance for testing the map'svalues collection

 */

public BulkTest bulkTestMapValues(){

  return new TestMapValues();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Creates a new Map Entry that is independent of the first and the map.

 */

public static <K,V>Map.Entry<K,V> cloneMapEntry(final Map.Entry<K,V> entry){

  final HashMap<K,V> map=new HashMap<>();

  map.put(entry.getKey(),entry.getValue());

  return map.entrySet().iterator().next();

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") protected <E>List<E> getAsList(final Object[] o){

  final ArrayList<E> result=new ArrayList<>();

  for (  final Object element : o) {

    result.add((E)element);

  }

  return result;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns a the set of values that can be used to replace the values returned from  {@link #getSampleValues()}.  This method must return an array with the same length as  {@link #getSampleValues()}.  The values returned from this method should not be the same as those returned from {@link #getSampleValues()}.  The default implementation constructs a set of String values and includes a single null value if {@link #isAllowNullValue()} returns {@code true}, and includes two values that are the same if  {@link #isAllowDuplicateValues()} returns{@code true}.

 */

@SuppressWarnings("unchecked") public V[] getNewSampleValues(){

  final Object[] result=new Object[]{isAllowNullValue() && !JDK12 && isAllowDuplicateValues() ? null : "newnonnullvalue","newvalue",isAllowDuplicateValues() ? "newvalue" : "newvalue2","newblahv","newfoov","newbarv","newbazv","newtmpv","newgoshv","newgollyv","newgeev","newhellov","newgoodbyev","newwe'llv","newseev","newyouv","newallv","newagainv"};

  return (V[])result;

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public K[] getOtherKeys(){

  return (K[])getOtherNonNullStringElements();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns a list of string elements suitable for return by {@link #getOtherKeys()} or {@link #getOtherValues}. <p>Override getOtherElements to return the results of this method if your collection does not support heterogenous elements or the null element. </p>

 */

public Object[] getOtherNonNullStringElements(){

  return new Object[]{"For","then","despite","space","I","would","be","brought","From","limits","far","remote","where","thou","dost","stay"};

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public V[] getOtherValues(){

  return (V[])getOtherNonNullStringElements();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}supports duplicate values. <p> Default implementation returns true. Override if your collection class does not support duplicate values.

 */

public boolean isAllowDuplicateValues(){

  return true;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}supports null values. <p> Default implementation returns true. Override if your collection class does not support null values.

 */

public boolean isAllowNullValue(){

  return true;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}can cause structural modification on a get(). The example is LRUMap. <p> Default implementation returns false. Override if your map class structurally modifies on get.

 */

public boolean isGetStructuralModify(){

  return false;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}support the  {@code setValue} operation on entrySet entries.<p> Default implementation returns isPutChangeSupported(). Override if your collection class does not support setValue but does support put changing.

 */

public boolean isSetValueSupported(){

  return isPutChangeSupported();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Utility methods to create an array of Map.Entry objects out of the given key and value arrays.<P>

 * @param keys    the array of keys

 * @param values  the array of values

 * @return an array of Map.Entry of those keys to those values

 */

@SuppressWarnings("unchecked") private Map.Entry<K,V>[] makeEntryArray(final K[] keys,final V[] values){

  final Map.Entry<K,V>[] result=new Map.Entry[keys.length];

  for (int i=0; i < keys.length; i++) {

    final Map<K,V> map=makeConfirmedMap();

    map.put(keys[i],values[i]);

    result[i]=map.entrySet().iterator().next();

  }

  return result;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#entrySet()} collection is backed bythe underlying map for clear().

 */

public void testEntrySetClearChangesMap(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  assertFalse(getMap().isEmpty());

  assertFalse(entrySet.isEmpty());

  entrySet.clear();

  assertTrue(getMap().isEmpty());

  assertTrue(entrySet.isEmpty());

  resetFull();

  entrySet=getMap().entrySet();

  assertFalse(getMap().isEmpty());

  assertFalse(entrySet.isEmpty());

  getMap().clear();

  assertTrue(getMap().isEmpty());

  assertTrue(entrySet.isEmpty());

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetContains1(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  assertTrue(entrySet.contains(entry));

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetContains2(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final Map.Entry<K,V> test=cloneMapEntry(entry);

  assertTrue(entrySet.contains(test));

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public void testEntrySetContains3(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final HashMap<K,V> temp=new HashMap<>();

  temp.put(entry.getKey(),(V)"A VERY DIFFERENT VALUE");

  final Map.Entry<K,V> test=temp.entrySet().iterator().next();

  assertFalse(entrySet.contains(test));

}

Location: AbstractMapTest.java

Content: 

/** 

 * Verify that entrySet.iterator.remove changes the underlying map.

 */

public void testEntrySetIteratorRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  for (final Iterator<Map.Entry<K,V>> iter=getMap().entrySet().iterator(); iter.hasNext(); ) {

    final K key=iter.next().getKey();

    try {

      iter.remove();

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse(getMap().containsKey(key));

  }

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetRemove1(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  final int size=getMap().size();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final K key=entry.getKey();

  assertTrue(entrySet.remove(entry));

  assertFalse(getMap().containsKey(key));

  assertEquals(size - 1,getMap().size());

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetRemove2(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  final int size=getMap().size();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final K key=entry.getKey();

  final Map.Entry<K,V> test=cloneMapEntry(entry);

  assertTrue(entrySet.remove(test));

  assertFalse(getMap().containsKey(key));

  assertEquals(size - 1,getMap().size());

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public void testEntrySetRemove3(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  final int size=getMap().size();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final K key=entry.getKey();

  final HashMap<K,V> temp=new HashMap<>();

  temp.put(entry.getKey(),(V)"A VERY DIFFERENT VALUE");

  final Map.Entry<K,V> test=temp.entrySet().iterator().next();

  assertFalse(entrySet.remove(test));

  assertTrue(getMap().containsKey(key));

  assertEquals(size,getMap().size());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test entrySet.removeAll.

 */

public void testEntrySetRemoveAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final V[] sampleValues=getSampleValues();

  for (int i=0; i < sampleKeys.length; i++) {

    if (!getMap().containsKey(sampleKeys[i])) {

      return;

    }

    final V value=sampleValues[i];

    final V test=getMap().get(sampleKeys[i]);

    if (value == test || value != null && value.equals(test)) {

      continue;

    }

    return;

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final HashSet<Map.Entry<K,V>> comparisonSet=new HashSet<>(entrySet);

  try {

    assertFalse(entrySet.removeAll(Collections.<Map.Entry<K,V>>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeys.length,getMap().size());

  try {

    assertTrue(entrySet.removeAll(comparisonSet));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#entrySet} set is backed bythe underlying map by removing from the entrySet set and testing if the entry was removed from the map.

 */

public void testEntrySetRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final V[] sampleValues=getSampleValues();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  for (int i=0; i < sampleKeys.length; i++) {

    try {

      entrySet.remove(new DefaultMapEntry<>(sampleKeys[i],sampleValues[i]));

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse("Entry should have been removed from the underlying map.",getMap().containsKey(sampleKeys[i]));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test entrySet.retainAll.

 */

public void testEntrySetRetainAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final V[] sampleValues=getSampleValues();

  for (int i=0; i < sampleKeys.length; i++) {

    if (!getMap().containsKey(sampleKeys[i])) {

      return;

    }

    final V value=sampleValues[i];

    final V test=getMap().get(sampleKeys[i]);

    if (value == test || value != null && value.equals(test)) {

      continue;

    }

    return;

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final HashSet<Map.Entry<K,V>> comparisonSet=new HashSet<>(entrySet);

  try {

    assertFalse(entrySet.retainAll(comparisonSet));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeys.length,getMap().size());

  try {

    assertTrue(entrySet.retainAll(Collections.<Map.Entry<K,V>>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#keySet} collection is backed bythe underlying map for clear().

 */

public void testKeySetClearChangesMap(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  Set<K> keySet=getMap().keySet();

  assertFalse(getMap().isEmpty());

  assertFalse(keySet.isEmpty());

  keySet.clear();

  assertTrue(getMap().isEmpty());

  assertTrue(keySet.isEmpty());

  resetFull();

  keySet=getMap().keySet();

  assertFalse(getMap().isEmpty());

  assertFalse(keySet.isEmpty());

  getMap().clear();

  assertTrue(getMap().isEmpty());

  assertTrue(keySet.isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Verify that keySet.iterator.remove changes the underlying map.

 */

public void testKeySetIteratorRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  for (final Iterator<K> iter=getMap().keySet().iterator(); iter.hasNext(); ) {

    final K key=iter.next();

    try {

      iter.remove();

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse(getMap().containsKey(key));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test keySet.removeAll.

 */

public void testKeySetRemoveAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<K> keys=getMap().keySet();

  final List<K> sampleKeysAsList=Arrays.asList(getSampleKeys());

  if (!keys.equals(sampleKeysAsList)) {

    return;

  }

  try {

    assertFalse(keys.removeAll(Collections.<K>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeysAsList,keys);

  try {

    assertTrue(keys.removeAll(sampleKeysAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#keySet} set is backed bythe underlying map by removing from the keySet set and testing if the key was removed from the map.

 */

public void testKeySetRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final Set<K> keys=getMap().keySet();

  for (  final K sampleKey : sampleKeys) {

    try {

      keys.remove(sampleKey);

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse("Key should have been removed from the underlying map.",getMap().containsKey(sampleKey));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test keySet.retainAll.

 */

public void testKeySetRetainAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<K> keys=getMap().keySet();

  final List<K> sampleKeysAsList=Arrays.asList(getSampleKeys());

  if (!keys.equals(sampleKeysAsList)) {

    return;

  }

  try {

    assertFalse(keys.retainAll(sampleKeysAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeysAsList,keys);

  try {

    assertTrue(keys.retainAll(Collections.<K>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test to ensure that makeEmptyMap and makeFull returns a new non-null map with each invocation.

 */

public void testMakeMap(){

  final Map<K,V> em=makeObject();

  assertNotNull("failure in test: makeEmptyMap must return a non-null map.",em);

  final Map<K,V> em2=makeObject();

  assertNotNull("failure in test: makeEmptyMap must return a non-null map.",em);

  assertNotSame("failure in test: makeEmptyMap must return a new map " + "with each invocation.",em,em2);

  final Map<K,V> fm=makeFullMap();

  assertNotNull("failure in test: makeFullMap must return a non-null map.",fm);

  final Map<K,V> fm2=makeFullMap();

  assertNotNull("failure in test: makeFullMap must return a non-null map.",fm);

  assertNotSame("failure in test: makeFullMap must return a new map " + "with each invocation.",fm,fm2);

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests  {@link Map#clear()}.  If the map  {@link #isRemoveSupported()}can add and remove elements}, then  {@link Map#size()} and{@link Map#isEmpty()} are used to ensure that map has no elements aftera call to clear.  If the map does not support adding and removing elements, this method checks to ensure clear throws an UnsupportedOperationException.

 */

public void testMapClear(){

  if (!isRemoveSupported()) {

    try {

      hongshuai();

      this.map=makeFullMap();

      views();

      this.confirmed=makeConfirmedMap();

      final K[] k=getSampleKeys();

      final V[] v=getSampleValues();

      for (int i=0; i < k.length; i++) {

        confirmed.put(k[i],v[i]);

      }

      getMap().clear();

      fail("Expected UnsupportedOperationException on clear");

    }

 catch (    final UnsupportedOperationException ex) {

    }

    return;

  }

  resetEmpty();

  getMap().clear();

  getConfirmed().clear();

  verify();

  resetFull();

  getMap().clear();

  getConfirmed().clear();

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.containsKey(Object) by verifying it returns false for all sample keys on a map created using an empty map and returns true for all sample keys returned on a full map.

 */

public void testMapContainsKey(){

  final Object[] keys=getSampleKeys();

  resetEmpty();

  for (  final Object key : keys) {

    assertFalse("Map must not contain key when map is empty",getMap().containsKey(key));

  }

  verify();

  resetFull();

  for (  final Object key : keys) {

    assertTrue("Map must contain key for a mapping in the map. " + "Missing: " + key,getMap().containsKey(key));

  }

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.containsValue(Object) by verifying it returns false for all sample values on an empty map and returns true for all sample values on a full map.

 */

public void testMapContainsValue(){

  final Object[] values=getSampleValues();

  resetEmpty();

  for (  final Object value : values) {

    assertFalse("Empty map must not contain value",getMap().containsValue(value));

  }

  verify();

  resetFull();

  for (  final Object value : values) {

    assertTrue("Map must contain value for a mapping in the map.",getMap().containsValue(value));

  }

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.get(Object)

 */

public void testMapGet(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  final Object[] keys=getSampleKeys();

  final Object[] values=getSampleValues();

  for (  final Object key : keys) {

    assertNull("Empty map.get() should return null.",getMap().get(key));

  }

  verify();

  resetFull();

  for (int i=0; i < keys.length; i++) {

    assertEquals("Full map.get() should return value from mapping.",values[i],getMap().get(keys[i]));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.hashCode()

 */

public void testMapHashCode(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertEquals("Empty maps have different hashCodes.",getMap().hashCode(),confirmed.hashCode());

  resetFull();

  assertEquals("Equal maps have different hashCodes.",getMap().hashCode(),confirmed.hashCode());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.isEmpty()

 */

public void testMapIsEmpty(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertTrue("Map.isEmpty() should return true with an empty map",getMap().isEmpty());

  verify();

  resetFull();

  assertFalse("Map.isEmpty() should return false with a non-empty map",getMap().isEmpty());

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.put(Object, Object)

 */

public void testMapPut(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] keys=getSampleKeys();

  final V[] values=getSampleValues();

  final V[] newValues=getNewSampleValues();

  if (isPutAddSupported()) {

    for (int i=0; i < keys.length; i++) {

      final Object o=getMap().put(keys[i],values[i]);

      getConfirmed().put(keys[i],values[i]);

      verify();

      assertNull("First map.put should return null",o);

      assertTrue("Map should contain key after put",getMap().containsKey(keys[i]));

      assertTrue("Map should contain value after put",getMap().containsValue(values[i]));

    }

    if (isPutChangeSupported()) {

      for (int i=0; i < keys.length; i++) {

        final Object o=getMap().put(keys[i],newValues[i]);

        getConfirmed().put(keys[i],newValues[i]);

        verify();

        assertEquals("Map.put should return previous value when changed",values[i],o);

        assertTrue("Map should still contain key after put when changed",getMap().containsKey(keys[i]));

        assertTrue("Map should contain new value after put when changed",getMap().containsValue(newValues[i]));

        if (!isAllowDuplicateValues()) {

          assertFalse("Map should not contain old value after put when changed",getMap().containsValue(values[i]));

        }

      }

    }

 else {

      try {

        getMap().put(keys[0],newValues[0]);

        fail("Expected IllegalArgumentException or UnsupportedOperationException on put (change)");

      }

 catch (      final IllegalArgumentException|UnsupportedOperationException ex) {

      }

    }

  }

 else   if (isPutChangeSupported()) {

    hongshuai();

    this.map=makeObject();

    views();

    this.confirmed=makeConfirmedMap();

    try {

      getMap().put(keys[0],values[0]);

      fail("Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size");

    }

 catch (    final IllegalArgumentException|UnsupportedOperationException ex) {

    }

    resetFull();

    int i=0;

    for (final Iterator<K> it=getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {

      final K key=it.next();

      final V o=getMap().put(key,newValues[i]);

      final V value=getConfirmed().put(key,newValues[i]);

      verify();

      assertEquals("Map.put should return previous value when changed",value,o);

      assertTrue("Map should still contain key after put when changed",getMap().containsKey(key));

      assertTrue("Map should contain new value after put when changed",getMap().containsValue(newValues[i]));

      if (!isAllowDuplicateValues()) {

        assertFalse("Map should not contain old value after put when changed",getMap().containsValue(values[i]));

      }

    }

  }

 else {

    try {

      getMap().put(keys[0],values[0]);

      fail("Expected UnsupportedOperationException on put (add)");

    }

 catch (    final UnsupportedOperationException ex) {

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.putAll(map)

 */

public void testMapPutAll(){

  if (!isPutAddSupported()) {

    if (!isPutChangeSupported()) {

      final Map<K,V> temp=makeFullMap();

      resetEmpty();

      try {

        getMap().putAll(temp);

        fail("Expected UnsupportedOperationException on putAll");

      }

 catch (      final UnsupportedOperationException ex) {

      }

    }

    return;

  }

  resetEmpty();

  assertEquals(0,getMap().size());

  getMap().putAll(new HashMap<K,V>());

  assertEquals(0,getMap().size());

  resetFull();

  final int size=getMap().size();

  getMap().putAll(new HashMap<K,V>());

  assertEquals(size,getMap().size());

  resetEmpty();

  Map<K,V> m2=makeFullMap();

  getMap().putAll(m2);

  getConfirmed().putAll(m2);

  verify();

  resetEmpty();

  m2=makeConfirmedMap();

  final K[] keys=getSampleKeys();

  final V[] values=getSampleValues();

  for (int i=0; i < keys.length; i++) {

    m2.put(keys[i],values[i]);

  }

  getMap().putAll(m2);

  getConfirmed().putAll(m2);

  verify();

  resetEmpty();

  m2=makeConfirmedMap();

  getMap().put(keys[0],values[0]);

  getConfirmed().put(keys[0],values[0]);

  verify();

  for (int i=1; i < keys.length; i++) {

    m2.put(keys[i],values[i]);

  }

  getMap().putAll(m2);

  getConfirmed().putAll(m2);

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.put(null, value)

 */

public void testMapPutNullKey(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final V[] values=getSampleValues();

  if (isPutAddSupported()) {

    if (isAllowNullKey()) {

      getMap().put(null,values[0]);

    }

 else {

      try {

        getMap().put(null,values[0]);

        fail("put(null, value) should throw NPE/IAE");

      }

 catch (      final NullPointerException|IllegalArgumentException ex) {

      }

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.put(null, value)

 */

public void testMapPutNullValue(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] keys=getSampleKeys();

  if (isPutAddSupported()) {

    if (isAllowNullValue()) {

      getMap().put(keys[0],null);

    }

 else {

      try {

        getMap().put(keys[0],null);

        fail("put(key, null) should throw NPE/IAE");

      }

 catch (      final NullPointerException|IllegalArgumentException ex) {

      }

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.remove(Object)

 */

public void testMapRemove(){

  if (!isRemoveSupported()) {

    try {

      hongshuai();

      this.map=makeFullMap();

      views();

      this.confirmed=makeConfirmedMap();

      final K[] k=getSampleKeys();

      final V[] v=getSampleValues();

      for (int i=0; i < k.length; i++) {

        confirmed.put(k[i],v[i]);

      }

      getMap().remove(getMap().keySet().iterator().next());

      fail("Expected UnsupportedOperationException on remove");

    }

 catch (    final UnsupportedOperationException ex) {

    }

    return;

  }

  resetEmpty();

  final Object[] keys=getSampleKeys();

  final Object[] values=getSampleValues();

  for (  final Object key : keys) {

    final Object o=getMap().remove(key);

    assertNull("First map.remove should return null",o);

  }

  verify();

  resetFull();

  for (int i=0; i < keys.length; i++) {

    final Object o=getMap().remove(keys[i]);

    getConfirmed().remove(keys[i]);

    verify();

    assertEquals("map.remove with valid key should return value",values[i],o);

  }

  final Object[] other=getOtherKeys();

  resetFull();

  final int size=getMap().size();

  for (  final Object element : other) {

    final Object o=getMap().remove(element);

    assertNull("map.remove for nonexistent key should return null",o);

    assertEquals("map.remove for nonexistent key should not " + "shrink map",size,getMap().size());

  }

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.size()

 */

public void testMapSize(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertEquals("Map.size() should be 0 with an empty map",0,getMap().size());

  verify();

  resetFull();

  assertEquals("Map.size() should equal the number of entries " + "in the map",getSampleKeys().length,getMap().size());

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.toString().  Since the format of the string returned by the toString() method is not defined in the Map interface, there is no common way to test the results of the toString() method.  Therefore, it is encouraged that Map implementations override this test with one that checks the format matches any format defined in its API.  This default implementation just verifies that the toString() method does not return null.

 */

public void testMapToString(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertNotNull("Empty map toString() should not return null",getMap().toString());

  verify();

  resetFull();

  assertNotNull("Empty map toString() should not return null",getMap().toString());

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test to ensure the test setup is working properly.  This method checks to ensure that the getSampleKeys and getSampleValues methods are returning results that look appropriate.  That is, they both return a non-null array of equal length.  The keys array must not have any duplicate values, and may only contain a (single) null key if isNullKeySupported() returns true.  The values array must only have a null value if useNullValue() is true and may only have duplicate values if isAllowDuplicateValues() returns true.

 */

public void testSampleMappings(){

  final Object[] keys=getSampleKeys();

  final Object[] values=getSampleValues();

  final Object[] newValues=getNewSampleValues();

  assertNotNull("failure in test: Must have keys returned from " + "getSampleKeys.",keys);

  assertNotNull("failure in test: Must have values returned from " + "getSampleValues.",values);

  assertEquals("failure in test: not the same number of sample " + "keys and values.",keys.length,values.length);

  assertEquals("failure in test: not the same number of values and new values.",values.length,newValues.length);

  for (int i=0; i < keys.length - 1; i++) {

    for (int j=i + 1; j < keys.length; j++) {

      assertTrue("failure in test: duplicate null keys.",keys[i] != null || keys[j] != null);

      assertTrue("failure in test: duplicate non-null key.",keys[i] == null || keys[j] == null || !keys[i].equals(keys[j]) && !keys[j].equals(keys[i]));

    }

    assertTrue("failure in test: found null key, but isNullKeySupported " + "is false.",keys[i] != null || isAllowNullKey());

    assertTrue("failure in test: found null value, but isNullValueSupported " + "is false.",values[i] != null || isAllowNullValue());

    assertTrue("failure in test: found null new value, but isNullValueSupported " + "is false.",newValues[i] != null || isAllowNullValue());

    assertTrue("failure in test: values should not be the same as new value",values[i] != newValues[i] && (values[i] == null || !values[i].equals(newValues[i])));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#values} collection is backed bythe underlying map for clear().

 */

public void testValuesClearChangesMap(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  Collection<V> values=getMap().values();

  assertFalse(getMap().isEmpty());

  assertFalse(values.isEmpty());

  values.clear();

  assertTrue(getMap().isEmpty());

  assertTrue(values.isEmpty());

  resetFull();

  values=getMap().values();

  assertFalse(getMap().isEmpty());

  assertFalse(values.isEmpty());

  getMap().clear();

  assertTrue(getMap().isEmpty());

  assertTrue(values.isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Verifies that values.iterator.remove changes the underlying map.

 */

@SuppressWarnings("boxing") public void testValuesIteratorRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final List<V> sampleValuesAsList=Arrays.asList(getSampleValues());

  final Map<V,Integer> cardinality=CollectionUtils.getCardinalityMap(sampleValuesAsList);

  final Collection<V> values=getMap().values();

  for (final Iterator<V> iter=values.iterator(); iter.hasNext(); ) {

    final V value=iter.next();

    Integer count=cardinality.get(value);

    if (count == null) {

      return;

    }

    try {

      iter.remove();

      cardinality.put(value,--count);

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    final boolean expected=count > 0;

    final StringBuilder msg=new StringBuilder("Value should ");

    msg.append(expected ? "yet " : "no longer ");

    msg.append("be present in the underlying map");

    assertEquals(msg.toString(),expected,getMap().containsValue(value));

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests values.removeAll.

 */

public void testValuesRemoveAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Collection<V> values=getMap().values();

  final List<V> sampleValuesAsList=Arrays.asList(getSampleValues());

  if (!values.equals(sampleValuesAsList)) {

    return;

  }

  try {

    assertFalse(values.removeAll(Collections.<V>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleValuesAsList.size(),getMap().size());

  try {

    assertTrue(values.removeAll(sampleValuesAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#values} collection is backed bythe underlying map by removing from the values collection and testing if the value was removed from the map. <p> We should really test the "vice versa" case--that values removed from the map are removed from the values collection--also, but that's a more difficult test to construct (lacking a "removeValue" method.) </p> <p> See bug <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=9573"> 9573</a>. </p>

 */

public void testValuesRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final V[] sampleValues=getSampleValues();

  final Collection<V> values=getMap().values();

  for (  final V sampleValue : sampleValues) {

    if (map.containsValue(sampleValue)) {

      int j=0;

      while (values.contains(sampleValue) && j < 10000) {

        try {

          values.remove(sampleValue);

        }

 catch (        final UnsupportedOperationException e) {

          return;

        }

        j++;

      }

      assertTrue("values().remove(obj) is broken",j < 10000);

      assertFalse("Value should have been removed from the underlying map.",getMap().containsValue(sampleValue));

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test values.retainAll.

 */

public void testValuesRetainAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Collection<V> values=getMap().values();

  final List<V> sampleValuesAsList=Arrays.asList(getSampleValues());

  if (!values.equals(sampleValuesAsList)) {

    return;

  }

  try {

    assertFalse(values.retainAll(sampleValuesAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleValuesAsList.size(),getMap().size());

  try {

    assertTrue(values.retainAll(Collections.<V>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

public void verifyEntrySet(){

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("entrySet should be same size as HashMap's" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),size,entrySet.size());

  assertEquals("entrySet should be empty if HashMap is" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),empty,entrySet.isEmpty());

  assertTrue("entrySet should contain all HashMap's elements" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),entrySet.containsAll(getConfirmed().entrySet()));

  assertEquals("entrySet hashCodes should be the same" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),getConfirmed().entrySet().hashCode(),entrySet.hashCode());

  assertEquals("Map's entry set should still equal HashMap's",getConfirmed().entrySet(),entrySet);

}

Location: AbstractMapTest.java

Content: 

public void verifyKeySet(){

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("keySet should be same size as HashMap's" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),size,keySet.size());

  assertEquals("keySet should be empty if HashMap is" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),empty,keySet.isEmpty());

  assertTrue("keySet should contain all HashMap's elements" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),keySet.containsAll(getConfirmed().keySet()));

  assertEquals("keySet hashCodes should be the same" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),getConfirmed().keySet().hashCode(),keySet.hashCode());

  assertEquals("Map's key set should still equal HashMap's",getConfirmed().keySet(),keySet);

}

Location: AbstractMapTest.java

Content: 

public void verifyMap(){

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("Map should be same size as HashMap",size,getMap().size());

  assertEquals("Map should be empty if HashMap is",empty,getMap().isEmpty());

  assertEquals("hashCodes should be the same",getConfirmed().hashCode(),getMap().hashCode());

  assertEquals("Map should still equal HashMap",map,confirmed);

  assertEquals("Map should still equal HashMap",getMap(),getConfirmed());

}

Location: AbstractMapTest.java

Content: 

public void verifyValues(){

  final List<V> known=new ArrayList<>(getConfirmed().values());

  values=getMap().values();

  final List<V> test=new ArrayList<>(values);

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("values should be same size as HashMap's" + "\nTest: " + test + "\nReal: "+ known,size,values.size());

  assertEquals("values should be empty if HashMap is" + "\nTest: " + test + "\nReal: "+ known,empty,values.isEmpty());

  assertTrue("values should contain all HashMap's elements" + "\nTest: " + test + "\nReal: "+ known,test.containsAll(known));

  assertTrue("values should contain all HashMap's elements" + "\nTest: " + test + "\nReal: "+ known,known.containsAll(test));

  for (  final V v : known) {

    final boolean removed=test.remove(v);

    assertTrue("Map's values should still equal HashMap's",removed);

  }

  assertTrue("Map's values should still equal HashMap's",test.isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Resets the collection view fields.

 */

private void views(){

  this.keySet=getMap().keySet();

  this.entrySet=getMap().entrySet();

}

Location: AbstractMapTest.java

Content: 

/** 

 * JUnit constructor.

 * @param testName  the test name

 */

public AbstractMapTest(final String testName){

  super(testName);

}

Location: AbstractMapTest.java

Content: 

/** 

 * Helper method to add all the mappings described by {@link #getSampleKeys()} and {@link #getSampleValues()}.

 */

public void addSampleMappings(final Map<? super K,? super V> m){

  final K[] keys=getSampleKeys();

  final V[] values=getSampleValues();

  for (int i=0; i < keys.length; i++) {

    try {

      m.put(keys[i],values[i]);

    }

 catch (    final NullPointerException exception) {

      assertTrue("NullPointerException only allowed to be thrown " + "if either the key or value is null.",keys[i] == null || values[i] == null);

      assertTrue("NullPointerException on null key, but " + "isAllowNullKey is not overridden to return false.",keys[i] == null || !isAllowNullKey());

      assertTrue("NullPointerException on null value, but " + "isAllowNullValue is not overridden to return false.",values[i] == null || !isAllowNullValue());

      fail("Unknown reason for NullPointer.");

    }

  }

  assertEquals("size must reflect number of mappings added.",keys.length,m.size());

}

Location: AbstractMapTest.java

Content: 

public boolean areEqualElementsDistinguishable(){

  return false;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Bulk test  {@link Map#entrySet()}.  This method runs through all of the tests in  {@link AbstractSetTest}. After modification operations,  {@link #verify()} is invoked to ensurethat the map and the other collection views are still valid.

 * @return a {@link AbstractSetTest} instance for testing the map's entry set

 */

public BulkTest bulkTestMapEntrySet(){

  return new TestMapEntrySet();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Bulk test  {@link Map#keySet()}.  This method runs through all of the tests in  {@link AbstractSetTest}. After modification operations,  {@link #verify()} is invoked to ensurethat the map and the other collection views are still valid.

 * @return a {@link AbstractSetTest} instance for testing the map's key set

 */

public BulkTest bulkTestMapKeySet(){

  return new TestMapKeySet();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Bulk test  {@link Map#values()}.  This method runs through all of the tests in  {@link AbstractCollectionTest}. After modification operations,  {@link #verify()} is invoked to ensurethat the map and the other collection views are still valid.

 * @return a {@link AbstractCollectionTest} instance for testing the map'svalues collection

 */

public BulkTest bulkTestMapValues(){

  return new TestMapValues();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Creates a new Map Entry that is independent of the first and the map.

 */

public static <K,V>Map.Entry<K,V> cloneMapEntry(final Map.Entry<K,V> entry){

  final HashMap<K,V> map=new HashMap<>();

  map.put(entry.getKey(),entry.getValue());

  return map.entrySet().iterator().next();

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") protected <E>List<E> getAsList(final Object[] o){

  final ArrayList<E> result=new ArrayList<>();

  for (  final Object element : o) {

    result.add((E)element);

  }

  return result;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns a the set of values that can be used to replace the values returned from  {@link #getSampleValues()}.  This method must return an array with the same length as  {@link #getSampleValues()}.  The values returned from this method should not be the same as those returned from {@link #getSampleValues()}.  The default implementation constructs a set of String values and includes a single null value if {@link #isAllowNullValue()} returns {@code true}, and includes two values that are the same if  {@link #isAllowDuplicateValues()} returns{@code true}.

 */

@SuppressWarnings("unchecked") public V[] getNewSampleValues(){

  final Object[] result=new Object[]{isAllowNullValue() && !JDK12 && isAllowDuplicateValues() ? null : "newnonnullvalue","newvalue",isAllowDuplicateValues() ? "newvalue" : "newvalue2","newblahv","newfoov","newbarv","newbazv","newtmpv","newgoshv","newgollyv","newgeev","newhellov","newgoodbyev","newwe'llv","newseev","newyouv","newallv","newagainv"};

  return (V[])result;

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public K[] getOtherKeys(){

  return (K[])getOtherNonNullStringElements();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns a list of string elements suitable for return by {@link #getOtherKeys()} or {@link #getOtherValues}. <p>Override getOtherElements to return the results of this method if your collection does not support heterogenous elements or the null element. </p>

 */

public Object[] getOtherNonNullStringElements(){

  return new Object[]{"For","then","despite","space","I","would","be","brought","From","limits","far","remote","where","thou","dost","stay"};

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public V[] getOtherValues(){

  return (V[])getOtherNonNullStringElements();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}supports duplicate values. <p> Default implementation returns true. Override if your collection class does not support duplicate values.

 */

public boolean isAllowDuplicateValues(){

  return true;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}supports null values. <p> Default implementation returns true. Override if your collection class does not support null values.

 */

public boolean isAllowNullValue(){

  return true;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}can cause structural modification on a get(). The example is LRUMap. <p> Default implementation returns false. Override if your map class structurally modifies on get.

 */

public boolean isGetStructuralModify(){

  return false;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()}support the  {@code setValue} operation on entrySet entries.<p> Default implementation returns isPutChangeSupported(). Override if your collection class does not support setValue but does support put changing.

 */

public boolean isSetValueSupported(){

  return isPutChangeSupported();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Utility methods to create an array of Map.Entry objects out of the given key and value arrays.<P>

 * @param keys    the array of keys

 * @param values  the array of values

 * @return an array of Map.Entry of those keys to those values

 */

@SuppressWarnings("unchecked") private Map.Entry<K,V>[] makeEntryArray(final K[] keys,final V[] values){

  final Map.Entry<K,V>[] result=new Map.Entry[keys.length];

  for (int i=0; i < keys.length; i++) {

    final Map<K,V> map=makeConfirmedMap();

    map.put(keys[i],values[i]);

    result[i]=map.entrySet().iterator().next();

  }

  return result;

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#entrySet()} collection is backed bythe underlying map for clear().

 */

public void testEntrySetClearChangesMap(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  assertFalse(getMap().isEmpty());

  assertFalse(entrySet.isEmpty());

  entrySet.clear();

  assertTrue(getMap().isEmpty());

  assertTrue(entrySet.isEmpty());

  resetFull();

  entrySet=getMap().entrySet();

  assertFalse(getMap().isEmpty());

  assertFalse(entrySet.isEmpty());

  getMap().clear();

  assertTrue(getMap().isEmpty());

  assertTrue(entrySet.isEmpty());

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetContains1(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  assertTrue(entrySet.contains(entry));

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetContains2(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final Map.Entry<K,V> test=cloneMapEntry(entry);

  assertTrue(entrySet.contains(test));

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public void testEntrySetContains3(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final HashMap<K,V> temp=new HashMap<>();

  temp.put(entry.getKey(),(V)"A VERY DIFFERENT VALUE");

  final Map.Entry<K,V> test=temp.entrySet().iterator().next();

  assertFalse(entrySet.contains(test));

}

Location: AbstractMapTest.java

Content: 

/** 

 * Verify that entrySet.iterator.remove changes the underlying map.

 */

public void testEntrySetIteratorRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  for (final Iterator<Map.Entry<K,V>> iter=getMap().entrySet().iterator(); iter.hasNext(); ) {

    final K key=iter.next().getKey();

    try {

      iter.remove();

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse(getMap().containsKey(key));

  }

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetRemove1(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  final int size=getMap().size();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final K key=entry.getKey();

  assertTrue(entrySet.remove(entry));

  assertFalse(getMap().containsKey(key));

  assertEquals(size - 1,getMap().size());

}

Location: AbstractMapTest.java

Content: 

public void testEntrySetRemove2(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  final int size=getMap().size();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final K key=entry.getKey();

  final Map.Entry<K,V> test=cloneMapEntry(entry);

  assertTrue(entrySet.remove(test));

  assertFalse(getMap().containsKey(key));

  assertEquals(size - 1,getMap().size());

}

Location: AbstractMapTest.java

Content: 

@SuppressWarnings("unchecked") public void testEntrySetRemove3(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  final int size=getMap().size();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final Map.Entry<K,V> entry=entrySet.iterator().next();

  final K key=entry.getKey();

  final HashMap<K,V> temp=new HashMap<>();

  temp.put(entry.getKey(),(V)"A VERY DIFFERENT VALUE");

  final Map.Entry<K,V> test=temp.entrySet().iterator().next();

  assertFalse(entrySet.remove(test));

  assertTrue(getMap().containsKey(key));

  assertEquals(size,getMap().size());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test entrySet.removeAll.

 */

public void testEntrySetRemoveAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final V[] sampleValues=getSampleValues();

  for (int i=0; i < sampleKeys.length; i++) {

    if (!getMap().containsKey(sampleKeys[i])) {

      return;

    }

    final V value=sampleValues[i];

    final V test=getMap().get(sampleKeys[i]);

    if (value == test || value != null && value.equals(test)) {

      continue;

    }

    return;

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final HashSet<Map.Entry<K,V>> comparisonSet=new HashSet<>(entrySet);

  try {

    assertFalse(entrySet.removeAll(Collections.<Map.Entry<K,V>>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeys.length,getMap().size());

  try {

    assertTrue(entrySet.removeAll(comparisonSet));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#entrySet} set is backed bythe underlying map by removing from the entrySet set and testing if the entry was removed from the map.

 */

public void testEntrySetRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final V[] sampleValues=getSampleValues();

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  for (int i=0; i < sampleKeys.length; i++) {

    try {

      entrySet.remove(new DefaultMapEntry<>(sampleKeys[i],sampleValues[i]));

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse("Entry should have been removed from the underlying map.",getMap().containsKey(sampleKeys[i]));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test entrySet.retainAll.

 */

public void testEntrySetRetainAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final V[] sampleValues=getSampleValues();

  for (int i=0; i < sampleKeys.length; i++) {

    if (!getMap().containsKey(sampleKeys[i])) {

      return;

    }

    final V value=sampleValues[i];

    final V test=getMap().get(sampleKeys[i]);

    if (value == test || value != null && value.equals(test)) {

      continue;

    }

    return;

  }

  final Set<Map.Entry<K,V>> entrySet=getMap().entrySet();

  final HashSet<Map.Entry<K,V>> comparisonSet=new HashSet<>(entrySet);

  try {

    assertFalse(entrySet.retainAll(comparisonSet));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeys.length,getMap().size());

  try {

    assertTrue(entrySet.retainAll(Collections.<Map.Entry<K,V>>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#keySet} collection is backed bythe underlying map for clear().

 */

public void testKeySetClearChangesMap(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  Set<K> keySet=getMap().keySet();

  assertFalse(getMap().isEmpty());

  assertFalse(keySet.isEmpty());

  keySet.clear();

  assertTrue(getMap().isEmpty());

  assertTrue(keySet.isEmpty());

  resetFull();

  keySet=getMap().keySet();

  assertFalse(getMap().isEmpty());

  assertFalse(keySet.isEmpty());

  getMap().clear();

  assertTrue(getMap().isEmpty());

  assertTrue(keySet.isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Verify that keySet.iterator.remove changes the underlying map.

 */

public void testKeySetIteratorRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  for (final Iterator<K> iter=getMap().keySet().iterator(); iter.hasNext(); ) {

    final K key=iter.next();

    try {

      iter.remove();

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse(getMap().containsKey(key));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test keySet.removeAll.

 */

public void testKeySetRemoveAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<K> keys=getMap().keySet();

  final List<K> sampleKeysAsList=Arrays.asList(getSampleKeys());

  if (!keys.equals(sampleKeysAsList)) {

    return;

  }

  try {

    assertFalse(keys.removeAll(Collections.<K>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeysAsList,keys);

  try {

    assertTrue(keys.removeAll(sampleKeysAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#keySet} set is backed bythe underlying map by removing from the keySet set and testing if the key was removed from the map.

 */

public void testKeySetRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] sampleKeys=getSampleKeys();

  final Set<K> keys=getMap().keySet();

  for (  final K sampleKey : sampleKeys) {

    try {

      keys.remove(sampleKey);

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    assertFalse("Key should have been removed from the underlying map.",getMap().containsKey(sampleKey));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test keySet.retainAll.

 */

public void testKeySetRetainAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Set<K> keys=getMap().keySet();

  final List<K> sampleKeysAsList=Arrays.asList(getSampleKeys());

  if (!keys.equals(sampleKeysAsList)) {

    return;

  }

  try {

    assertFalse(keys.retainAll(sampleKeysAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleKeysAsList,keys);

  try {

    assertTrue(keys.retainAll(Collections.<K>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test to ensure that makeEmptyMap and makeFull returns a new non-null map with each invocation.

 */

public void testMakeMap(){

  final Map<K,V> em=makeObject();

  assertNotNull("failure in test: makeEmptyMap must return a non-null map.",em);

  final Map<K,V> em2=makeObject();

  assertNotNull("failure in test: makeEmptyMap must return a non-null map.",em);

  assertNotSame("failure in test: makeEmptyMap must return a new map " + "with each invocation.",em,em2);

  final Map<K,V> fm=makeFullMap();

  assertNotNull("failure in test: makeFullMap must return a non-null map.",fm);

  final Map<K,V> fm2=makeFullMap();

  assertNotNull("failure in test: makeFullMap must return a non-null map.",fm);

  assertNotSame("failure in test: makeFullMap must return a new map " + "with each invocation.",fm,fm2);

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests  {@link Map#clear()}.  If the map  {@link #isRemoveSupported()}can add and remove elements}, then  {@link Map#size()} and{@link Map#isEmpty()} are used to ensure that map has no elements aftera call to clear.  If the map does not support adding and removing elements, this method checks to ensure clear throws an UnsupportedOperationException.

 */

public void testMapClear(){

  if (!isRemoveSupported()) {

    try {

      hongshuai();

      this.map=makeFullMap();

      views();

      this.confirmed=makeConfirmedMap();

      final K[] k=getSampleKeys();

      final V[] v=getSampleValues();

      for (int i=0; i < k.length; i++) {

        confirmed.put(k[i],v[i]);

      }

      getMap().clear();

      fail("Expected UnsupportedOperationException on clear");

    }

 catch (    final UnsupportedOperationException ex) {

    }

    return;

  }

  resetEmpty();

  getMap().clear();

  getConfirmed().clear();

  verify();

  resetFull();

  getMap().clear();

  getConfirmed().clear();

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.containsKey(Object) by verifying it returns false for all sample keys on a map created using an empty map and returns true for all sample keys returned on a full map.

 */

public void testMapContainsKey(){

  final Object[] keys=getSampleKeys();

  resetEmpty();

  for (  final Object key : keys) {

    assertFalse("Map must not contain key when map is empty",getMap().containsKey(key));

  }

  verify();

  resetFull();

  for (  final Object key : keys) {

    assertTrue("Map must contain key for a mapping in the map. " + "Missing: " + key,getMap().containsKey(key));

  }

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.containsValue(Object) by verifying it returns false for all sample values on an empty map and returns true for all sample values on a full map.

 */

public void testMapContainsValue(){

  final Object[] values=getSampleValues();

  resetEmpty();

  for (  final Object value : values) {

    assertFalse("Empty map must not contain value",getMap().containsValue(value));

  }

  verify();

  resetFull();

  for (  final Object value : values) {

    assertTrue("Map must contain value for a mapping in the map.",getMap().containsValue(value));

  }

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.get(Object)

 */

public void testMapGet(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  final Object[] keys=getSampleKeys();

  final Object[] values=getSampleValues();

  for (  final Object key : keys) {

    assertNull("Empty map.get() should return null.",getMap().get(key));

  }

  verify();

  resetFull();

  for (int i=0; i < keys.length; i++) {

    assertEquals("Full map.get() should return value from mapping.",values[i],getMap().get(keys[i]));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.hashCode()

 */

public void testMapHashCode(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertEquals("Empty maps have different hashCodes.",getMap().hashCode(),confirmed.hashCode());

  resetFull();

  assertEquals("Equal maps have different hashCodes.",getMap().hashCode(),confirmed.hashCode());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.isEmpty()

 */

public void testMapIsEmpty(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertTrue("Map.isEmpty() should return true with an empty map",getMap().isEmpty());

  verify();

  resetFull();

  assertFalse("Map.isEmpty() should return false with a non-empty map",getMap().isEmpty());

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.put(Object, Object)

 */

public void testMapPut(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] keys=getSampleKeys();

  final V[] values=getSampleValues();

  final V[] newValues=getNewSampleValues();

  if (isPutAddSupported()) {

    for (int i=0; i < keys.length; i++) {

      final Object o=getMap().put(keys[i],values[i]);

      getConfirmed().put(keys[i],values[i]);

      verify();

      assertNull("First map.put should return null",o);

      assertTrue("Map should contain key after put",getMap().containsKey(keys[i]));

      assertTrue("Map should contain value after put",getMap().containsValue(values[i]));

    }

    if (isPutChangeSupported()) {

      for (int i=0; i < keys.length; i++) {

        final Object o=getMap().put(keys[i],newValues[i]);

        getConfirmed().put(keys[i],newValues[i]);

        verify();

        assertEquals("Map.put should return previous value when changed",values[i],o);

        assertTrue("Map should still contain key after put when changed",getMap().containsKey(keys[i]));

        assertTrue("Map should contain new value after put when changed",getMap().containsValue(newValues[i]));

        if (!isAllowDuplicateValues()) {

          assertFalse("Map should not contain old value after put when changed",getMap().containsValue(values[i]));

        }

      }

    }

 else {

      try {

        getMap().put(keys[0],newValues[0]);

        fail("Expected IllegalArgumentException or UnsupportedOperationException on put (change)");

      }

 catch (      final IllegalArgumentException|UnsupportedOperationException ex) {

      }

    }

  }

 else   if (isPutChangeSupported()) {

    hongshuai();

    this.map=makeObject();

    views();

    this.confirmed=makeConfirmedMap();

    try {

      getMap().put(keys[0],values[0]);

      fail("Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size");

    }

 catch (    final IllegalArgumentException|UnsupportedOperationException ex) {

    }

    resetFull();

    int i=0;

    for (final Iterator<K> it=getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {

      final K key=it.next();

      final V o=getMap().put(key,newValues[i]);

      final V value=getConfirmed().put(key,newValues[i]);

      verify();

      assertEquals("Map.put should return previous value when changed",value,o);

      assertTrue("Map should still contain key after put when changed",getMap().containsKey(key));

      assertTrue("Map should contain new value after put when changed",getMap().containsValue(newValues[i]));

      if (!isAllowDuplicateValues()) {

        assertFalse("Map should not contain old value after put when changed",getMap().containsValue(values[i]));

      }

    }

  }

 else {

    try {

      getMap().put(keys[0],values[0]);

      fail("Expected UnsupportedOperationException on put (add)");

    }

 catch (    final UnsupportedOperationException ex) {

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.putAll(map)

 */

public void testMapPutAll(){

  if (!isPutAddSupported()) {

    if (!isPutChangeSupported()) {

      final Map<K,V> temp=makeFullMap();

      resetEmpty();

      try {

        getMap().putAll(temp);

        fail("Expected UnsupportedOperationException on putAll");

      }

 catch (      final UnsupportedOperationException ex) {

      }

    }

    return;

  }

  resetEmpty();

  assertEquals(0,getMap().size());

  getMap().putAll(new HashMap<K,V>());

  assertEquals(0,getMap().size());

  resetFull();

  final int size=getMap().size();

  getMap().putAll(new HashMap<K,V>());

  assertEquals(size,getMap().size());

  resetEmpty();

  Map<K,V> m2=makeFullMap();

  getMap().putAll(m2);

  getConfirmed().putAll(m2);

  verify();

  resetEmpty();

  m2=makeConfirmedMap();

  final K[] keys=getSampleKeys();

  final V[] values=getSampleValues();

  for (int i=0; i < keys.length; i++) {

    m2.put(keys[i],values[i]);

  }

  getMap().putAll(m2);

  getConfirmed().putAll(m2);

  verify();

  resetEmpty();

  m2=makeConfirmedMap();

  getMap().put(keys[0],values[0]);

  getConfirmed().put(keys[0],values[0]);

  verify();

  for (int i=1; i < keys.length; i++) {

    m2.put(keys[i],values[i]);

  }

  getMap().putAll(m2);

  getConfirmed().putAll(m2);

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.put(null, value)

 */

public void testMapPutNullKey(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final V[] values=getSampleValues();

  if (isPutAddSupported()) {

    if (isAllowNullKey()) {

      getMap().put(null,values[0]);

    }

 else {

      try {

        getMap().put(null,values[0]);

        fail("put(null, value) should throw NPE/IAE");

      }

 catch (      final NullPointerException|IllegalArgumentException ex) {

      }

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.put(null, value)

 */

public void testMapPutNullValue(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final K[] keys=getSampleKeys();

  if (isPutAddSupported()) {

    if (isAllowNullValue()) {

      getMap().put(keys[0],null);

    }

 else {

      try {

        getMap().put(keys[0],null);

        fail("put(key, null) should throw NPE/IAE");

      }

 catch (      final NullPointerException|IllegalArgumentException ex) {

      }

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.remove(Object)

 */

public void testMapRemove(){

  if (!isRemoveSupported()) {

    try {

      hongshuai();

      this.map=makeFullMap();

      views();

      this.confirmed=makeConfirmedMap();

      final K[] k=getSampleKeys();

      final V[] v=getSampleValues();

      for (int i=0; i < k.length; i++) {

        confirmed.put(k[i],v[i]);

      }

      getMap().remove(getMap().keySet().iterator().next());

      fail("Expected UnsupportedOperationException on remove");

    }

 catch (    final UnsupportedOperationException ex) {

    }

    return;

  }

  resetEmpty();

  final Object[] keys=getSampleKeys();

  final Object[] values=getSampleValues();

  for (  final Object key : keys) {

    final Object o=getMap().remove(key);

    assertNull("First map.remove should return null",o);

  }

  verify();

  resetFull();

  for (int i=0; i < keys.length; i++) {

    final Object o=getMap().remove(keys[i]);

    getConfirmed().remove(keys[i]);

    verify();

    assertEquals("map.remove with valid key should return value",values[i],o);

  }

  final Object[] other=getOtherKeys();

  resetFull();

  final int size=getMap().size();

  for (  final Object element : other) {

    final Object o=getMap().remove(element);

    assertNull("map.remove for nonexistent key should return null",o);

    assertEquals("map.remove for nonexistent key should not " + "shrink map",size,getMap().size());

  }

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.size()

 */

public void testMapSize(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertEquals("Map.size() should be 0 with an empty map",0,getMap().size());

  verify();

  resetFull();

  assertEquals("Map.size() should equal the number of entries " + "in the map",getSampleKeys().length,getMap().size());

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests Map.toString().  Since the format of the string returned by the toString() method is not defined in the Map interface, there is no common way to test the results of the toString() method.  Therefore, it is encouraged that Map implementations override this test with one that checks the format matches any format defined in its API.  This default implementation just verifies that the toString() method does not return null.

 */

public void testMapToString(){

  hongshuai();

  this.map=makeObject();

  views();

  this.confirmed=makeConfirmedMap();

  assertNotNull("Empty map toString() should not return null",getMap().toString());

  verify();

  resetFull();

  assertNotNull("Empty map toString() should not return null",getMap().toString());

  verify();

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test to ensure the test setup is working properly.  This method checks to ensure that the getSampleKeys and getSampleValues methods are returning results that look appropriate.  That is, they both return a non-null array of equal length.  The keys array must not have any duplicate values, and may only contain a (single) null key if isNullKeySupported() returns true.  The values array must only have a null value if useNullValue() is true and may only have duplicate values if isAllowDuplicateValues() returns true.

 */

public void testSampleMappings(){

  final Object[] keys=getSampleKeys();

  final Object[] values=getSampleValues();

  final Object[] newValues=getNewSampleValues();

  assertNotNull("failure in test: Must have keys returned from " + "getSampleKeys.",keys);

  assertNotNull("failure in test: Must have values returned from " + "getSampleValues.",values);

  assertEquals("failure in test: not the same number of sample " + "keys and values.",keys.length,values.length);

  assertEquals("failure in test: not the same number of values and new values.",values.length,newValues.length);

  for (int i=0; i < keys.length - 1; i++) {

    for (int j=i + 1; j < keys.length; j++) {

      assertTrue("failure in test: duplicate null keys.",keys[i] != null || keys[j] != null);

      assertTrue("failure in test: duplicate non-null key.",keys[i] == null || keys[j] == null || !keys[i].equals(keys[j]) && !keys[j].equals(keys[i]));

    }

    assertTrue("failure in test: found null key, but isNullKeySupported " + "is false.",keys[i] != null || isAllowNullKey());

    assertTrue("failure in test: found null value, but isNullValueSupported " + "is false.",values[i] != null || isAllowNullValue());

    assertTrue("failure in test: found null new value, but isNullValueSupported " + "is false.",newValues[i] != null || isAllowNullValue());

    assertTrue("failure in test: values should not be the same as new value",values[i] != newValues[i] && (values[i] == null || !values[i].equals(newValues[i])));

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#values} collection is backed bythe underlying map for clear().

 */

public void testValuesClearChangesMap(){

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  Collection<V> values=getMap().values();

  assertFalse(getMap().isEmpty());

  assertFalse(values.isEmpty());

  values.clear();

  assertTrue(getMap().isEmpty());

  assertTrue(values.isEmpty());

  resetFull();

  values=getMap().values();

  assertFalse(getMap().isEmpty());

  assertFalse(values.isEmpty());

  getMap().clear();

  assertTrue(getMap().isEmpty());

  assertTrue(values.isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Verifies that values.iterator.remove changes the underlying map.

 */

@SuppressWarnings("boxing") public void testValuesIteratorRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final List<V> sampleValuesAsList=Arrays.asList(getSampleValues());

  final Map<V,Integer> cardinality=CollectionUtils.getCardinalityMap(sampleValuesAsList);

  final Collection<V> values=getMap().values();

  for (final Iterator<V> iter=values.iterator(); iter.hasNext(); ) {

    final V value=iter.next();

    Integer count=cardinality.get(value);

    if (count == null) {

      return;

    }

    try {

      iter.remove();

      cardinality.put(value,--count);

    }

 catch (    final UnsupportedOperationException e) {

      return;

    }

    final boolean expected=count > 0;

    final StringBuilder msg=new StringBuilder("Value should ");

    msg.append(expected ? "yet " : "no longer ");

    msg.append("be present in the underlying map");

    assertEquals(msg.toString(),expected,getMap().containsValue(value));

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests values.removeAll.

 */

public void testValuesRemoveAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Collection<V> values=getMap().values();

  final List<V> sampleValuesAsList=Arrays.asList(getSampleValues());

  if (!values.equals(sampleValuesAsList)) {

    return;

  }

  try {

    assertFalse(values.removeAll(Collections.<V>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleValuesAsList.size(),getMap().size());

  try {

    assertTrue(values.removeAll(sampleValuesAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Tests that the  {@link Map#values} collection is backed bythe underlying map by removing from the values collection and testing if the value was removed from the map. <p> We should really test the "vice versa" case--that values removed from the map are removed from the values collection--also, but that's a more difficult test to construct (lacking a "removeValue" method.) </p> <p> See bug <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=9573"> 9573</a>. </p>

 */

public void testValuesRemoveChangesMap(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final V[] sampleValues=getSampleValues();

  final Collection<V> values=getMap().values();

  for (  final V sampleValue : sampleValues) {

    if (map.containsValue(sampleValue)) {

      int j=0;

      while (values.contains(sampleValue) && j < 10000) {

        try {

          values.remove(sampleValue);

        }

 catch (        final UnsupportedOperationException e) {

          return;

        }

        j++;

      }

      assertTrue("values().remove(obj) is broken",j < 10000);

      assertFalse("Value should have been removed from the underlying map.",getMap().containsValue(sampleValue));

    }

  }

}

Location: AbstractMapTest.java

Content: 

/** 

 * Test values.retainAll.

 */

public void testValuesRetainAll(){

  hongshuai();

  this.map=makeFullMap();

  views();

  this.confirmed=makeConfirmedMap();

  final K[] k=getSampleKeys();

  final V[] v=getSampleValues();

  for (int i=0; i < k.length; i++) {

    confirmed.put(k[i],v[i]);

  }

  final Collection<V> values=getMap().values();

  final List<V> sampleValuesAsList=Arrays.asList(getSampleValues());

  if (!values.equals(sampleValuesAsList)) {

    return;

  }

  try {

    assertFalse(values.retainAll(sampleValuesAsList));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertEquals(sampleValuesAsList.size(),getMap().size());

  try {

    assertTrue(values.retainAll(Collections.<V>emptySet()));

  }

 catch (  final UnsupportedOperationException e) {

    return;

  }

  assertTrue(getMap().isEmpty());

}

Location: AbstractMapTest.java

Content: 

public void verifyEntrySet(){

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("entrySet should be same size as HashMap's" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),size,entrySet.size());

  assertEquals("entrySet should be empty if HashMap is" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),empty,entrySet.isEmpty());

  assertTrue("entrySet should contain all HashMap's elements" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),entrySet.containsAll(getConfirmed().entrySet()));

  assertEquals("entrySet hashCodes should be the same" + "\nTest: " + entrySet + "\nReal: "+ getConfirmed().entrySet(),getConfirmed().entrySet().hashCode(),entrySet.hashCode());

  assertEquals("Map's entry set should still equal HashMap's",getConfirmed().entrySet(),entrySet);

}

Location: AbstractMapTest.java

Content: 

public void verifyKeySet(){

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("keySet should be same size as HashMap's" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),size,keySet.size());

  assertEquals("keySet should be empty if HashMap is" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),empty,keySet.isEmpty());

  assertTrue("keySet should contain all HashMap's elements" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),keySet.containsAll(getConfirmed().keySet()));

  assertEquals("keySet hashCodes should be the same" + "\nTest: " + keySet + "\nReal: "+ getConfirmed().keySet(),getConfirmed().keySet().hashCode(),keySet.hashCode());

  assertEquals("Map's key set should still equal HashMap's",getConfirmed().keySet(),keySet);

}

Location: AbstractMapTest.java

Content: 

public void verifyMap(){

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("Map should be same size as HashMap",size,getMap().size());

  assertEquals("Map should be empty if HashMap is",empty,getMap().isEmpty());

  assertEquals("hashCodes should be the same",getConfirmed().hashCode(),getMap().hashCode());

  assertEquals("Map should still equal HashMap",map,confirmed);

  assertEquals("Map should still equal HashMap",getMap(),getConfirmed());

}

Location: AbstractMapTest.java

Content: 

public void verifyValues(){

  final List<V> known=new ArrayList<>(getConfirmed().values());

  values=getMap().values();

  final List<V> test=new ArrayList<>(values);

  final int size=getConfirmed().size();

  final boolean empty=getConfirmed().isEmpty();

  assertEquals("values should be same size as HashMap's" + "\nTest: " + test + "\nReal: "+ known,size,values.size());

  assertEquals("values should be empty if HashMap is" + "\nTest: " + test + "\nReal: "+ known,empty,values.isEmpty());

  assertTrue("values should contain all HashMap's elements" + "\nTest: " + test + "\nReal: "+ known,test.containsAll(known));

  assertTrue("values should contain all HashMap's elements" + "\nTest: " + test + "\nReal: "+ known,known.containsAll(test));

  for (  final V v : known) {

    final boolean removed=test.remove(v);

    assertTrue("Map's values should still equal HashMap's",removed);

  }

  assertTrue("Map's values should still equal HashMap's",test.isEmpty());

}

Location: AbstractMapTest.java

Content: 

/** 

 * Resets the collection view fields.

 */

private void views(){

  this.keySet=getMap().keySet();

  this.entrySet=getMap().entrySet();

}

