Location: AbstractCollectionTest.java

Content: 

/** 

 * JUnit constructor.

 * @param testName  the test class name

 */

public AbstractCollectionTest(final String testName){

  super(testName);

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle the optional exceptions declared by  {@link Collection#containsAll(Collection)}

 * @param coll

 * @param sub

 */

protected static void assertNotCollectionContainsAll(final Collection<?> coll,final Collection<?> sub){

  try {

    assertFalse(coll.containsAll(sub));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle the optional exceptions declared by  {@link Collection#contains(Object)}

 * @param coll

 * @param element

 */

protected static void assertNotCollectionContains(final Collection<?> coll,final Object element){

  try {

    assertFalse(coll.contains(element));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle optional exceptions of  {@link Collection#removeAll(Collection)}

 * @param coll

 * @param sub

 */

protected static void assertNotRemoveAllFromCollection(final Collection<?> coll,final Collection<?> sub){

  try {

    assertFalse(coll.removeAll(sub));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle optional exceptions of  {@link Collection#remove(Object)}

 * @param coll

 * @param element

 */

protected static void assertNotRemoveFromCollection(final Collection<?> coll,final Object element){

  try {

    assertFalse(coll.remove(element));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Returns a list of string elements suitable for return by {@link #getFullElements()}.  Override getFullElements to return the results of this method if your collection does not support heterogenous elements or the null element.

 */

public Object[] getFullNonNullStringElements(){

  return new Object[]{"If","the","dull","substance","of","my","flesh","were","thought","Injurious","distance","could","not","stop","my","way"};

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Set the collection.

 * @param collection the Collection<E> to set

 */

public void setCollection(final Collection<E> collection){

  this.collection=collection;

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Set the confirmed.

 * @param confirmed the Collection<E> to set

 */

public void setConfirmed(final Collection<E> confirmed){

  this.confirmed=confirmed;

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#add(Object)}.

 */

public void testCollectionAdd(){

  if (!isAddSupported()) {

    return;

  }

  final E[] elements=getFullElements();

  for (  final E element : elements) {

    resetEmpty();

    final boolean r=getCollection().add(element);

    getConfirmed().add(element);

    verify();

    assertTrue("Empty collection changed after add",r);

    assertEquals("Collection size is 1 after first add",1,getCollection().size());

  }

  resetEmpty();

  int size=0;

  for (  final E element : elements) {

    final boolean r=getCollection().add(element);

    getConfirmed().add(element);

    verify();

    if (r) {

      size++;

    }

    assertEquals("Collection size should grow after add",size,getCollection().size());

    assertTrue("Collection should contain added element",getCollection().contains(element));

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Test  {@link Collection#clear()}.

 */

public void testCollectionClear(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  getCollection().clear();

  verify();

  resetFull();

  getCollection().clear();

  getConfirmed().clear();

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#contains(Object)}.

 */

public void testCollectionContains(){

  Object[] elements;

  resetEmpty();

  elements=getFullElements();

  for (int i=0; i < elements.length; i++) {

    assertFalse("Empty collection shouldn't contain element[" + i + "]",getCollection().contains(elements[i]));

  }

  verify();

  elements=getOtherElements();

  for (int i=0; i < elements.length; i++) {

    assertFalse("Empty collection shouldn't contain element[" + i + "]",getCollection().contains(elements[i]));

  }

  verify();

  resetFull();

  elements=getFullElements();

  for (int i=0; i < elements.length; i++) {

    assertTrue("Full collection should contain element[" + i + "]",getCollection().contains(elements[i]));

  }

  verify();

  resetFull();

  elements=getOtherElements();

  for (  final Object element : elements) {

    assertFalse("Full collection shouldn't contain element",getCollection().contains(element));

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#containsAll(Collection)}.

 */

public void testCollectionContainsAll(){

  resetEmpty();

  Collection<E> col=new HashSet<>();

  assertTrue("Every Collection should contain all elements of an " + "empty Collection.",getCollection().containsAll(col));

  col.addAll(Arrays.asList(getOtherElements()));

  assertFalse("Empty Collection shouldn't contain all elements of " + "a non-empty Collection.",getCollection().containsAll(col));

  verify();

  resetFull();

  assertFalse("Full collection shouldn't contain other elements",getCollection().containsAll(col));

  col.clear();

  col.addAll(Arrays.asList(getFullElements()));

  assertTrue("Full collection should containAll full elements",getCollection().containsAll(col));

  verify();

  final int min=getFullElements().length < 4 ? 0 : 2;

  final int max=getFullElements().length == 1 ? 1 : getFullElements().length <= 5 ? getFullElements().length - 1 : 5;

  col=Arrays.asList(getFullElements()).subList(min,max);

  assertTrue("Full collection should containAll partial full elements",getCollection().containsAll(col));

  assertTrue("Full collection should containAll itself",getCollection().containsAll(getCollection()));

  verify();

  col=new ArrayList<>(Arrays.asList(getFullElements()));

  col.addAll(Arrays.asList(getFullElements()));

  assertTrue("Full collection should containAll duplicate full elements",getCollection().containsAll(col));

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#isEmpty()}.

 */

public void testCollectionIsEmpty(){

  resetEmpty();

  assertTrue("New Collection should be empty.",getCollection().isEmpty());

  verify();

  resetFull();

  assertFalse("Full collection shouldn't be empty",getCollection().isEmpty());

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests the read-only functionality of  {@link Collection#iterator()}.

 */

public void testCollectionIterator(){

  resetEmpty();

  Iterator<E> it1=getCollection().iterator();

  assertFalse("Iterator for empty Collection shouldn't have next.",it1.hasNext());

  try {

    it1.next();

    fail("Iterator at end of Collection should throw " + "NoSuchElementException when next is called.");

  }

 catch (  final NoSuchElementException e) {

  }

  verify();

  resetFull();

  it1=getCollection().iterator();

  for (  final E element : getCollection()) {

    assertTrue("Iterator for full collection should haveNext",it1.hasNext());

    it1.next();

  }

  assertFalse("Iterator should be finished",it1.hasNext());

  final ArrayList<E> list=new ArrayList<>();

  it1=getCollection().iterator();

  for (int i=0; i < getCollection().size(); i++) {

    final E next=it1.next();

    assertTrue("Collection should contain element returned by its iterator",getCollection().contains(next));

    list.add(next);

  }

  try {

    it1.next();

    fail("iterator.next() should raise NoSuchElementException after it finishes");

  }

 catch (  final NoSuchElementException e) {

  }

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests that the collection's iterator is fail-fast.

 */

public void testCollectionIteratorFailFast(){

  if (!isFailFastSupported()) {

    return;

  }

  if (isAddSupported()) {

    resetFull();

    try {

      final Iterator<E> iter=getCollection().iterator();

      final E o=getOtherElements()[0];

      getCollection().add(o);

      getConfirmed().add(o);

      iter.next();

      fail("next after add should raise ConcurrentModification");

    }

 catch (    final ConcurrentModificationException e) {

    }

    verify();

    resetFull();

    try {

      final Iterator<E> iter=getCollection().iterator();

      getCollection().addAll(Arrays.asList(getOtherElements()));

      getConfirmed().addAll(Arrays.asList(getOtherElements()));

      iter.next();

      fail("next after addAll should raise ConcurrentModification");

    }

 catch (    final ConcurrentModificationException e) {

    }

    verify();

  }

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    getCollection().clear();

    iter.next();

    fail("next after clear should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException|NoSuchElementException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    getCollection().remove(getFullElements()[0]);

    iter.next();

    fail("next after remove should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    getCollection().removeIf(e -> false);

    iter.next();

    fail("next after removeIf should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    final List<E> sublist=Arrays.asList(getFullElements()).subList(2,5);

    getCollection().removeAll(sublist);

    iter.next();

    fail("next after removeAll should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    final List<E> sublist=Arrays.asList(getFullElements()).subList(2,5);

    getCollection().retainAll(sublist);

    iter.next();

    fail("next after retainAll should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#remove(Object)}.

 */

public void testCollectionRemove(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  final E[] elements=getFullElements();

  for (  final E element : elements) {

    assertFalse("Shouldn't remove nonexistent element",getCollection().remove(element));

    verify();

  }

  final E[] other=getOtherElements();

  resetFull();

  for (  final E element : other) {

    assertFalse("Shouldn't remove nonexistent other element",getCollection().remove(element));

    verify();

  }

  final int size=getCollection().size();

  for (  final E element : elements) {

    resetFull();

    assertTrue("Collection should remove extant element: " + element,getCollection().remove(element));

    if (!areEqualElementsDistinguishable()) {

      getConfirmed().remove(element);

      verify();

    }

    assertEquals("Collection should shrink after remove",size - 1,getCollection().size());

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#removeAll(Collection)}.

 */

public void testCollectionRemoveAll(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  assertFalse("Empty collection removeAll should return false for empty input",getCollection().removeAll(Collections.EMPTY_SET));

  verify();

  assertFalse("Empty collection removeAll should return false for nonempty input",getCollection().removeAll(new ArrayList<>(getCollection())));

  verify();

  resetFull();

  assertFalse("Full collection removeAll should return false for empty input",getCollection().removeAll(Collections.EMPTY_SET));

  verify();

  assertFalse("Full collection removeAll should return false for other elements",getCollection().removeAll(Arrays.asList(getOtherElements())));

  verify();

  assertTrue("Full collection removeAll should return true for full elements",getCollection().removeAll(new HashSet<>(getCollection())));

  getConfirmed().removeAll(new HashSet<>(getConfirmed()));

  verify();

  resetFull();

  final int size=getCollection().size();

  final int min=getFullElements().length < 4 ? 0 : 2;

  final int max=getFullElements().length == 1 ? 1 : getFullElements().length <= 5 ? getFullElements().length - 1 : 5;

  final Collection<E> all=Arrays.asList(getFullElements()).subList(min,max);

  assertTrue("Full collection removeAll should work",getCollection().removeAll(all));

  getConfirmed().removeAll(all);

  verify();

  assertTrue("Collection should shrink after removeAll",getCollection().size() < size);

  for (  final E element : all) {

    assertFalse("Collection shouldn't contain removed element",getCollection().contains(element));

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#removeIf(Predicate)}.

 * @since 4.4

 */

public void testCollectionRemoveIf(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  assertFalse("Empty collection removeIf should return false for a predicate that returns only false",getCollection().removeIf(e -> false));

  verify();

  assertFalse("Empty collection removeIf should return false for a predicate that returns only true",getCollection().removeIf(e -> true));

  verify();

  resetFull();

  assertFalse("Full collection removeIf should return false for a predicate that returns only false",getCollection().removeIf(e -> false));

  verify();

  assertTrue("Full collection removeIf should return true for a predicate that returns only true",getCollection().removeIf(e -> true));

  getConfirmed().removeIf(e -> true);

  verify();

  resetFull();

  final List<E> elements=Arrays.asList(getFullElements());

  final int mid=getFullElements().length / 2;

  final E target=elements.get(mid);

  final int size=getCollection().size();

  final int targetCount=Collections.frequency(elements,target);

  final Predicate<E> filter=e -> target.equals(e);

  assertTrue("Full collection removeIf should work",getCollection().removeIf(filter));

  getConfirmed().removeIf(filter);

  verify();

  assertEquals("Collection should shrink after removeIf",getCollection().size(),size - targetCount);

  assertFalse("Collection shouldn't contain removed element",getCollection().contains(target));

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#retainAll(Collection)}.

 */

public void testCollectionRetainAll(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  final List<E> elements=Arrays.asList(getFullElements());

  final List<E> other=Arrays.asList(getOtherElements());

  assertFalse("Empty retainAll() should return false",getCollection().retainAll(Collections.EMPTY_SET));

  verify();

  assertFalse("Empty retainAll() should return false",getCollection().retainAll(elements));

  verify();

  resetFull();

  assertTrue("Collection should change from retainAll empty",getCollection().retainAll(Collections.EMPTY_SET));

  getConfirmed().retainAll(Collections.EMPTY_SET);

  verify();

  resetFull();

  assertTrue("Collection changed from retainAll other",getCollection().retainAll(other));

  getConfirmed().retainAll(other);

  verify();

  resetFull();

  int size=getCollection().size();

  assertFalse("Collection shouldn't change from retainAll elements",getCollection().retainAll(elements));

  verify();

  assertEquals("Collection size shouldn't change",size,getCollection().size());

  if (getFullElements().length > 1) {

    resetFull();

    size=getCollection().size();

    final int min=getFullElements().length < 4 ? 0 : 2;

    final int max=getFullElements().length <= 5 ? getFullElements().length - 1 : 5;

    assertTrue("Collection should changed by partial retainAll",getCollection().retainAll(elements.subList(min,max)));

    getConfirmed().retainAll(elements.subList(min,max));

    verify();

    for (    final E element : getCollection()) {

      assertTrue("Collection only contains retained element",elements.subList(min,max).contains(element));

    }

  }

  resetFull();

  final HashSet<E> set=new HashSet<>(elements);

  size=getCollection().size();

  assertFalse("Collection shouldn't change from retainAll without " + "duplicate elements",getCollection().retainAll(set));

  verify();

  assertEquals("Collection size didn't change from nonduplicate " + "retainAll",size,getCollection().size());

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#size()}.

 */

public void testCollectionSize(){

  resetEmpty();

  assertEquals("Size of new Collection is 0.",0,getCollection().size());

  resetFull();

  assertFalse("Size of full collection should be greater than zero",getCollection().isEmpty());

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#toArray()}.

 */

public void testCollectionToArray(){

  resetEmpty();

  assertEquals("Empty Collection should return empty array for toArray",0,getCollection().toArray().length);

  resetFull();

  final Object[] array=getCollection().toArray();

  assertEquals("Full collection toArray should be same size as collection",array.length,getCollection().size());

  final Object[] confirmedArray=getConfirmed().toArray();

  assertEquals("length of array from confirmed collection should " + "match the length of the collection's array",confirmedArray.length,array.length);

  final boolean[] matched=new boolean[array.length];

  for (int i=0; i < array.length; i++) {

    assertTrue("Collection should contain element in toArray",getCollection().contains(array[i]));

    boolean match=false;

    for (int j=0; j < array.length; j++) {

      if (matched[j]) {

        continue;

      }

      if (Objects.equals(array[i],confirmedArray[j])) {

        matched[j]=true;

        match=true;

        break;

      }

    }

    if (!match) {

      fail("element " + i + " in returned array should be found "+ "in the confirmed collection's array");

    }

  }

  for (  final boolean element : matched) {

    assertTrue("Collection should return all its elements in " + "toArray",element);

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#toArray(Object[])}.

 */

public void testCollectionToArray2(){

  resetEmpty();

  Object[] a=new Object[]{new Object(),null,null};

  Object[] array=getCollection().toArray(a);

  assertEquals("Given array shouldn't shrink",array,a);

  assertNull("Last element should be set to null",a[0]);

  verify();

  resetFull();

  try {

    array=getCollection().toArray(new Void[0]);

    fail("toArray(new Void[0]) should raise ArrayStore");

  }

 catch (  final ArrayStoreException e) {

  }

  verify();

  try {

    array=getCollection().toArray((Object[])null);

    fail("toArray(null) should raise NPE");

  }

 catch (  final NullPointerException e) {

  }

  verify();

  array=getCollection().toArray(new Object[0]);

  a=getCollection().toArray();

  assertEquals("toArrays should be equal",Arrays.asList(array),Arrays.asList(a));

  final HashSet<Class<?>> classes=new HashSet<>();

  for (  final Object element : array) {

    classes.add(element == null ? null : element.getClass());

  }

  if (classes.size() > 1) {

    return;

  }

  Class<?> cl=classes.iterator().next();

  if (Map.Entry.class.isAssignableFrom(cl)) {

    cl=Map.Entry.class;

  }

  a=(Object[])Array.newInstance(cl,0);

  array=getCollection().toArray(a);

  assertEquals("toArray(Object[]) should return correct array type",a.getClass(),array.getClass());

  assertEquals("type-specific toArrays should be equal",Arrays.asList(array),Arrays.asList(getCollection().toArray()));

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@code toString} on a collection.

 */

public void testCollectionToString(){

  resetEmpty();

  assertNotNull("toString shouldn't return null",getCollection().toString());

  resetFull();

  assertNotNull("toString shouldn't return null",getCollection().toString());

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * If  {@link #isAddSupported()} returns false, tests that add operationsraise <code>UnsupportedOperationException.

 */

public void testUnsupportedAdd(){

  if (isAddSupported()) {

    return;

  }

  resetEmpty();

  try {

    getCollection().add(getFullNonNullElements()[0]);

    fail("Empty collection should not support add.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

  try {

    getCollection().addAll(Arrays.asList(getFullElements()));

    fail("Empty collection should not support addAll.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

  resetFull();

  try {

    getCollection().add(getFullNonNullElements()[0]);

    fail("Full collection should not support add.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

  try {

    getCollection().addAll(Arrays.asList(getOtherElements()));

    fail("Full collection should not support addAll.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * JUnit constructor.

 * @param testName  the test class name

 */

public AbstractCollectionTest(final String testName){

  super(testName);

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle the optional exceptions declared by  {@link Collection#containsAll(Collection)}

 * @param coll

 * @param sub

 */

protected static void assertNotCollectionContainsAll(final Collection<?> coll,final Collection<?> sub){

  try {

    assertFalse(coll.containsAll(sub));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle the optional exceptions declared by  {@link Collection#contains(Object)}

 * @param coll

 * @param element

 */

protected static void assertNotCollectionContains(final Collection<?> coll,final Object element){

  try {

    assertFalse(coll.contains(element));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle optional exceptions of  {@link Collection#removeAll(Collection)}

 * @param coll

 * @param sub

 */

protected static void assertNotRemoveAllFromCollection(final Collection<?> coll,final Collection<?> sub){

  try {

    assertFalse(coll.removeAll(sub));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Handle optional exceptions of  {@link Collection#remove(Object)}

 * @param coll

 * @param element

 */

protected static void assertNotRemoveFromCollection(final Collection<?> coll,final Object element){

  try {

    assertFalse(coll.remove(element));

  }

 catch (  final ClassCastException|NullPointerException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Returns a list of string elements suitable for return by {@link #getFullElements()}.  Override getFullElements to return the results of this method if your collection does not support heterogenous elements or the null element.

 */

public Object[] getFullNonNullStringElements(){

  return new Object[]{"If","the","dull","substance","of","my","flesh","were","thought","Injurious","distance","could","not","stop","my","way"};

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Set the collection.

 * @param collection the Collection<E> to set

 */

public void setCollection(final Collection<E> collection){

  this.collection=collection;

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Set the confirmed.

 * @param confirmed the Collection<E> to set

 */

public void setConfirmed(final Collection<E> confirmed){

  this.confirmed=confirmed;

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#add(Object)}.

 */

public void testCollectionAdd(){

  if (!isAddSupported()) {

    return;

  }

  final E[] elements=getFullElements();

  for (  final E element : elements) {

    resetEmpty();

    final boolean r=getCollection().add(element);

    getConfirmed().add(element);

    verify();

    assertTrue("Empty collection changed after add",r);

    assertEquals("Collection size is 1 after first add",1,getCollection().size());

  }

  resetEmpty();

  int size=0;

  for (  final E element : elements) {

    final boolean r=getCollection().add(element);

    getConfirmed().add(element);

    verify();

    if (r) {

      size++;

    }

    assertEquals("Collection size should grow after add",size,getCollection().size());

    assertTrue("Collection should contain added element",getCollection().contains(element));

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Test  {@link Collection#clear()}.

 */

public void testCollectionClear(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  getCollection().clear();

  verify();

  resetFull();

  getCollection().clear();

  getConfirmed().clear();

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#contains(Object)}.

 */

public void testCollectionContains(){

  Object[] elements;

  resetEmpty();

  elements=getFullElements();

  for (int i=0; i < elements.length; i++) {

    assertFalse("Empty collection shouldn't contain element[" + i + "]",getCollection().contains(elements[i]));

  }

  verify();

  elements=getOtherElements();

  for (int i=0; i < elements.length; i++) {

    assertFalse("Empty collection shouldn't contain element[" + i + "]",getCollection().contains(elements[i]));

  }

  verify();

  resetFull();

  elements=getFullElements();

  for (int i=0; i < elements.length; i++) {

    assertTrue("Full collection should contain element[" + i + "]",getCollection().contains(elements[i]));

  }

  verify();

  resetFull();

  elements=getOtherElements();

  for (  final Object element : elements) {

    assertFalse("Full collection shouldn't contain element",getCollection().contains(element));

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#containsAll(Collection)}.

 */

public void testCollectionContainsAll(){

  resetEmpty();

  Collection<E> col=new HashSet<>();

  assertTrue("Every Collection should contain all elements of an " + "empty Collection.",getCollection().containsAll(col));

  col.addAll(Arrays.asList(getOtherElements()));

  assertFalse("Empty Collection shouldn't contain all elements of " + "a non-empty Collection.",getCollection().containsAll(col));

  verify();

  resetFull();

  assertFalse("Full collection shouldn't contain other elements",getCollection().containsAll(col));

  col.clear();

  col.addAll(Arrays.asList(getFullElements()));

  assertTrue("Full collection should containAll full elements",getCollection().containsAll(col));

  verify();

  final int min=getFullElements().length < 4 ? 0 : 2;

  final int max=getFullElements().length == 1 ? 1 : getFullElements().length <= 5 ? getFullElements().length - 1 : 5;

  col=Arrays.asList(getFullElements()).subList(min,max);

  assertTrue("Full collection should containAll partial full elements",getCollection().containsAll(col));

  assertTrue("Full collection should containAll itself",getCollection().containsAll(getCollection()));

  verify();

  col=new ArrayList<>(Arrays.asList(getFullElements()));

  col.addAll(Arrays.asList(getFullElements()));

  assertTrue("Full collection should containAll duplicate full elements",getCollection().containsAll(col));

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#isEmpty()}.

 */

public void testCollectionIsEmpty(){

  resetEmpty();

  assertTrue("New Collection should be empty.",getCollection().isEmpty());

  verify();

  resetFull();

  assertFalse("Full collection shouldn't be empty",getCollection().isEmpty());

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests the read-only functionality of  {@link Collection#iterator()}.

 */

public void testCollectionIterator(){

  resetEmpty();

  Iterator<E> it1=getCollection().iterator();

  assertFalse("Iterator for empty Collection shouldn't have next.",it1.hasNext());

  try {

    it1.next();

    fail("Iterator at end of Collection should throw " + "NoSuchElementException when next is called.");

  }

 catch (  final NoSuchElementException e) {

  }

  verify();

  resetFull();

  it1=getCollection().iterator();

  for (  final E element : getCollection()) {

    assertTrue("Iterator for full collection should haveNext",it1.hasNext());

    it1.next();

  }

  assertFalse("Iterator should be finished",it1.hasNext());

  final ArrayList<E> list=new ArrayList<>();

  it1=getCollection().iterator();

  for (int i=0; i < getCollection().size(); i++) {

    final E next=it1.next();

    assertTrue("Collection should contain element returned by its iterator",getCollection().contains(next));

    list.add(next);

  }

  try {

    it1.next();

    fail("iterator.next() should raise NoSuchElementException after it finishes");

  }

 catch (  final NoSuchElementException e) {

  }

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests that the collection's iterator is fail-fast.

 */

public void testCollectionIteratorFailFast(){

  if (!isFailFastSupported()) {

    return;

  }

  if (isAddSupported()) {

    resetFull();

    try {

      final Iterator<E> iter=getCollection().iterator();

      final E o=getOtherElements()[0];

      getCollection().add(o);

      getConfirmed().add(o);

      iter.next();

      fail("next after add should raise ConcurrentModification");

    }

 catch (    final ConcurrentModificationException e) {

    }

    verify();

    resetFull();

    try {

      final Iterator<E> iter=getCollection().iterator();

      getCollection().addAll(Arrays.asList(getOtherElements()));

      getConfirmed().addAll(Arrays.asList(getOtherElements()));

      iter.next();

      fail("next after addAll should raise ConcurrentModification");

    }

 catch (    final ConcurrentModificationException e) {

    }

    verify();

  }

  if (!isRemoveSupported()) {

    return;

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    getCollection().clear();

    iter.next();

    fail("next after clear should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException|NoSuchElementException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    getCollection().remove(getFullElements()[0]);

    iter.next();

    fail("next after remove should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    getCollection().removeIf(e -> false);

    iter.next();

    fail("next after removeIf should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    final List<E> sublist=Arrays.asList(getFullElements()).subList(2,5);

    getCollection().removeAll(sublist);

    iter.next();

    fail("next after removeAll should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

  resetFull();

  try {

    final Iterator<E> iter=getCollection().iterator();

    final List<E> sublist=Arrays.asList(getFullElements()).subList(2,5);

    getCollection().retainAll(sublist);

    iter.next();

    fail("next after retainAll should raise ConcurrentModification");

  }

 catch (  final ConcurrentModificationException e) {

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#remove(Object)}.

 */

public void testCollectionRemove(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  final E[] elements=getFullElements();

  for (  final E element : elements) {

    assertFalse("Shouldn't remove nonexistent element",getCollection().remove(element));

    verify();

  }

  final E[] other=getOtherElements();

  resetFull();

  for (  final E element : other) {

    assertFalse("Shouldn't remove nonexistent other element",getCollection().remove(element));

    verify();

  }

  final int size=getCollection().size();

  for (  final E element : elements) {

    resetFull();

    assertTrue("Collection should remove extant element: " + element,getCollection().remove(element));

    if (!areEqualElementsDistinguishable()) {

      getConfirmed().remove(element);

      verify();

    }

    assertEquals("Collection should shrink after remove",size - 1,getCollection().size());

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#removeAll(Collection)}.

 */

public void testCollectionRemoveAll(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  assertFalse("Empty collection removeAll should return false for empty input",getCollection().removeAll(Collections.EMPTY_SET));

  verify();

  assertFalse("Empty collection removeAll should return false for nonempty input",getCollection().removeAll(new ArrayList<>(getCollection())));

  verify();

  resetFull();

  assertFalse("Full collection removeAll should return false for empty input",getCollection().removeAll(Collections.EMPTY_SET));

  verify();

  assertFalse("Full collection removeAll should return false for other elements",getCollection().removeAll(Arrays.asList(getOtherElements())));

  verify();

  assertTrue("Full collection removeAll should return true for full elements",getCollection().removeAll(new HashSet<>(getCollection())));

  getConfirmed().removeAll(new HashSet<>(getConfirmed()));

  verify();

  resetFull();

  final int size=getCollection().size();

  final int min=getFullElements().length < 4 ? 0 : 2;

  final int max=getFullElements().length == 1 ? 1 : getFullElements().length <= 5 ? getFullElements().length - 1 : 5;

  final Collection<E> all=Arrays.asList(getFullElements()).subList(min,max);

  assertTrue("Full collection removeAll should work",getCollection().removeAll(all));

  getConfirmed().removeAll(all);

  verify();

  assertTrue("Collection should shrink after removeAll",getCollection().size() < size);

  for (  final E element : all) {

    assertFalse("Collection shouldn't contain removed element",getCollection().contains(element));

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#removeIf(Predicate)}.

 * @since 4.4

 */

public void testCollectionRemoveIf(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  assertFalse("Empty collection removeIf should return false for a predicate that returns only false",getCollection().removeIf(e -> false));

  verify();

  assertFalse("Empty collection removeIf should return false for a predicate that returns only true",getCollection().removeIf(e -> true));

  verify();

  resetFull();

  assertFalse("Full collection removeIf should return false for a predicate that returns only false",getCollection().removeIf(e -> false));

  verify();

  assertTrue("Full collection removeIf should return true for a predicate that returns only true",getCollection().removeIf(e -> true));

  getConfirmed().removeIf(e -> true);

  verify();

  resetFull();

  final List<E> elements=Arrays.asList(getFullElements());

  final int mid=getFullElements().length / 2;

  final E target=elements.get(mid);

  final int size=getCollection().size();

  final int targetCount=Collections.frequency(elements,target);

  final Predicate<E> filter=e -> target.equals(e);

  assertTrue("Full collection removeIf should work",getCollection().removeIf(filter));

  getConfirmed().removeIf(filter);

  verify();

  assertEquals("Collection should shrink after removeIf",getCollection().size(),size - targetCount);

  assertFalse("Collection shouldn't contain removed element",getCollection().contains(target));

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#retainAll(Collection)}.

 */

public void testCollectionRetainAll(){

  if (!isRemoveSupported()) {

    return;

  }

  resetEmpty();

  final List<E> elements=Arrays.asList(getFullElements());

  final List<E> other=Arrays.asList(getOtherElements());

  assertFalse("Empty retainAll() should return false",getCollection().retainAll(Collections.EMPTY_SET));

  verify();

  assertFalse("Empty retainAll() should return false",getCollection().retainAll(elements));

  verify();

  resetFull();

  assertTrue("Collection should change from retainAll empty",getCollection().retainAll(Collections.EMPTY_SET));

  getConfirmed().retainAll(Collections.EMPTY_SET);

  verify();

  resetFull();

  assertTrue("Collection changed from retainAll other",getCollection().retainAll(other));

  getConfirmed().retainAll(other);

  verify();

  resetFull();

  int size=getCollection().size();

  assertFalse("Collection shouldn't change from retainAll elements",getCollection().retainAll(elements));

  verify();

  assertEquals("Collection size shouldn't change",size,getCollection().size());

  if (getFullElements().length > 1) {

    resetFull();

    size=getCollection().size();

    final int min=getFullElements().length < 4 ? 0 : 2;

    final int max=getFullElements().length <= 5 ? getFullElements().length - 1 : 5;

    assertTrue("Collection should changed by partial retainAll",getCollection().retainAll(elements.subList(min,max)));

    getConfirmed().retainAll(elements.subList(min,max));

    verify();

    for (    final E element : getCollection()) {

      assertTrue("Collection only contains retained element",elements.subList(min,max).contains(element));

    }

  }

  resetFull();

  final HashSet<E> set=new HashSet<>(elements);

  size=getCollection().size();

  assertFalse("Collection shouldn't change from retainAll without " + "duplicate elements",getCollection().retainAll(set));

  verify();

  assertEquals("Collection size didn't change from nonduplicate " + "retainAll",size,getCollection().size());

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#size()}.

 */

public void testCollectionSize(){

  resetEmpty();

  assertEquals("Size of new Collection is 0.",0,getCollection().size());

  resetFull();

  assertFalse("Size of full collection should be greater than zero",getCollection().isEmpty());

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#toArray()}.

 */

public void testCollectionToArray(){

  resetEmpty();

  assertEquals("Empty Collection should return empty array for toArray",0,getCollection().toArray().length);

  resetFull();

  final Object[] array=getCollection().toArray();

  assertEquals("Full collection toArray should be same size as collection",array.length,getCollection().size());

  final Object[] confirmedArray=getConfirmed().toArray();

  assertEquals("length of array from confirmed collection should " + "match the length of the collection's array",confirmedArray.length,array.length);

  final boolean[] matched=new boolean[array.length];

  for (int i=0; i < array.length; i++) {

    assertTrue("Collection should contain element in toArray",getCollection().contains(array[i]));

    boolean match=false;

    for (int j=0; j < array.length; j++) {

      if (matched[j]) {

        continue;

      }

      if (Objects.equals(array[i],confirmedArray[j])) {

        matched[j]=true;

        match=true;

        break;

      }

    }

    if (!match) {

      fail("element " + i + " in returned array should be found "+ "in the confirmed collection's array");

    }

  }

  for (  final boolean element : matched) {

    assertTrue("Collection should return all its elements in " + "toArray",element);

  }

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@link Collection#toArray(Object[])}.

 */

public void testCollectionToArray2(){

  resetEmpty();

  Object[] a=new Object[]{new Object(),null,null};

  Object[] array=getCollection().toArray(a);

  assertEquals("Given array shouldn't shrink",array,a);

  assertNull("Last element should be set to null",a[0]);

  verify();

  resetFull();

  try {

    array=getCollection().toArray(new Void[0]);

    fail("toArray(new Void[0]) should raise ArrayStore");

  }

 catch (  final ArrayStoreException e) {

  }

  verify();

  try {

    array=getCollection().toArray((Object[])null);

    fail("toArray(null) should raise NPE");

  }

 catch (  final NullPointerException e) {

  }

  verify();

  array=getCollection().toArray(new Object[0]);

  a=getCollection().toArray();

  assertEquals("toArrays should be equal",Arrays.asList(array),Arrays.asList(a));

  final HashSet<Class<?>> classes=new HashSet<>();

  for (  final Object element : array) {

    classes.add(element == null ? null : element.getClass());

  }

  if (classes.size() > 1) {

    return;

  }

  Class<?> cl=classes.iterator().next();

  if (Map.Entry.class.isAssignableFrom(cl)) {

    cl=Map.Entry.class;

  }

  a=(Object[])Array.newInstance(cl,0);

  array=getCollection().toArray(a);

  assertEquals("toArray(Object[]) should return correct array type",a.getClass(),array.getClass());

  assertEquals("type-specific toArrays should be equal",Arrays.asList(array),Arrays.asList(getCollection().toArray()));

  verify();

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * Tests  {@code toString} on a collection.

 */

public void testCollectionToString(){

  resetEmpty();

  assertNotNull("toString shouldn't return null",getCollection().toString());

  resetFull();

  assertNotNull("toString shouldn't return null",getCollection().toString());

}

Location: AbstractCollectionTest.java

Content: 

/** 

 * If  {@link #isAddSupported()} returns false, tests that add operationsraise <code>UnsupportedOperationException.

 */

public void testUnsupportedAdd(){

  if (isAddSupported()) {

    return;

  }

  resetEmpty();

  try {

    getCollection().add(getFullNonNullElements()[0]);

    fail("Empty collection should not support add.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

  try {

    getCollection().addAll(Arrays.asList(getFullElements()));

    fail("Empty collection should not support addAll.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

  resetFull();

  try {

    getCollection().add(getFullNonNullElements()[0]);

    fail("Full collection should not support add.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

  try {

    getCollection().addAll(Arrays.asList(getOtherElements()));

    fail("Full collection should not support addAll.");

  }

 catch (  final UnsupportedOperationException e) {

  }

  verify();

}

