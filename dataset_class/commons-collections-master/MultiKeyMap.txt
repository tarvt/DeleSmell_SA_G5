Location: MultiKeyMap.java

Content: 

/** 

 * Check to ensure that input keys are valid MultiKey objects.

 * @param key  the key to check

 */

protected void checkKey(final MultiKey<?> key){

  Objects.requireNonNull(key,"key");

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2){

  final int hashCode=hash(key1,key2);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2,final Object key3){

  final int hashCode=hash(key1,key2,key3);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2,final Object key3,final Object key4){

  final int hashCode=hash(key1,key2,key3,key4);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2){

  final int hashCode=hash(key1,key2);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2,final Object key3){

  final int hashCode=hash(key1,key2,key3);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2,final Object key3,final Object key4){

  final int hashCode=hash(key1,key2,key3,key4);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2,final Object key3){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  if (key3 != null) {

    h^=key3.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2,final Object key3,final Object key4){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  if (key3 != null) {

    h^=key3.hashCode();

  }

  if (key4 != null) {

    h^=key4.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  if (key3 != null) {

    h^=key3.hashCode();

  }

  if (key4 != null) {

    h^=key4.hashCode();

  }

  if (key5 != null) {

    h^=key5.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 2 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2,final Object key3){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 3 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) && (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2,final Object key3,final Object key4){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 4 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) && (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) && (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 5 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) && (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) && (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3))) && (key5 == multi.getKey(4) || key5 != null && key5.equals(multi.getKey(4)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Constructs a new MultiKeyMap that decorates a  {@code HashedMap}.

 */

public MultiKeyMap(){

  this(new HashedMap<MultiKey<? extends K>,V>());

}

Location: MultiKeyMap.java

Content: 

/** 

 * Constructor that decorates the specified map and is called from {@link #multiKeyMap(AbstractHashedMap)}. The map must not be null and should be empty or only contain valid keys. This constructor performs no validation.

 * @param map  the map to decorate

 */

protected MultiKeyMap(final AbstractHashedMap<MultiKey<? extends K>,V> map){

  super(map);

  this.map=map;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final K key3,final K key4,final K key5,final V value){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2,key3,key4,key5),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final K key3,final K key4,final V value){

  final int hashCode=hash(key1,key2,key3,key4);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2,key3,key4),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final K key3,final V value){

  final int hashCode=hash(key1,key2,key3);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2,key3),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final V value){

  final int hashCode=hash(key1,key2);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Puts the key and value into the map, where the key must be a non-null MultiKey object.

 * @param key  the non-null MultiKey object

 * @param value  the value to store

 * @return the previous value for the key

 * @throws NullPointerException if the key is null

 * @throws ClassCastException if the key is not a MultiKey

 */

@Override public V put(final MultiKey<? extends K> key,final V value){

  checkKey(key);

  return super.put(key,value);

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first key is that specified. <p> This method removes all the mappings where the  {@code MultiKey}has one or more keys, and the first matches that specified.

 * @param key1  the first key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 1 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first two keys are those specified. <p> This method removes all the mappings where the  {@code MultiKey}has two or more keys, and the first two match those specified.

 * @param key1  the first key

 * @param key2  the second key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1,final Object key2){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 2 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) && (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first three keys are those specified. <p> This method removes all the mappings where the  {@code MultiKey}has three or more keys, and the first three match those specified.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1,final Object key2,final Object key3){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 3 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) && (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) && (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first four keys are those specified. <p> This method removes all the mappings where the  {@code MultiKey}has four or more keys, and the first four match those specified.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1,final Object key2,final Object key3,final Object key4){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 4 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) && (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) && (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) && (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2){

  final int hashCode=hash(key1,key2);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2,final Object key3){

  final int hashCode=hash(key1,key2,key3);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object, Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2,final Object key3,final Object key4){

  final int hashCode=hash(key1,key2,key3,key4);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object, Object, Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Check to ensure that input keys are valid MultiKey objects.

 * @param key  the key to check

 */

protected void checkKey(final MultiKey<?> key){

  Objects.requireNonNull(key,"key");

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2){

  final int hashCode=hash(key1,key2);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2,final Object key3){

  final int hashCode=hash(key1,key2,key3);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2,final Object key3,final Object key4){

  final int hashCode=hash(key1,key2,key3,key4);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Checks whether the map contains the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return true if the map contains the key

 */

public boolean containsKey(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      return true;

    }

    entry=entry.next;

  }

  return false;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2){

  final int hashCode=hash(key1,key2);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2,final Object key3){

  final int hashCode=hash(key1,key2,key3);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2,final Object key3,final Object key4){

  final int hashCode=hash(key1,key2,key3,key4);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the value mapped to the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return the mapped value, null if no match

 */

public V get(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[decorated().hashIndex(hashCode,decorated().data.length)];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      return entry.getValue();

    }

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2,final Object key3){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  if (key3 != null) {

    h^=key3.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2,final Object key3,final Object key4){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  if (key3 != null) {

    h^=key3.hashCode();

  }

  if (key4 != null) {

    h^=key4.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Gets the hash code for the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return the hash code

 */

protected int hash(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  int h=0;

  if (key1 != null) {

    h^=key1.hashCode();

  }

  if (key2 != null) {

    h^=key2.hashCode();

  }

  if (key3 != null) {

    h^=key3.hashCode();

  }

  if (key4 != null) {

    h^=key4.hashCode();

  }

  if (key5 != null) {

    h^=key5.hashCode();

  }

  h+=~(h << 9);

  h^=h >>> 14;

  h+=h << 4;

  h^=h >>> 10;

  return h;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 2 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2,final Object key3){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 3 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) && (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2,final Object key3,final Object key4){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 4 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) && (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) && (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Is the key equal to the combined key.

 * @param entry  the entry to compare to

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return true if the key matches

 */

protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry,final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final MultiKey<? extends K> multi=entry.getKey();

  return multi.size() == 5 && (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) && (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) && (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) && (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3))) && (key5 == multi.getKey(4) || key5 != null && key5.equals(multi.getKey(4)));

}

Location: MultiKeyMap.java

Content: 

/** 

 * Constructs a new MultiKeyMap that decorates a  {@code HashedMap}.

 */

public MultiKeyMap(){

  this(new HashedMap<MultiKey<? extends K>,V>());

}

Location: MultiKeyMap.java

Content: 

/** 

 * Constructor that decorates the specified map and is called from {@link #multiKeyMap(AbstractHashedMap)}. The map must not be null and should be empty or only contain valid keys. This constructor performs no validation.

 * @param map  the map to decorate

 */

protected MultiKeyMap(final AbstractHashedMap<MultiKey<? extends K>,V> map){

  super(map);

  this.map=map;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final K key3,final K key4,final K key5,final V value){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2,key3,key4,key5),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final K key3,final K key4,final V value){

  final int hashCode=hash(key1,key2,key3,key4);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2,key3,key4),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final K key3,final V value){

  final int hashCode=hash(key1,key2,key3);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2,key3),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Stores the value against the specified multi-key.

 * @param key1  the first key

 * @param key2  the second key

 * @param value  the value to store

 * @return the value previously mapped to this combined key, null if none

 */

public V put(final K key1,final K key2,final V value){

  final int hashCode=hash(key1,key2);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      final V oldValue=entry.getValue();

      decorated().updateEntry(entry,value);

      return oldValue;

    }

    entry=entry.next;

  }

  decorated().addMapping(index,hashCode,new MultiKey<>(key1,key2),value);

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Puts the key and value into the map, where the key must be a non-null MultiKey object.

 * @param key  the non-null MultiKey object

 * @param value  the value to store

 * @return the previous value for the key

 * @throws NullPointerException if the key is null

 * @throws ClassCastException if the key is not a MultiKey

 */

@Override public V put(final MultiKey<? extends K> key,final V value){

  checkKey(key);

  return super.put(key,value);

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first key is that specified. <p> This method removes all the mappings where the  {@code MultiKey}has one or more keys, and the first matches that specified.

 * @param key1  the first key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 1 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first two keys are those specified. <p> This method removes all the mappings where the  {@code MultiKey}has two or more keys, and the first two match those specified.

 * @param key1  the first key

 * @param key2  the second key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1,final Object key2){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 2 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) && (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first three keys are those specified. <p> This method removes all the mappings where the  {@code MultiKey}has three or more keys, and the first three match those specified.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1,final Object key2,final Object key3){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 3 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) && (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) && (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes all mappings where the first four keys are those specified. <p> This method removes all the mappings where the  {@code MultiKey}has four or more keys, and the first four match those specified.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return true if any elements were removed

 */

public boolean removeAll(final Object key1,final Object key2,final Object key3,final Object key4){

  boolean modified=false;

  final MapIterator<MultiKey<? extends K>,V> it=mapIterator();

  while (it.hasNext()) {

    final MultiKey<? extends K> multi=it.next();

    if (multi.size() >= 4 && (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) && (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) && (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) && (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)))) {

      it.remove();

      modified=true;

    }

  }

  return modified;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2){

  final int hashCode=hash(key1,key2);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2,final Object key3){

  final int hashCode=hash(key1,key2,key3);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object, Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2,final Object key3,final Object key4){

  final int hashCode=hash(key1,key2,key3,key4);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

Location: MultiKeyMap.java

Content: 

/** 

 * Removes the specified multi-key from this map.

 * @param key1  the first key

 * @param key2  the second key

 * @param key3  the third key

 * @param key4  the fourth key

 * @param key5  the fifth key

 * @return the value mapped to the removed key, null if key not in map

 * @since 4.0 (previous name: remove(Object, Object, Object, Object, Object))

 */

public V removeMultiKey(final Object key1,final Object key2,final Object key3,final Object key4,final Object key5){

  final int hashCode=hash(key1,key2,key3,key4,key5);

  final int index=decorated().hashIndex(hashCode,decorated().data.length);

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> entry=decorated().data[index];

  AbstractHashedMap.HashEntry<MultiKey<? extends K>,V> previous=null;

  while (entry != null) {

    if (entry.hashCode == hashCode && isEqualKey(entry,key1,key2,key3,key4,key5)) {

      final V oldValue=entry.getValue();

      decorated().removeMapping(entry,index,previous);

      return oldValue;

    }

    previous=entry;

    entry=entry.next;

  }

  return null;

}

