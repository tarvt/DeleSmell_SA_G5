Location: TreeBidiMap.java

Content: 

/** 

 * Checks a key and a value for validity (non-null and implements Comparable)

 * @param key the key to be checked

 * @param value the value to be checked

 * @throws NullPointerException if key or value is null

 * @throws ClassCastException if key or value is not Comparable

 */

private static void checkKeyAndValue(final Object key,final Object value){

  checkKey(key);

  checkValue(value);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Checks a key for validity (non-null and implements Comparable)

 * @param key the key to be checked

 * @throws NullPointerException if key is null

 * @throws ClassCastException if key is not Comparable

 */

private static void checkKey(final Object key){

  checkNonNullComparable(key,KEY);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Checks if an object is fit to be proper input ... has to be Comparable and non-null.

 * @param obj the object being checked

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @throws NullPointerException if o is null

 * @throws ClassCastException if o is not Comparable

 */

private static void checkNonNullComparable(final Object obj,final DataElement dataElement){

  Objects.requireNonNull(obj,Objects.toString(dataElement));

  if (!(obj instanceof Comparable)) {

    throw new ClassCastException(dataElement + " must be Comparable");

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Checks a value for validity (non-null and implements Comparable)

 * @param value the value to be checked

 * @throws NullPointerException if value is null

 * @throws ClassCastException if value is not Comparable

 */

private static void checkValue(final Object value){

  checkNonNullComparable(value,VALUE);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Copies the color from one node to another, dealing with the fact that one or both nodes may, in fact, be null.

 * @param from the node whose color we're copying; may be null

 * @param to the node whose color we're changing; may be null

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private void copyColor(final Node<K,V> from,final Node<K,V> to,final DataElement dataElement){

  if (to != null) {

    if (from == null) {

      to.setBlack(dataElement);

    }

 else {

      to.copyColor(from,dataElement);

    }

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Compares for equals as per the API.

 * @param obj  the object to compare to

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return true if equal

 */

private boolean doEquals(final Object obj,final DataElement dataElement){

  if (obj == this) {

    return true;

  }

  if (!(obj instanceof Map)) {

    return false;

  }

  final Map<?,?> other=(Map<?,?>)obj;

  if (other.size() != size()) {

    return false;

  }

  if (nodeCount > 0) {

    try {

      for (final MapIterator<?,?> it=getMapIterator(dataElement); it.hasNext(); ) {

        final Object key=it.next();

        final Object value=it.getValue();

        if (!value.equals(other.get(key))) {

          return false;

        }

      }

    }

 catch (    final ClassCastException|NullPointerException ex) {

      return false;

    }

  }

  return true;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the hash code value for this map as per the API.

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the hash code value for this map

 */

private int doHashCode(final DataElement dataElement){

  int total=0;

  if (nodeCount > 0) {

    for (final MapIterator<?,?> it=getMapIterator(dataElement); it.hasNext(); ) {

      final Object key=it.next();

      final Object value=it.getValue();

      total+=key.hashCode() ^ value.hashCode();

    }

  }

  return total;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Puts logic.

 * @param key  the key, always the main map key

 * @param value  the value, always the main map value

 */

private void doPut(final K key,final V value){

  checkKeyAndValue(key,value);

  doRemoveKey(key);

  doRemoveValue(value);

  Node<K,V> node=rootNode[KEY.ordinal()];

  if (node == null) {

    final Node<K,V> root=new Node<>(key,value);

    rootNode[KEY.ordinal()]=root;

    rootNode[VALUE.ordinal()]=root;

    grow();

  }

 else {

    while (true) {

      final int cmp=compare(key,node.getKey());

      if (cmp == 0) {

        throw new IllegalArgumentException("Cannot store a duplicate key (\"" + key + "\") in this Map");

      }

      if (cmp < 0) {

        if (node.getLeft(KEY) == null) {

          final Node<K,V> newNode=new Node<>(key,value);

          insertValue(newNode);

          node.setLeft(newNode,KEY);

          newNode.setParent(node,KEY);

          doRedBlackInsert(newNode,KEY);

          grow();

          break;

        }

        node=node.getLeft(KEY);

      }

 else {

        if (node.getRight(KEY) == null) {

          final Node<K,V> newNode=new Node<>(key,value);

          insertValue(newNode);

          node.setRight(newNode,KEY);

          newNode.setParent(node,KEY);

          doRedBlackInsert(newNode,KEY);

          grow();

          break;

        }

        node=node.getRight(KEY);

      }

    }

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Complicated red-black delete stuff. Based on Sun's TreeMap implementation, though it's barely recognizable any more. This rebalances the tree (somewhat, as red-black trees are not perfectly balanced -- perfect balancing takes longer)

 * @param replacementNode the node being replaced

 * @param dataElement  the KEY or VALUE int

 */

private void doRedBlackDeleteFixup(final Node<K,V> replacementNode,final DataElement dataElement){

  Node<K,V> currentNode=replacementNode;

  while (currentNode != rootNode[dataElement.ordinal()] && isBlack(currentNode,dataElement)) {

    if (currentNode.isLeftChild(dataElement)) {

      Node<K,V> siblingNode=getRightChild(getParent(currentNode,dataElement),dataElement);

      if (isRed(siblingNode,dataElement)) {

        makeBlack(siblingNode,dataElement);

        makeRed(getParent(currentNode,dataElement),dataElement);

        rotateLeft(getParent(currentNode,dataElement),dataElement);

        siblingNode=getRightChild(getParent(currentNode,dataElement),dataElement);

      }

      if (isBlack(getLeftChild(siblingNode,dataElement),dataElement) && isBlack(getRightChild(siblingNode,dataElement),dataElement)) {

        makeRed(siblingNode,dataElement);

        currentNode=getParent(currentNode,dataElement);

      }

 else {

        if (isBlack(getRightChild(siblingNode,dataElement),dataElement)) {

          makeBlack(getLeftChild(siblingNode,dataElement),dataElement);

          makeRed(siblingNode,dataElement);

          rotateRight(siblingNode,dataElement);

          siblingNode=getRightChild(getParent(currentNode,dataElement),dataElement);

        }

        copyColor(getParent(currentNode,dataElement),siblingNode,dataElement);

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(getRightChild(siblingNode,dataElement),dataElement);

        rotateLeft(getParent(currentNode,dataElement),dataElement);

        currentNode=rootNode[dataElement.ordinal()];

      }

    }

 else {

      Node<K,V> siblingNode=getLeftChild(getParent(currentNode,dataElement),dataElement);

      if (isRed(siblingNode,dataElement)) {

        makeBlack(siblingNode,dataElement);

        makeRed(getParent(currentNode,dataElement),dataElement);

        rotateRight(getParent(currentNode,dataElement),dataElement);

        siblingNode=getLeftChild(getParent(currentNode,dataElement),dataElement);

      }

      if (isBlack(getRightChild(siblingNode,dataElement),dataElement) && isBlack(getLeftChild(siblingNode,dataElement),dataElement)) {

        makeRed(siblingNode,dataElement);

        currentNode=getParent(currentNode,dataElement);

      }

 else {

        if (isBlack(getLeftChild(siblingNode,dataElement),dataElement)) {

          makeBlack(getRightChild(siblingNode,dataElement),dataElement);

          makeRed(siblingNode,dataElement);

          rotateLeft(siblingNode,dataElement);

          siblingNode=getLeftChild(getParent(currentNode,dataElement),dataElement);

        }

        copyColor(getParent(currentNode,dataElement),siblingNode,dataElement);

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(getLeftChild(siblingNode,dataElement),dataElement);

        rotateRight(getParent(currentNode,dataElement),dataElement);

        currentNode=rootNode[dataElement.ordinal()];

      }

    }

  }

  makeBlack(currentNode,dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Complicated red-black delete stuff. Based on Sun's TreeMap implementation, though it's barely recognizable any more.

 * @param deletedNode the node to be deleted

 */

private void doRedBlackDelete(final Node<K,V> deletedNode){

  for (  final DataElement dataElement : DataElement.values()) {

    if (deletedNode.getLeft(dataElement) != null && deletedNode.getRight(dataElement) != null) {

      swapPosition(nextGreater(deletedNode,dataElement),deletedNode,dataElement);

    }

    final Node<K,V> replacement=deletedNode.getLeft(dataElement) != null ? deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);

    if (replacement != null) {

      replacement.setParent(deletedNode.getParent(dataElement),dataElement);

      if (deletedNode.getParent(dataElement) == null) {

        rootNode[dataElement.ordinal()]=replacement;

      }

 else       if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {

        deletedNode.getParent(dataElement).setLeft(replacement,dataElement);

      }

 else {

        deletedNode.getParent(dataElement).setRight(replacement,dataElement);

      }

      deletedNode.setLeft(null,dataElement);

      deletedNode.setRight(null,dataElement);

      deletedNode.setParent(null,dataElement);

      if (isBlack(deletedNode,dataElement)) {

        doRedBlackDeleteFixup(replacement,dataElement);

      }

    }

 else {

      if (deletedNode.getParent(dataElement) == null) {

        rootNode[dataElement.ordinal()]=null;

      }

 else {

        if (isBlack(deletedNode,dataElement)) {

          doRedBlackDeleteFixup(deletedNode,dataElement);

        }

        if (deletedNode.getParent(dataElement) != null) {

          if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {

            deletedNode.getParent(dataElement).setLeft(null,dataElement);

          }

 else {

            deletedNode.getParent(dataElement).setRight(null,dataElement);

          }

          deletedNode.setParent(null,dataElement);

        }

      }

    }

  }

  shrink();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Complicated red-black insert stuff. Based on Sun's TreeMap implementation, though it's barely recognizable any more.

 * @param insertedNode the node to be inserted

 * @param dataElement  the KEY or VALUE int

 */

private void doRedBlackInsert(final Node<K,V> insertedNode,final DataElement dataElement){

  Node<K,V> currentNode=insertedNode;

  makeRed(currentNode,dataElement);

  while (currentNode != null && currentNode != rootNode[dataElement.ordinal()] && isRed(currentNode.getParent(dataElement),dataElement)) {

    if (currentNode.isLeftChild(dataElement)) {

      final Node<K,V> y=getRightChild(getGrandParent(currentNode,dataElement),dataElement);

      if (isRed(y,dataElement)) {

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(y,dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        currentNode=getGrandParent(currentNode,dataElement);

      }

 else {

        if (currentNode.isRightChild(dataElement)) {

          currentNode=getParent(currentNode,dataElement);

          rotateLeft(currentNode,dataElement);

        }

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        if (getGrandParent(currentNode,dataElement) != null) {

          rotateRight(getGrandParent(currentNode,dataElement),dataElement);

        }

      }

    }

 else {

      final Node<K,V> y=getLeftChild(getGrandParent(currentNode,dataElement),dataElement);

      if (isRed(y,dataElement)) {

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(y,dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        currentNode=getGrandParent(currentNode,dataElement);

      }

 else {

        if (currentNode.isLeftChild(dataElement)) {

          currentNode=getParent(currentNode,dataElement);

          rotateRight(currentNode,dataElement);

        }

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        if (getGrandParent(currentNode,dataElement) != null) {

          rotateLeft(getGrandParent(currentNode,dataElement),dataElement);

        }

      }

    }

  }

  makeBlack(rootNode[dataElement.ordinal()],dataElement);

}

Location: TreeBidiMap.java

Content: 

private V doRemoveKey(final Object key){

  final Node<K,V> node=lookupKey(key);

  if (node == null) {

    return null;

  }

  doRedBlackDelete(node);

  return node.getValue();

}

Location: TreeBidiMap.java

Content: 

private K doRemoveValue(final Object value){

  final Node<K,V> node=lookupValue(value);

  if (node == null) {

    return null;

  }

  doRedBlackDelete(node);

  return node.getKey();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the string form of this map as per AbstractMap.

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the string form of this map

 */

private String doToString(final DataElement dataElement){

  if (nodeCount == 0) {

    return "{}";

  }

  final StringBuilder buf=new StringBuilder(nodeCount * 32);

  buf.append('{');

  final MapIterator<?,?> it=getMapIterator(dataElement);

  boolean hasNext=it.hasNext();

  while (hasNext) {

    final Object key=it.next();

    final Object value=it.getValue();

    buf.append(key == this ? "(this Map)" : key).append('=').append(value == this ? "(this Map)" : value);

    hasNext=it.hasNext();

    if (hasNext) {

      buf.append(", ");

    }

  }

  buf.append('}');

  return buf.toString();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's grandparent. mind you, the node, its parent, or its grandparent may not exist. No problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getGrandParent(final Node<K,V> node,final DataElement dataElement){

  return getParent(getParent(node,dataElement),dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Returns the key to which this map maps the specified value. Returns null if the map contains no mapping for this value. <p> The value must implement  {@code Comparable}.

 * @param value  value whose associated key is to be returned.

 * @return the key to which this map maps the specified value,or null if the map contains no mapping for this value.

 * @throws ClassCastException if the value is of an inappropriate type

 * @throws NullPointerException if the value is null

 */

@Override public K getKey(final Object value){

  checkValue(value);

  final Node<K,V> node=lookupValue(value);

  return node == null ? null : node.getKey();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's left child. mind you, the node may not exist. no problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getLeftChild(final Node<K,V> node,final DataElement dataElement){

  return node == null ? null : node.getLeft(dataElement);

}

Location: TreeBidiMap.java

Content: 

private MapIterator<?,?> getMapIterator(final DataElement dataElement){

switch (dataElement) {

case KEY:

    return new ViewMapIterator(KEY);

case VALUE:

  return new InverseViewMapIterator(VALUE);

default :

throw new IllegalArgumentException();

}

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's parent. mind you, the node, or its parent, may not exist. no problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getParent(final Node<K,V> node,final DataElement dataElement){

  return node == null ? null : node.getParent(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's right child. mind you, the node may not exist. no problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getRightChild(final Node<K,V> node,final DataElement dataElement){

  return node == null ? null : node.getRight(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Finds the greatest node from a given node.

 * @param node  the node from which we will start searching

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the greatest node, from the specified node

 */

private Node<K,V> greatestNode(final Node<K,V> node,final DataElement dataElement){

  Node<K,V> rval=node;

  if (rval != null) {

    while (rval.getRight(dataElement) != null) {

      rval=rval.getRight(dataElement);

    }

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Bumps up the size and note that the map has changed.

 */

private void grow(){

  modify();

  nodeCount++;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Inserts a node by its value.

 * @param newNode the node to be inserted

 * @throws IllegalArgumentException if the node already existsin the value mapping

 */

private void insertValue(final Node<K,V> newNode) throws IllegalArgumentException {

  Node<K,V> node=rootNode[VALUE.ordinal()];

  while (true) {

    final int cmp=compare(newNode.getValue(),node.getValue());

    if (cmp == 0) {

      throw new IllegalArgumentException("Cannot store a duplicate value (\"" + newNode.getData(VALUE) + "\") in this Map");

    }

    if (cmp < 0) {

      if (node.getLeft(VALUE) == null) {

        node.setLeft(newNode,VALUE);

        newNode.setParent(node,VALUE);

        doRedBlackInsert(newNode,VALUE);

        break;

      }

      node=node.getLeft(VALUE);

    }

 else {

      if (node.getRight(VALUE) == null) {

        node.setRight(newNode,VALUE);

        newNode.setParent(node,VALUE);

        doRedBlackInsert(newNode,VALUE);

        break;

      }

      node=node.getRight(VALUE);

    }

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the inverse map for comparison.

 * @return the inverse map

 */

@Override public OrderedBidiMap<V,K> inverseBidiMap(){

  if (inverse == null) {

    inverse=new Inverse();

  }

  return inverse;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Is the specified black red? If the node does not exist, sure, it's black, thank you.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static boolean isBlack(final Node<?,?> node,final DataElement dataElement){

  return node == null || node.isBlack(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Is the specified node red? If the node does not exist, no, it's black, thank you.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static boolean isRed(final Node<?,?> node,final DataElement dataElement){

  return node != null && node.isRed(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Finds the least node from a given node.

 * @param node  the node from which we will start searching

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the smallest node, from the specified node, in thespecified mapping

 */

private Node<K,V> leastNode(final Node<K,V> node,final DataElement dataElement){

  Node<K,V> rval=node;

  if (rval != null) {

    while (rval.getLeft(dataElement) != null) {

      rval=rval.getLeft(dataElement);

    }

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

private Node<K,V> lookupKey(final Object key){

  return this.<K>lookup(key,KEY);

}

Location: TreeBidiMap.java

Content: 

private Node<K,V> lookupValue(final Object value){

  return this.<V>lookup(value,VALUE);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Does the actual lookup of a piece of data.

 * @param data the key or value to be looked up

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the desired Node, or null if there is no mapping of thespecified data

 */

@SuppressWarnings("unchecked") private <T extends Comparable<T>>Node<K,V> lookup(final Object data,final DataElement dataElement){

  Node<K,V> rval=null;

  Node<K,V> node=rootNode[dataElement.ordinal()];

  while (node != null) {

    final int cmp=compare((T)data,(T)node.getData(dataElement));

    if (cmp == 0) {

      rval=node;

      break;

    }

    node=cmp < 0 ? node.getLeft(dataElement) : node.getRight(dataElement);

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Forces a node (if it exists) black.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static void makeBlack(final Node<?,?> node,final DataElement dataElement){

  if (node != null) {

    node.setBlack(dataElement);

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Forces a node (if it exists) red.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static void makeRed(final Node<?,?> node,final DataElement dataElement){

  if (node != null) {

    node.setRed(dataElement);

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Increments the modification count -- used to check for concurrent modification of the map through the map and through an Iterator from one of its Set or Collection views.

 */

private void modify(){

  modifications++;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the next larger node from the specified node.

 * @param node the node to be searched from

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the specified node

 */

private Node<K,V> nextGreater(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> rval;

  if (node == null) {

    rval=null;

  }

 else   if (node.getRight(dataElement) != null) {

    rval=leastNode(node.getRight(dataElement),dataElement);

  }

 else {

    Node<K,V> parent=node.getParent(dataElement);

    Node<K,V> child=node;

    while (parent != null && child == parent.getRight(dataElement)) {

      child=parent;

      parent=parent.getParent(dataElement);

    }

    rval=parent;

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the next smaller node from the specified node.

 * @param node the node to be searched from

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the specified node

 */

private Node<K,V> nextSmaller(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> rval;

  if (node == null) {

    rval=null;

  }

 else   if (node.getLeft(dataElement) != null) {

    rval=greatestNode(node.getLeft(dataElement),dataElement);

  }

 else {

    Node<K,V> parent=node.getParent(dataElement);

    Node<K,V> child=node;

    while (parent != null && child == parent.getLeft(dataElement)) {

      child=parent;

      parent=parent.getParent(dataElement);

    }

    rval=parent;

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Removes the mapping for this value from this map if present. <p> The value must implement  {@code Comparable}.

 * @param value  value whose mapping is to be removed from the map

 * @return previous key associated with specified value,or null if there was no mapping for value.

 * @throws ClassCastException if the value is of an inappropriate type

 * @throws NullPointerException if the value is null

 */

@Override public K removeValue(final Object value){

  return doRemoveValue(value);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Does a rotate left. standard fare in the world of balanced trees.

 * @param node the node to be rotated

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private void rotateLeft(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> rightChild=node.getRight(dataElement);

  node.setRight(rightChild.getLeft(dataElement),dataElement);

  if (rightChild.getLeft(dataElement) != null) {

    rightChild.getLeft(dataElement).setParent(node,dataElement);

  }

  rightChild.setParent(node.getParent(dataElement),dataElement);

  if (node.getParent(dataElement) == null) {

    rootNode[dataElement.ordinal()]=rightChild;

  }

 else   if (node.getParent(dataElement).getLeft(dataElement) == node) {

    node.getParent(dataElement).setLeft(rightChild,dataElement);

  }

 else {

    node.getParent(dataElement).setRight(rightChild,dataElement);

  }

  rightChild.setLeft(node,dataElement);

  node.setParent(rightChild,dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Does a rotate right. standard fare in the world of balanced trees.

 * @param node the node to be rotated

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private void rotateRight(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> leftChild=node.getLeft(dataElement);

  node.setLeft(leftChild.getRight(dataElement),dataElement);

  if (leftChild.getRight(dataElement) != null) {

    leftChild.getRight(dataElement).setParent(node,dataElement);

  }

  leftChild.setParent(node.getParent(dataElement),dataElement);

  if (node.getParent(dataElement) == null) {

    rootNode[dataElement.ordinal()]=leftChild;

  }

 else   if (node.getParent(dataElement).getRight(dataElement) == node) {

    node.getParent(dataElement).setRight(leftChild,dataElement);

  }

 else {

    node.getParent(dataElement).setLeft(leftChild,dataElement);

  }

  leftChild.setRight(node,dataElement);

  node.setParent(leftChild,dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Decrements the size and note that the map has changed.

 */

private void shrink(){

  modify();

  nodeCount--;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Swaps two nodes (except for their content), taking care of special cases where one is the other's parent ... hey, it happens.

 * @param x one node

 * @param y another node

 * @param dataElement  the KEY or VALUE int

 */

private void swapPosition(final Node<K,V> x,final Node<K,V> y,final DataElement dataElement){

  final Node<K,V> xFormerParent=x.getParent(dataElement);

  final Node<K,V> xFormerLeftChild=x.getLeft(dataElement);

  final Node<K,V> xFormerRightChild=x.getRight(dataElement);

  final Node<K,V> yFormerParent=y.getParent(dataElement);

  final Node<K,V> yFormerLeftChild=y.getLeft(dataElement);

  final Node<K,V> yFormerRightChild=y.getRight(dataElement);

  final boolean xWasLeftChild=x.getParent(dataElement) != null && x == x.getParent(dataElement).getLeft(dataElement);

  final boolean yWasLeftChild=y.getParent(dataElement) != null && y == y.getParent(dataElement).getLeft(dataElement);

  if (x == yFormerParent) {

    x.setParent(y,dataElement);

    if (yWasLeftChild) {

      y.setLeft(x,dataElement);

      y.setRight(xFormerRightChild,dataElement);

    }

 else {

      y.setRight(x,dataElement);

      y.setLeft(xFormerLeftChild,dataElement);

    }

  }

 else {

    x.setParent(yFormerParent,dataElement);

    if (yFormerParent != null) {

      if (yWasLeftChild) {

        yFormerParent.setLeft(x,dataElement);

      }

 else {

        yFormerParent.setRight(x,dataElement);

      }

    }

    y.setLeft(xFormerLeftChild,dataElement);

    y.setRight(xFormerRightChild,dataElement);

  }

  if (y == xFormerParent) {

    y.setParent(x,dataElement);

    if (xWasLeftChild) {

      x.setLeft(y,dataElement);

      x.setRight(yFormerRightChild,dataElement);

    }

 else {

      x.setRight(y,dataElement);

      x.setLeft(yFormerLeftChild,dataElement);

    }

  }

 else {

    y.setParent(xFormerParent,dataElement);

    if (xFormerParent != null) {

      if (xWasLeftChild) {

        xFormerParent.setLeft(y,dataElement);

      }

 else {

        xFormerParent.setRight(y,dataElement);

      }

    }

    x.setLeft(yFormerLeftChild,dataElement);

    x.setRight(yFormerRightChild,dataElement);

  }

  if (x.getLeft(dataElement) != null) {

    x.getLeft(dataElement).setParent(x,dataElement);

  }

  if (x.getRight(dataElement) != null) {

    x.getRight(dataElement).setParent(x,dataElement);

  }

  if (y.getLeft(dataElement) != null) {

    y.getLeft(dataElement).setParent(y,dataElement);

  }

  if (y.getRight(dataElement) != null) {

    y.getRight(dataElement).setParent(y,dataElement);

  }

  x.swapColors(y,dataElement);

  if (rootNode[dataElement.ordinal()] == x) {

    rootNode[dataElement.ordinal()]=y;

  }

 else   if (rootNode[dataElement.ordinal()] == y) {

    rootNode[dataElement.ordinal()]=x;

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Constructs a new empty TreeBidiMap.

 */

@SuppressWarnings("unchecked") public TreeBidiMap(){

  rootNode=new Node[2];

}

Location: TreeBidiMap.java

Content: 

/** 

 * Constructs a new TreeBidiMap by copying an existing Map.

 * @param map  the map to copy

 * @throws ClassCastException if the keys/values in the map arenot Comparable or are not mutually comparable

 * @throws NullPointerException if any key or value in the map is null

 */

public TreeBidiMap(final Map<? extends K,? extends V> map){

  this();

  putAll(map);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Checks a key and a value for validity (non-null and implements Comparable)

 * @param key the key to be checked

 * @param value the value to be checked

 * @throws NullPointerException if key or value is null

 * @throws ClassCastException if key or value is not Comparable

 */

private static void checkKeyAndValue(final Object key,final Object value){

  checkKey(key);

  checkValue(value);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Checks a key for validity (non-null and implements Comparable)

 * @param key the key to be checked

 * @throws NullPointerException if key is null

 * @throws ClassCastException if key is not Comparable

 */

private static void checkKey(final Object key){

  checkNonNullComparable(key,KEY);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Checks if an object is fit to be proper input ... has to be Comparable and non-null.

 * @param obj the object being checked

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @throws NullPointerException if o is null

 * @throws ClassCastException if o is not Comparable

 */

private static void checkNonNullComparable(final Object obj,final DataElement dataElement){

  Objects.requireNonNull(obj,Objects.toString(dataElement));

  if (!(obj instanceof Comparable)) {

    throw new ClassCastException(dataElement + " must be Comparable");

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Checks a value for validity (non-null and implements Comparable)

 * @param value the value to be checked

 * @throws NullPointerException if value is null

 * @throws ClassCastException if value is not Comparable

 */

private static void checkValue(final Object value){

  checkNonNullComparable(value,VALUE);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Copies the color from one node to another, dealing with the fact that one or both nodes may, in fact, be null.

 * @param from the node whose color we're copying; may be null

 * @param to the node whose color we're changing; may be null

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private void copyColor(final Node<K,V> from,final Node<K,V> to,final DataElement dataElement){

  if (to != null) {

    if (from == null) {

      to.setBlack(dataElement);

    }

 else {

      to.copyColor(from,dataElement);

    }

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Compares for equals as per the API.

 * @param obj  the object to compare to

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return true if equal

 */

private boolean doEquals(final Object obj,final DataElement dataElement){

  if (obj == this) {

    return true;

  }

  if (!(obj instanceof Map)) {

    return false;

  }

  final Map<?,?> other=(Map<?,?>)obj;

  if (other.size() != size()) {

    return false;

  }

  if (nodeCount > 0) {

    try {

      for (final MapIterator<?,?> it=getMapIterator(dataElement); it.hasNext(); ) {

        final Object key=it.next();

        final Object value=it.getValue();

        if (!value.equals(other.get(key))) {

          return false;

        }

      }

    }

 catch (    final ClassCastException|NullPointerException ex) {

      return false;

    }

  }

  return true;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the hash code value for this map as per the API.

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the hash code value for this map

 */

private int doHashCode(final DataElement dataElement){

  int total=0;

  if (nodeCount > 0) {

    for (final MapIterator<?,?> it=getMapIterator(dataElement); it.hasNext(); ) {

      final Object key=it.next();

      final Object value=it.getValue();

      total+=key.hashCode() ^ value.hashCode();

    }

  }

  return total;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Puts logic.

 * @param key  the key, always the main map key

 * @param value  the value, always the main map value

 */

private void doPut(final K key,final V value){

  checkKeyAndValue(key,value);

  doRemoveKey(key);

  doRemoveValue(value);

  Node<K,V> node=rootNode[KEY.ordinal()];

  if (node == null) {

    final Node<K,V> root=new Node<>(key,value);

    rootNode[KEY.ordinal()]=root;

    rootNode[VALUE.ordinal()]=root;

    grow();

  }

 else {

    while (true) {

      final int cmp=compare(key,node.getKey());

      if (cmp == 0) {

        throw new IllegalArgumentException("Cannot store a duplicate key (\"" + key + "\") in this Map");

      }

      if (cmp < 0) {

        if (node.getLeft(KEY) == null) {

          final Node<K,V> newNode=new Node<>(key,value);

          insertValue(newNode);

          node.setLeft(newNode,KEY);

          newNode.setParent(node,KEY);

          doRedBlackInsert(newNode,KEY);

          grow();

          break;

        }

        node=node.getLeft(KEY);

      }

 else {

        if (node.getRight(KEY) == null) {

          final Node<K,V> newNode=new Node<>(key,value);

          insertValue(newNode);

          node.setRight(newNode,KEY);

          newNode.setParent(node,KEY);

          doRedBlackInsert(newNode,KEY);

          grow();

          break;

        }

        node=node.getRight(KEY);

      }

    }

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Complicated red-black delete stuff. Based on Sun's TreeMap implementation, though it's barely recognizable any more. This rebalances the tree (somewhat, as red-black trees are not perfectly balanced -- perfect balancing takes longer)

 * @param replacementNode the node being replaced

 * @param dataElement  the KEY or VALUE int

 */

private void doRedBlackDeleteFixup(final Node<K,V> replacementNode,final DataElement dataElement){

  Node<K,V> currentNode=replacementNode;

  while (currentNode != rootNode[dataElement.ordinal()] && isBlack(currentNode,dataElement)) {

    if (currentNode.isLeftChild(dataElement)) {

      Node<K,V> siblingNode=getRightChild(getParent(currentNode,dataElement),dataElement);

      if (isRed(siblingNode,dataElement)) {

        makeBlack(siblingNode,dataElement);

        makeRed(getParent(currentNode,dataElement),dataElement);

        rotateLeft(getParent(currentNode,dataElement),dataElement);

        siblingNode=getRightChild(getParent(currentNode,dataElement),dataElement);

      }

      if (isBlack(getLeftChild(siblingNode,dataElement),dataElement) && isBlack(getRightChild(siblingNode,dataElement),dataElement)) {

        makeRed(siblingNode,dataElement);

        currentNode=getParent(currentNode,dataElement);

      }

 else {

        if (isBlack(getRightChild(siblingNode,dataElement),dataElement)) {

          makeBlack(getLeftChild(siblingNode,dataElement),dataElement);

          makeRed(siblingNode,dataElement);

          rotateRight(siblingNode,dataElement);

          siblingNode=getRightChild(getParent(currentNode,dataElement),dataElement);

        }

        copyColor(getParent(currentNode,dataElement),siblingNode,dataElement);

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(getRightChild(siblingNode,dataElement),dataElement);

        rotateLeft(getParent(currentNode,dataElement),dataElement);

        currentNode=rootNode[dataElement.ordinal()];

      }

    }

 else {

      Node<K,V> siblingNode=getLeftChild(getParent(currentNode,dataElement),dataElement);

      if (isRed(siblingNode,dataElement)) {

        makeBlack(siblingNode,dataElement);

        makeRed(getParent(currentNode,dataElement),dataElement);

        rotateRight(getParent(currentNode,dataElement),dataElement);

        siblingNode=getLeftChild(getParent(currentNode,dataElement),dataElement);

      }

      if (isBlack(getRightChild(siblingNode,dataElement),dataElement) && isBlack(getLeftChild(siblingNode,dataElement),dataElement)) {

        makeRed(siblingNode,dataElement);

        currentNode=getParent(currentNode,dataElement);

      }

 else {

        if (isBlack(getLeftChild(siblingNode,dataElement),dataElement)) {

          makeBlack(getRightChild(siblingNode,dataElement),dataElement);

          makeRed(siblingNode,dataElement);

          rotateLeft(siblingNode,dataElement);

          siblingNode=getLeftChild(getParent(currentNode,dataElement),dataElement);

        }

        copyColor(getParent(currentNode,dataElement),siblingNode,dataElement);

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(getLeftChild(siblingNode,dataElement),dataElement);

        rotateRight(getParent(currentNode,dataElement),dataElement);

        currentNode=rootNode[dataElement.ordinal()];

      }

    }

  }

  makeBlack(currentNode,dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Complicated red-black delete stuff. Based on Sun's TreeMap implementation, though it's barely recognizable any more.

 * @param deletedNode the node to be deleted

 */

private void doRedBlackDelete(final Node<K,V> deletedNode){

  for (  final DataElement dataElement : DataElement.values()) {

    if (deletedNode.getLeft(dataElement) != null && deletedNode.getRight(dataElement) != null) {

      swapPosition(nextGreater(deletedNode,dataElement),deletedNode,dataElement);

    }

    final Node<K,V> replacement=deletedNode.getLeft(dataElement) != null ? deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);

    if (replacement != null) {

      replacement.setParent(deletedNode.getParent(dataElement),dataElement);

      if (deletedNode.getParent(dataElement) == null) {

        rootNode[dataElement.ordinal()]=replacement;

      }

 else       if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {

        deletedNode.getParent(dataElement).setLeft(replacement,dataElement);

      }

 else {

        deletedNode.getParent(dataElement).setRight(replacement,dataElement);

      }

      deletedNode.setLeft(null,dataElement);

      deletedNode.setRight(null,dataElement);

      deletedNode.setParent(null,dataElement);

      if (isBlack(deletedNode,dataElement)) {

        doRedBlackDeleteFixup(replacement,dataElement);

      }

    }

 else {

      if (deletedNode.getParent(dataElement) == null) {

        rootNode[dataElement.ordinal()]=null;

      }

 else {

        if (isBlack(deletedNode,dataElement)) {

          doRedBlackDeleteFixup(deletedNode,dataElement);

        }

        if (deletedNode.getParent(dataElement) != null) {

          if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {

            deletedNode.getParent(dataElement).setLeft(null,dataElement);

          }

 else {

            deletedNode.getParent(dataElement).setRight(null,dataElement);

          }

          deletedNode.setParent(null,dataElement);

        }

      }

    }

  }

  shrink();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Complicated red-black insert stuff. Based on Sun's TreeMap implementation, though it's barely recognizable any more.

 * @param insertedNode the node to be inserted

 * @param dataElement  the KEY or VALUE int

 */

private void doRedBlackInsert(final Node<K,V> insertedNode,final DataElement dataElement){

  Node<K,V> currentNode=insertedNode;

  makeRed(currentNode,dataElement);

  while (currentNode != null && currentNode != rootNode[dataElement.ordinal()] && isRed(currentNode.getParent(dataElement),dataElement)) {

    if (currentNode.isLeftChild(dataElement)) {

      final Node<K,V> y=getRightChild(getGrandParent(currentNode,dataElement),dataElement);

      if (isRed(y,dataElement)) {

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(y,dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        currentNode=getGrandParent(currentNode,dataElement);

      }

 else {

        if (currentNode.isRightChild(dataElement)) {

          currentNode=getParent(currentNode,dataElement);

          rotateLeft(currentNode,dataElement);

        }

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        if (getGrandParent(currentNode,dataElement) != null) {

          rotateRight(getGrandParent(currentNode,dataElement),dataElement);

        }

      }

    }

 else {

      final Node<K,V> y=getLeftChild(getGrandParent(currentNode,dataElement),dataElement);

      if (isRed(y,dataElement)) {

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeBlack(y,dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        currentNode=getGrandParent(currentNode,dataElement);

      }

 else {

        if (currentNode.isLeftChild(dataElement)) {

          currentNode=getParent(currentNode,dataElement);

          rotateRight(currentNode,dataElement);

        }

        makeBlack(getParent(currentNode,dataElement),dataElement);

        makeRed(getGrandParent(currentNode,dataElement),dataElement);

        if (getGrandParent(currentNode,dataElement) != null) {

          rotateLeft(getGrandParent(currentNode,dataElement),dataElement);

        }

      }

    }

  }

  makeBlack(rootNode[dataElement.ordinal()],dataElement);

}

Location: TreeBidiMap.java

Content: 

private V doRemoveKey(final Object key){

  final Node<K,V> node=lookupKey(key);

  if (node == null) {

    return null;

  }

  doRedBlackDelete(node);

  return node.getValue();

}

Location: TreeBidiMap.java

Content: 

private K doRemoveValue(final Object value){

  final Node<K,V> node=lookupValue(value);

  if (node == null) {

    return null;

  }

  doRedBlackDelete(node);

  return node.getKey();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the string form of this map as per AbstractMap.

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the string form of this map

 */

private String doToString(final DataElement dataElement){

  if (nodeCount == 0) {

    return "{}";

  }

  final StringBuilder buf=new StringBuilder(nodeCount * 32);

  buf.append('{');

  final MapIterator<?,?> it=getMapIterator(dataElement);

  boolean hasNext=it.hasNext();

  while (hasNext) {

    final Object key=it.next();

    final Object value=it.getValue();

    buf.append(key == this ? "(this Map)" : key).append('=').append(value == this ? "(this Map)" : value);

    hasNext=it.hasNext();

    if (hasNext) {

      buf.append(", ");

    }

  }

  buf.append('}');

  return buf.toString();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's grandparent. mind you, the node, its parent, or its grandparent may not exist. No problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getGrandParent(final Node<K,V> node,final DataElement dataElement){

  return getParent(getParent(node,dataElement),dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Returns the key to which this map maps the specified value. Returns null if the map contains no mapping for this value. <p> The value must implement  {@code Comparable}.

 * @param value  value whose associated key is to be returned.

 * @return the key to which this map maps the specified value,or null if the map contains no mapping for this value.

 * @throws ClassCastException if the value is of an inappropriate type

 * @throws NullPointerException if the value is null

 */

@Override public K getKey(final Object value){

  checkValue(value);

  final Node<K,V> node=lookupValue(value);

  return node == null ? null : node.getKey();

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's left child. mind you, the node may not exist. no problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getLeftChild(final Node<K,V> node,final DataElement dataElement){

  return node == null ? null : node.getLeft(dataElement);

}

Location: TreeBidiMap.java

Content: 

private MapIterator<?,?> getMapIterator(final DataElement dataElement){

switch (dataElement) {

case KEY:

    return new ViewMapIterator(KEY);

case VALUE:

  return new InverseViewMapIterator(VALUE);

default :

throw new IllegalArgumentException();

}

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's parent. mind you, the node, or its parent, may not exist. no problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getParent(final Node<K,V> node,final DataElement dataElement){

  return node == null ? null : node.getParent(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets a node's right child. mind you, the node may not exist. no problem.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private Node<K,V> getRightChild(final Node<K,V> node,final DataElement dataElement){

  return node == null ? null : node.getRight(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Finds the greatest node from a given node.

 * @param node  the node from which we will start searching

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the greatest node, from the specified node

 */

private Node<K,V> greatestNode(final Node<K,V> node,final DataElement dataElement){

  Node<K,V> rval=node;

  if (rval != null) {

    while (rval.getRight(dataElement) != null) {

      rval=rval.getRight(dataElement);

    }

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Bumps up the size and note that the map has changed.

 */

private void grow(){

  modify();

  nodeCount++;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Inserts a node by its value.

 * @param newNode the node to be inserted

 * @throws IllegalArgumentException if the node already existsin the value mapping

 */

private void insertValue(final Node<K,V> newNode) throws IllegalArgumentException {

  Node<K,V> node=rootNode[VALUE.ordinal()];

  while (true) {

    final int cmp=compare(newNode.getValue(),node.getValue());

    if (cmp == 0) {

      throw new IllegalArgumentException("Cannot store a duplicate value (\"" + newNode.getData(VALUE) + "\") in this Map");

    }

    if (cmp < 0) {

      if (node.getLeft(VALUE) == null) {

        node.setLeft(newNode,VALUE);

        newNode.setParent(node,VALUE);

        doRedBlackInsert(newNode,VALUE);

        break;

      }

      node=node.getLeft(VALUE);

    }

 else {

      if (node.getRight(VALUE) == null) {

        node.setRight(newNode,VALUE);

        newNode.setParent(node,VALUE);

        doRedBlackInsert(newNode,VALUE);

        break;

      }

      node=node.getRight(VALUE);

    }

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the inverse map for comparison.

 * @return the inverse map

 */

@Override public OrderedBidiMap<V,K> inverseBidiMap(){

  if (inverse == null) {

    inverse=new Inverse();

  }

  return inverse;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Is the specified black red? If the node does not exist, sure, it's black, thank you.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static boolean isBlack(final Node<?,?> node,final DataElement dataElement){

  return node == null || node.isBlack(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Is the specified node red? If the node does not exist, no, it's black, thank you.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static boolean isRed(final Node<?,?> node,final DataElement dataElement){

  return node != null && node.isRed(dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Finds the least node from a given node.

 * @param node  the node from which we will start searching

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the smallest node, from the specified node, in thespecified mapping

 */

private Node<K,V> leastNode(final Node<K,V> node,final DataElement dataElement){

  Node<K,V> rval=node;

  if (rval != null) {

    while (rval.getLeft(dataElement) != null) {

      rval=rval.getLeft(dataElement);

    }

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

private Node<K,V> lookupKey(final Object key){

  return this.<K>lookup(key,KEY);

}

Location: TreeBidiMap.java

Content: 

private Node<K,V> lookupValue(final Object value){

  return this.<V>lookup(value,VALUE);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Does the actual lookup of a piece of data.

 * @param data the key or value to be looked up

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the desired Node, or null if there is no mapping of thespecified data

 */

@SuppressWarnings("unchecked") private <T extends Comparable<T>>Node<K,V> lookup(final Object data,final DataElement dataElement){

  Node<K,V> rval=null;

  Node<K,V> node=rootNode[dataElement.ordinal()];

  while (node != null) {

    final int cmp=compare((T)data,(T)node.getData(dataElement));

    if (cmp == 0) {

      rval=node;

      break;

    }

    node=cmp < 0 ? node.getLeft(dataElement) : node.getRight(dataElement);

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Forces a node (if it exists) black.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static void makeBlack(final Node<?,?> node,final DataElement dataElement){

  if (node != null) {

    node.setBlack(dataElement);

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Forces a node (if it exists) red.

 * @param node the node (may be null) in question

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private static void makeRed(final Node<?,?> node,final DataElement dataElement){

  if (node != null) {

    node.setRed(dataElement);

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Increments the modification count -- used to check for concurrent modification of the map through the map and through an Iterator from one of its Set or Collection views.

 */

private void modify(){

  modifications++;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the next larger node from the specified node.

 * @param node the node to be searched from

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the specified node

 */

private Node<K,V> nextGreater(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> rval;

  if (node == null) {

    rval=null;

  }

 else   if (node.getRight(dataElement) != null) {

    rval=leastNode(node.getRight(dataElement),dataElement);

  }

 else {

    Node<K,V> parent=node.getParent(dataElement);

    Node<K,V> child=node;

    while (parent != null && child == parent.getRight(dataElement)) {

      child=parent;

      parent=parent.getParent(dataElement);

    }

    rval=parent;

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Gets the next smaller node from the specified node.

 * @param node the node to be searched from

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 * @return the specified node

 */

private Node<K,V> nextSmaller(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> rval;

  if (node == null) {

    rval=null;

  }

 else   if (node.getLeft(dataElement) != null) {

    rval=greatestNode(node.getLeft(dataElement),dataElement);

  }

 else {

    Node<K,V> parent=node.getParent(dataElement);

    Node<K,V> child=node;

    while (parent != null && child == parent.getLeft(dataElement)) {

      child=parent;

      parent=parent.getParent(dataElement);

    }

    rval=parent;

  }

  return rval;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Removes the mapping for this value from this map if present. <p> The value must implement  {@code Comparable}.

 * @param value  value whose mapping is to be removed from the map

 * @return previous key associated with specified value,or null if there was no mapping for value.

 * @throws ClassCastException if the value is of an inappropriate type

 * @throws NullPointerException if the value is null

 */

@Override public K removeValue(final Object value){

  return doRemoveValue(value);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Does a rotate left. standard fare in the world of balanced trees.

 * @param node the node to be rotated

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private void rotateLeft(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> rightChild=node.getRight(dataElement);

  node.setRight(rightChild.getLeft(dataElement),dataElement);

  if (rightChild.getLeft(dataElement) != null) {

    rightChild.getLeft(dataElement).setParent(node,dataElement);

  }

  rightChild.setParent(node.getParent(dataElement),dataElement);

  if (node.getParent(dataElement) == null) {

    rootNode[dataElement.ordinal()]=rightChild;

  }

 else   if (node.getParent(dataElement).getLeft(dataElement) == node) {

    node.getParent(dataElement).setLeft(rightChild,dataElement);

  }

 else {

    node.getParent(dataElement).setRight(rightChild,dataElement);

  }

  rightChild.setLeft(node,dataElement);

  node.setParent(rightChild,dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Does a rotate right. standard fare in the world of balanced trees.

 * @param node the node to be rotated

 * @param dataElement  either {@link DataElement#KEY} key}or the  {@link DataElement#VALUE value}.

 */

private void rotateRight(final Node<K,V> node,final DataElement dataElement){

  final Node<K,V> leftChild=node.getLeft(dataElement);

  node.setLeft(leftChild.getRight(dataElement),dataElement);

  if (leftChild.getRight(dataElement) != null) {

    leftChild.getRight(dataElement).setParent(node,dataElement);

  }

  leftChild.setParent(node.getParent(dataElement),dataElement);

  if (node.getParent(dataElement) == null) {

    rootNode[dataElement.ordinal()]=leftChild;

  }

 else   if (node.getParent(dataElement).getRight(dataElement) == node) {

    node.getParent(dataElement).setRight(leftChild,dataElement);

  }

 else {

    node.getParent(dataElement).setLeft(leftChild,dataElement);

  }

  leftChild.setRight(node,dataElement);

  node.setParent(leftChild,dataElement);

}

Location: TreeBidiMap.java

Content: 

/** 

 * Decrements the size and note that the map has changed.

 */

private void shrink(){

  modify();

  nodeCount--;

}

Location: TreeBidiMap.java

Content: 

/** 

 * Swaps two nodes (except for their content), taking care of special cases where one is the other's parent ... hey, it happens.

 * @param x one node

 * @param y another node

 * @param dataElement  the KEY or VALUE int

 */

private void swapPosition(final Node<K,V> x,final Node<K,V> y,final DataElement dataElement){

  final Node<K,V> xFormerParent=x.getParent(dataElement);

  final Node<K,V> xFormerLeftChild=x.getLeft(dataElement);

  final Node<K,V> xFormerRightChild=x.getRight(dataElement);

  final Node<K,V> yFormerParent=y.getParent(dataElement);

  final Node<K,V> yFormerLeftChild=y.getLeft(dataElement);

  final Node<K,V> yFormerRightChild=y.getRight(dataElement);

  final boolean xWasLeftChild=x.getParent(dataElement) != null && x == x.getParent(dataElement).getLeft(dataElement);

  final boolean yWasLeftChild=y.getParent(dataElement) != null && y == y.getParent(dataElement).getLeft(dataElement);

  if (x == yFormerParent) {

    x.setParent(y,dataElement);

    if (yWasLeftChild) {

      y.setLeft(x,dataElement);

      y.setRight(xFormerRightChild,dataElement);

    }

 else {

      y.setRight(x,dataElement);

      y.setLeft(xFormerLeftChild,dataElement);

    }

  }

 else {

    x.setParent(yFormerParent,dataElement);

    if (yFormerParent != null) {

      if (yWasLeftChild) {

        yFormerParent.setLeft(x,dataElement);

      }

 else {

        yFormerParent.setRight(x,dataElement);

      }

    }

    y.setLeft(xFormerLeftChild,dataElement);

    y.setRight(xFormerRightChild,dataElement);

  }

  if (y == xFormerParent) {

    y.setParent(x,dataElement);

    if (xWasLeftChild) {

      x.setLeft(y,dataElement);

      x.setRight(yFormerRightChild,dataElement);

    }

 else {

      x.setRight(y,dataElement);

      x.setLeft(yFormerLeftChild,dataElement);

    }

  }

 else {

    y.setParent(xFormerParent,dataElement);

    if (xFormerParent != null) {

      if (xWasLeftChild) {

        xFormerParent.setLeft(y,dataElement);

      }

 else {

        xFormerParent.setRight(y,dataElement);

      }

    }

    x.setLeft(yFormerLeftChild,dataElement);

    x.setRight(yFormerRightChild,dataElement);

  }

  if (x.getLeft(dataElement) != null) {

    x.getLeft(dataElement).setParent(x,dataElement);

  }

  if (x.getRight(dataElement) != null) {

    x.getRight(dataElement).setParent(x,dataElement);

  }

  if (y.getLeft(dataElement) != null) {

    y.getLeft(dataElement).setParent(y,dataElement);

  }

  if (y.getRight(dataElement) != null) {

    y.getRight(dataElement).setParent(y,dataElement);

  }

  x.swapColors(y,dataElement);

  if (rootNode[dataElement.ordinal()] == x) {

    rootNode[dataElement.ordinal()]=y;

  }

 else   if (rootNode[dataElement.ordinal()] == y) {

    rootNode[dataElement.ordinal()]=x;

  }

}

Location: TreeBidiMap.java

Content: 

/** 

 * Constructs a new empty TreeBidiMap.

 */

@SuppressWarnings("unchecked") public TreeBidiMap(){

  rootNode=new Node[2];

}

Location: TreeBidiMap.java

Content: 

/** 

 * Constructs a new TreeBidiMap by copying an existing Map.

 * @param map  the map to copy

 * @throws ClassCastException if the keys/values in the map arenot Comparable or are not mutually comparable

 * @throws NullPointerException if any key or value in the map is null

 */

public TreeBidiMap(final Map<? extends K,? extends V> map){

  this();

  putAll(map);

}

