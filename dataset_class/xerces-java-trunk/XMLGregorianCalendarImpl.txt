Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Add <code>duration</code> to this instance.<\p> <p>The computation is specified in <a href="http://www.w3.org/TR/xmlschema-2/#adding-durations-to-dateTimes">XML Schema 1.0 Part 2, Appendix E, <i>Adding durations to dateTimes</i>></a>. <a href="#datetimefieldsmapping">date/time field mapping table</a> defines the mapping from XML Schema 1.0 <code>dateTime</code> fields  to this class' representation of those fields.</p>

 * @param duration Duration to add to this <code>XMLGregorianCalendar</code>.

 * @throws NullPointerException  when <code>duration</code> parameter is <code>null</code>.

 */

public void add(Duration duration){

  boolean fieldUndefined[]={false,false,false,false,false,false};

  int signum=duration.getSign();

  int startMonth=getMonth();

  if (startMonth == DatatypeConstants.FIELD_UNDEFINED) {

    startMonth=MIN_FIELD_VALUE[MONTH];

    fieldUndefined[MONTH]=true;

  }

  BigInteger dMonths=sanitize(duration.getField(DatatypeConstants.MONTHS),signum);

  BigInteger temp=BigInteger.valueOf((long)startMonth).add(dMonths);

  setMonth(temp.subtract(BigInteger.ONE).mod(TWELVE).intValue() + 1);

  BigInteger carry=new BigDecimal(temp.subtract(BigInteger.ONE)).divide(new BigDecimal(TWELVE),BigDecimal.ROUND_FLOOR).toBigInteger();

  BigInteger startYear=getEonAndYear();

  if (startYear == null) {

    fieldUndefined[YEAR]=true;

    startYear=BigInteger.ZERO;

  }

  BigInteger dYears=sanitize(duration.getField(DatatypeConstants.YEARS),signum);

  BigInteger endYear=startYear.add(dYears).add(carry);

  setYear(endYear);

  BigDecimal startSeconds;

  if (getSecond() == DatatypeConstants.FIELD_UNDEFINED) {

    fieldUndefined[SECOND]=true;

    startSeconds=DECIMAL_ZERO;

  }

 else {

    startSeconds=getSeconds();

  }

  BigDecimal dSeconds=DurationImpl.sanitize((BigDecimal)duration.getField(DatatypeConstants.SECONDS),signum);

  BigDecimal tempBD=startSeconds.add(dSeconds);

  BigDecimal fQuotient=new BigDecimal(new BigDecimal(tempBD.toBigInteger()).divide(DECIMAL_SIXTY,BigDecimal.ROUND_FLOOR).toBigInteger());

  BigDecimal endSeconds=tempBD.subtract(fQuotient.multiply(DECIMAL_SIXTY));

  carry=fQuotient.toBigInteger();

  setSecond(endSeconds.intValue());

  BigDecimal tempFracSeconds=endSeconds.subtract(new BigDecimal(BigInteger.valueOf((long)getSecond())));

  if (tempFracSeconds.compareTo(DECIMAL_ZERO) < 0) {

    setFractionalSecond(DECIMAL_ONE.add(tempFracSeconds));

    if (getSecond() == 0) {

      setSecond(59);

      carry=carry.subtract(BigInteger.ONE);

    }

 else {

      setSecond(getSecond() - 1);

    }

  }

 else {

    setFractionalSecond(tempFracSeconds);

  }

  int startMinutes=getMinute();

  if (startMinutes == DatatypeConstants.FIELD_UNDEFINED) {

    fieldUndefined[MINUTE]=true;

    startMinutes=MIN_FIELD_VALUE[MINUTE];

  }

  BigInteger dMinutes=sanitize(duration.getField(DatatypeConstants.MINUTES),signum);

  temp=BigInteger.valueOf(startMinutes).add(dMinutes).add(carry);

  setMinute(temp.mod(SIXTY).intValue());

  carry=new BigDecimal(temp).divide(DECIMAL_SIXTY,BigDecimal.ROUND_FLOOR).toBigInteger();

  int startHours=getHour();

  if (startHours == DatatypeConstants.FIELD_UNDEFINED) {

    fieldUndefined[HOUR]=true;

    startHours=MIN_FIELD_VALUE[HOUR];

  }

  BigInteger dHours=sanitize(duration.getField(DatatypeConstants.HOURS),signum);

  temp=BigInteger.valueOf(startHours).add(dHours).add(carry);

  setHour(temp.mod(TWENTY_FOUR).intValue());

  carry=new BigDecimal(temp).divide(new BigDecimal(TWENTY_FOUR),BigDecimal.ROUND_FLOOR).toBigInteger();

  BigInteger tempDays;

  int startDay=getDay();

  if (startDay == DatatypeConstants.FIELD_UNDEFINED) {

    fieldUndefined[DAY]=true;

    startDay=MIN_FIELD_VALUE[DAY];

  }

  BigInteger dDays=sanitize(duration.getField(DatatypeConstants.DAYS),signum);

  int maxDayInMonth=maximumDayInMonthFor(getEonAndYear(),getMonth());

  if (startDay > maxDayInMonth) {

    tempDays=BigInteger.valueOf(maxDayInMonth);

  }

 else   if (startDay < 1) {

    tempDays=BigInteger.ONE;

  }

 else {

    tempDays=BigInteger.valueOf(startDay);

  }

  BigInteger endDays=tempDays.add(dDays).add(carry);

  int monthCarry;

  int intTemp;

  while (true) {

    if (endDays.compareTo(BigInteger.ONE) < 0) {

      BigInteger mdimf=null;

      if (month >= 2) {

        mdimf=BigInteger.valueOf(maximumDayInMonthFor(getEonAndYear(),getMonth() - 1));

      }

 else {

        mdimf=BigInteger.valueOf(maximumDayInMonthFor(getEonAndYear().subtract(BigInteger.valueOf((long)1)),12));

      }

      endDays=endDays.add(mdimf);

      monthCarry=-1;

    }

 else     if (endDays.compareTo(BigInteger.valueOf(maximumDayInMonthFor(getEonAndYear(),getMonth()))) > 0) {

      endDays=endDays.add(BigInteger.valueOf(-maximumDayInMonthFor(getEonAndYear(),getMonth())));

      monthCarry=1;

    }

 else {

      break;

    }

    intTemp=getMonth() + monthCarry;

    int endMonth=(intTemp - 1) % (13 - 1);

    int quotient;

    if (endMonth < 0) {

      endMonth=(13 - 1) + endMonth + 1;

      quotient=BigDecimal.valueOf(intTemp - 1).divide(new BigDecimal(TWELVE),BigDecimal.ROUND_UP).intValue();

    }

 else {

      quotient=(intTemp - 1) / (13 - 1);

      endMonth+=1;

    }

    setMonth(endMonth);

    if (quotient != 0) {

      setYear(getEonAndYear().add(BigInteger.valueOf(quotient)));

    }

  }

  setDay(endDays.intValue());

  for (int i=YEAR; i <= SECOND; i++) {

    if (fieldUndefined[i]) {

switch (i) {

case YEAR:

        setYear(DatatypeConstants.FIELD_UNDEFINED);

      break;

case MONTH:

    setMonth(DatatypeConstants.FIELD_UNDEFINED);

  break;

case DAY:

setDay(DatatypeConstants.FIELD_UNDEFINED);

break;

case HOUR:

setHour(DatatypeConstants.FIELD_UNDEFINED);

break;

case MINUTE:

setMinute(DatatypeConstants.FIELD_UNDEFINED);

break;

case SECOND:

setSecond(DatatypeConstants.FIELD_UNDEFINED);

setFractionalSecond(null);

break;

}

}

}

}

Location: XMLGregorianCalendarImpl.java

Content: 

private void checkFieldValueConstraint(int field,int value) throws IllegalArgumentException {

  if ((value < MIN_FIELD_VALUE[field] && value != DatatypeConstants.FIELD_UNDEFINED) || value > MAX_FIELD_VALUE[field]) {

    throw new IllegalArgumentException(DatatypeMessageFormatter.formatMessage(null,"InvalidFieldValue",new Object[]{new Integer(value),FIELD_NAME[field]}));

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

private static int compareField(BigDecimal Pfield,BigDecimal Qfield){

  if (Pfield == Qfield) {

    return DatatypeConstants.EQUAL;

  }

  if (Pfield == null) {

    Pfield=DECIMAL_ZERO;

  }

  if (Qfield == null) {

    Qfield=DECIMAL_ZERO;

  }

  return Pfield.compareTo(Qfield);

}

Location: XMLGregorianCalendarImpl.java

Content: 

private static int compareField(BigInteger Pfield,BigInteger Qfield){

  if (Pfield == null) {

    return (Qfield == null ? DatatypeConstants.EQUAL : DatatypeConstants.INDETERMINATE);

  }

  if (Qfield == null) {

    return DatatypeConstants.INDETERMINATE;

  }

  return Pfield.compareTo(Qfield);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Implement Step B from  http://www.w3.org/TR/xmlschema-2/#dateTime-order.</p>

 */

private static int compareField(int Pfield,int Qfield){

  if (Pfield == Qfield) {

    return DatatypeConstants.EQUAL;

  }

 else {

    if (Pfield == DatatypeConstants.FIELD_UNDEFINED || Qfield == DatatypeConstants.FIELD_UNDEFINED) {

      return DatatypeConstants.INDETERMINATE;

    }

 else {

      return (Pfield < Qfield ? DatatypeConstants.LESSER : DatatypeConstants.GREATER);

    }

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Compare two instances of W3C XML Schema 1.0 date/time datatypes  according to partial order relation defined in  <a href="http://www.w3.org/TR/xmlschema-2/#dateTime-order">W3C XML Schema 1.0 Part 2, Section 3.2.7.3, <i>Order relation on dateTime</i></a>.</p> <p><code>xsd:dateTime</code> datatype field mapping to accessors of this class are defined in <a href="#datetimefieldmapping">date/time field mapping table</a>.</p>

 * @param rhs instance of <code>XMLGregorianCalendar</code> to compare

 * @return the relationship between <code>lhs</code> and <code>rhs</code> as {@link DatatypeConstants#LESSER}, {@link DatatypeConstants#EQUAL}, {@link DatatypeConstants#GREATER} or{@link DatatypeConstants#INDETERMINATE}.

 * @throws NullPointerException if <code>lhs</code> or <code>rhs</code> parameters are null. 

 */

public int compare(XMLGregorianCalendar rhs){

  int result=DatatypeConstants.INDETERMINATE;

  XMLGregorianCalendar P=this;

  XMLGregorianCalendar Q=rhs;

  if (P.getTimezone() == Q.getTimezone()) {

    return internalCompare(P,Q);

  }

 else   if (P.getTimezone() != DatatypeConstants.FIELD_UNDEFINED && Q.getTimezone() != DatatypeConstants.FIELD_UNDEFINED) {

    P=(XMLGregorianCalendarImpl)P.normalize();

    Q=(XMLGregorianCalendarImpl)Q.normalize();

    return internalCompare(P,Q);

  }

 else   if (P.getTimezone() != DatatypeConstants.FIELD_UNDEFINED) {

    if (P.getTimezone() != 0) {

      P=(XMLGregorianCalendarImpl)P.normalize();

    }

    XMLGregorianCalendar MinQ=normalizeToTimezone(Q,DatatypeConstants.MIN_TIMEZONE_OFFSET);

    result=internalCompare(P,MinQ);

    if (result == DatatypeConstants.LESSER) {

      return result;

    }

    XMLGregorianCalendar MaxQ=normalizeToTimezone(Q,DatatypeConstants.MAX_TIMEZONE_OFFSET);

    result=internalCompare(P,MaxQ);

    if (result == DatatypeConstants.GREATER) {

      return result;

    }

 else {

      return DatatypeConstants.INDETERMINATE;

    }

  }

 else {

    if (Q.getTimezone() != 0) {

      Q=(XMLGregorianCalendarImpl)normalizeToTimezone(Q,Q.getTimezone());

    }

    XMLGregorianCalendar MaxP=normalizeToTimezone(P,DatatypeConstants.MAX_TIMEZONE_OFFSET);

    result=internalCompare(MaxP,Q);

    if (result == DatatypeConstants.LESSER) {

      return result;

    }

    XMLGregorianCalendar MinP=normalizeToTimezone(P,DatatypeConstants.MIN_TIMEZONE_OFFSET);

    result=internalCompare(MinP,Q);

    if (result == DatatypeConstants.GREATER) {

      return result;

    }

 else {

      return DatatypeConstants.INDETERMINATE;

    }

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Create a Java representation of XML Schema builtin datatype <code>dateTime</code>. All possible fields are specified for this factory method.</p>

 * @param year represents both high-order eons and low-order year.

 * @param month of <code>dateTime</code>

 * @param day of <code>dateTime</code>

 * @param hours of <code>dateTime</code>

 * @param minutes of <code>dateTime</code>

 * @param seconds of <code>dateTime</code>

 * @param fractionalSecond value of null indicates optional field is absent.

 * @param timezone offset in minutes. {@link DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.

 * @return <code>XMLGregorianCalendar</code> created from parameter values.

 * @see DatatypeConstants#FIELD_UNDEFINED

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public static XMLGregorianCalendar createDateTime(BigInteger year,int month,int day,int hours,int minutes,int seconds,BigDecimal fractionalSecond,int timezone){

  return new XMLGregorianCalendarImpl(year,month,day,hours,minutes,seconds,fractionalSecond,timezone);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Create a Java instance of XML Schema builtin datatype dateTime.</p>

 * @param year represents both high-order eons and low-order year.

 * @param month of <code>dateTime</code>

 * @param day of <code>dateTime</code>

 * @param hour of <code>dateTime</code>

 * @param minute of <code>dateTime</code>

 * @param second of <code>dateTime</code>

 * @return <code>XMLGregorianCalendar</code> created from parameter values.

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in <a href="#datetimefieldmapping">date/time field mapping table</a>.

 * @see DatatypeConstants#FIELD_UNDEFINED

 */

public static XMLGregorianCalendar createDateTime(int year,int month,int day,int hour,int minute,int second){

  return new XMLGregorianCalendarImpl(year,month,day,hour,minute,second,DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Create a Java representation of XML Schema builtin datatype <code>dateTime</code>. All possible fields are specified for this factory method.</p>

 * @param year represents low-order year.

 * @param month of <code>dateTime</code>

 * @param day of <code>dateTime</code>

 * @param hours of <code>dateTime</code>

 * @param minutes of <code>dateTime</code>

 * @param seconds of <code>dateTime</code>

 * @param milliseconds of <code>dateTime</code>. {@link DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.

 * @param timezone offset in minutes. {@link DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.

 * @return <code>XMLGregorianCalendar</code> created from parameter values.

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in <a href="#datetimefieldmapping">date/time field mapping table</a>.

 * @see DatatypeConstants#FIELD_UNDEFINED

 */

public static XMLGregorianCalendar createDateTime(int year,int month,int day,int hours,int minutes,int seconds,int milliseconds,int timezone){

  return new XMLGregorianCalendarImpl(year,month,day,hours,minutes,seconds,milliseconds,timezone);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Create a Java representation of XML Schema builtin datatype <code>date</code> or <code>g*</code>.</p> <p>For example, an instance of <code>gYear</code> can be created invoking this factory  with <code>month</code> and <code>day</code> parameters set to  {@link DatatypeConstants#FIELD_UNDEFINED}.</p>

 * @param year of <code>XMLGregorianCalendar</code> to be created.

 * @param month of <code>XMLGregorianCalendar</code> to be created.

 * @param day of <code>XMLGregorianCalendar</code> to be created.

 * @param timezone offset in minutes. {@link DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.

 * @return <code>XMLGregorianCalendar</code> created from parameter values.

 * @see DatatypeConstants#FIELD_UNDEFINED

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public static XMLGregorianCalendar createDate(int year,int month,int day,int timezone){

  return new XMLGregorianCalendarImpl(year,month,day,DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,timezone);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Create a Java instance of XML Schema builtin datatype time.</p>

 * @param hours number of hours

 * @param minutes number of minutes

 * @param seconds number of seconds

 * @param fractionalSecond value of <code>null</code> indicates that this optional field is not set.

 * @param timezone offset in minutes. {@link DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.

 * @return <code>XMLGregorianCalendar</code> created from parameter values.

 * @see DatatypeConstants#FIELD_UNDEFINED

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public static XMLGregorianCalendar createTime(int hours,int minutes,int seconds,BigDecimal fractionalSecond,int timezone){

  return new XMLGregorianCalendarImpl(null,DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,hours,minutes,seconds,fractionalSecond,timezone);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Create a Java instance of XML Schema builtin datatype <code>time</code>.

 * @param hours number of hours

 * @param minutes number of minutes

 * @param seconds number of seconds

 * @param timezone offset in minutes. {@link DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.

 * @return <code>XMLGregorianCalendar</code> created from parameter values.

 * @see DatatypeConstants#FIELD_UNDEFINED

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public static XMLGregorianCalendar createTime(int hours,int minutes,int seconds,int timezone){

  return new XMLGregorianCalendarImpl(DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,hours,minutes,seconds,DatatypeConstants.FIELD_UNDEFINED,timezone);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Create a Java instance of XML Schema builtin datatype time.</p>

 * @param hours number of hours

 * @param minutes number of minutes

 * @param seconds number of seconds

 * @param milliseconds number of milliseconds

 * @param timezone offset in minutes. {@link DatatypeConstants#FIELD_UNDEFINED} indicates optional field is not set.

 * @return <code>XMLGregorianCalendar</code> created from parameter values.

 * @see DatatypeConstants#FIELD_UNDEFINED

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public static XMLGregorianCalendar createTime(int hours,int minutes,int seconds,int milliseconds,int timezone){

  return new XMLGregorianCalendarImpl(DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,DatatypeConstants.FIELD_UNDEFINED,hours,minutes,seconds,milliseconds,timezone);

}

Location: XMLGregorianCalendarImpl.java

Content: 

private String format(String format){

  StringBuffer buf=new StringBuffer();

  int fidx=0, flen=format.length();

  while (fidx < flen) {

    char fch=format.charAt(fidx++);

    if (fch != '%') {

      buf.append(fch);

      continue;

    }

switch (format.charAt(fidx++)) {

case 'Y':

      if (eon == null) {

        int absYear=year;

        if (absYear < 0) {

          buf.append('-');

          absYear=-year;

        }

        printNumber(buf,absYear,4);

      }

 else {

        printNumber(buf,getEonAndYear(),4);

      }

    break;

case 'M':

  printNumber(buf,getMonth(),2);

break;

case 'D':

printNumber(buf,getDay(),2);

break;

case 'h':

printNumber(buf,getHour(),2);

break;

case 'm':

printNumber(buf,getMinute(),2);

break;

case 's':

printNumber(buf,getSecond(),2);

if (getFractionalSecond() != null) {

String frac=toString(getFractionalSecond());

buf.append(frac.substring(1,frac.length()));

}

break;

case 'z':

int offset=getTimezone();

if (offset == 0) {

buf.append('Z');

}

 else if (offset != DatatypeConstants.FIELD_UNDEFINED) {

if (offset < 0) {

buf.append('-');

offset*=-1;

}

 else {

buf.append('+');

}

printNumber(buf,offset / 60,2);

buf.append(':');

printNumber(buf,offset % 60,2);

}

break;

default :

throw new InternalError();

}

}

return buf.toString();

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Return day in month or  {@link DatatypeConstants#FIELD_UNDEFINED}.</p> <p>Value constraints for this value are summarized in  <a href="#datetimefield-day">day field of date/time field mapping table</a>.</p>

 * @see #setDay(int)

 */

public int getDay(){

  return day;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return high order component for XML Schema 1.0 dateTime datatype field for  <code>year</code>. <code>null</code> if this optional part of the year field is not defined.</p> <p>Value constraints for this value are summarized in  <a href="#datetimefield-year">year field of date/time field mapping table</a>.</p>

 * @return eon of this <code>XMLGregorianCalendar</code>. The value returned is an integer multiple of 10^9.

 * @see #getYear()

 * @see #getEonAndYear()

 */

public BigInteger getEon(){

  return eon;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return XML Schema 1.0 dateTime datatype field for  <code>year</code>.</p> <p>Value constraints for this value are summarized in  <a href="#datetimefield-year">year field of date/time field mapping table</a>.</p>

 * @return sum of <code>eon</code> and <code>BigInteger.valueOf(year)</code>when both fields are defined. When only <code>year</code> is defined,  return it. When both <code>eon</code> and <code>year</code> are not  defined, return <code>null</code>.

 * @see #getEon()

 * @see #getYear()

 */

public BigInteger getEonAndYear(){

  if (year != DatatypeConstants.FIELD_UNDEFINED && eon != null) {

    return eon.add(BigInteger.valueOf((long)year));

  }

  if (year != DatatypeConstants.FIELD_UNDEFINED && eon == null) {

    return BigInteger.valueOf((long)year);

  }

  return null;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return fractional seconds.</p> <p><code>null</code> is returned when this optional field is not defined.</p> <p>Value constraints are detailed in <a href="#datetimefield-second">second field of date/time field mapping table</a>.</p> <p>This optional field can only have a defined value when the xs:dateTime second field, represented by ( {@link #getSecond()},  does not return  {@link DatatypeConstants#FIELD_UNDEFINED}).</p>

 * @return fractional seconds  of this <code>XMLGregorianCalendar</code>.

 * @see #getSecond()

 * @see #setTime(int,int,int,BigDecimal)

 */

public BigDecimal getFractionalSecond(){

  return fractionalSecond;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Return hours or  {@link DatatypeConstants#FIELD_UNDEFINED}. Returns  {@link DatatypeConstants#FIELD_UNDEFINED} if this field is not defined.<p>Value constraints for this value are summarized in  <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.</p>

 * @see #setTime(int,int,int)

 */

public int getHour(){

  return hour;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return millisecond precision of  {@link #getFractionalSecond()}.<\p> <p>This method represents a convenience accessor to infinite precision fractional second value returned by  {@link #getFractionalSecond()}. The returned value is the rounded  down to milliseconds value of  {@link #getFractionalSecond()}. When  {@link #getFractionalSecond()} returns <code>null</code>, this method must return  {@link DatatypeConstants#FIELD_UNDEFINED}.</p> <p>Value constraints for this value are summarized in  <a href="#datetimefield-second">second field of date/time field mapping table</a>.</p>

 * @return Millisecond  of this <code>XMLGregorianCalendar</code>.

 * @see #getFractionalSecond()

 * @see #setTime(int,int,int)

 */

public int getMillisecond(){

  if (fractionalSecond == null) {

    return DatatypeConstants.FIELD_UNDEFINED;

  }

 else {

    return fractionalSecond.movePointRight(3).intValue();

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Return minutes or  {@link DatatypeConstants#FIELD_UNDEFINED}.<\p> Returns  {@link DatatypeConstants#FIELD_UNDEFINED} if this field is not defined.<p>Value constraints for this value are summarized in  <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.</p>

 * @see #setTime(int,int,int)

 */

public int getMinute(){

  return minute;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return number of month or  {@link DatatypeConstants#FIELD_UNDEFINED}.</p> <p>Value constraints for this value are summarized in  <a href="#datetimefield-month">month field of date/time field mapping table</a>.</p>

 * @return year  of this <code>XMLGregorianCalendar</code>.

 */

public int getMonth(){

  return month;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return seconds or  {@link DatatypeConstants#FIELD_UNDEFINED}.<\p> <p>Returns  {@link DatatypeConstants#FIELD_UNDEFINED} if this field is not defined.When this field is not defined, the optional xs:dateTime  fractional seconds field, represented by  {@link #getFractionalSecond()} and {@link #getMillisecond()}, must not be defined.</p> <p>Value constraints for this value are summarized in  <a href="#datetimefield-second">second field of date/time field mapping table</a>.</p>

 * @return Second  of this <code>XMLGregorianCalendar</code>.

 * @see #getFractionalSecond()

 * @see #getMillisecond()

 * @see #setTime(int,int,int)

 */

public int getSecond(){

  return second;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Return timezone offset in minutes or  {@link DatatypeConstants#FIELD_UNDEFINED} if this optional field is not defined.<p>Value constraints for this value are summarized in  <a href="#datetimefield-timezone">timezone field of date/time field mapping table</a>.</p>

 * @see #setTimezone(int)

 */

public int getTimezone(){

  return timezone;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Returns a <code>java.util.TimeZone</code> for this class.</p> <p>If timezone field is defined for this instance,  returns TimeZone initialized with custom timezone id of zoneoffset. If timezone field is undefined,  try the defaultZoneoffset that was passed in.  If defaultZoneoffset is DatatypeConstants.FIELD_UNDEFINED, return default timezone for this host. (Same default as java.util.GregorianCalendar).</p>

 * @param defaultZoneoffset default zoneoffset if this zoneoffset is {@link DatatypeConstants#FIELD_UNDEFINED}.

 * @return TimeZone for this.

 */

public TimeZone getTimeZone(int defaultZoneoffset){

  TimeZone result=null;

  int zoneoffset=getTimezone();

  if (zoneoffset == DatatypeConstants.FIELD_UNDEFINED) {

    zoneoffset=defaultZoneoffset;

  }

  if (zoneoffset == DatatypeConstants.FIELD_UNDEFINED) {

    result=TimeZone.getDefault();

  }

 else {

    char sign=zoneoffset < 0 ? '-' : '+';

    if (sign == '-') {

      zoneoffset=-zoneoffset;

    }

    int hour=zoneoffset / 60;

    int minutes=zoneoffset - (hour * 60);

    StringBuffer customTimezoneId=new StringBuffer(8);

    customTimezoneId.append("GMT");

    customTimezoneId.append(sign);

    customTimezoneId.append(hour);

    if (minutes != 0) {

      if (minutes < 10) {

        customTimezoneId.append('0');

      }

      customTimezoneId.append(minutes);

    }

    result=TimeZone.getTimeZone(customTimezoneId.toString());

  }

  return result;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return the name of the XML Schema date/time type that this instance  maps to. Type is computed based on fields that are set.</p> <table border="2" rules="all" cellpadding="2"> <thead> <tr> <th align="center" colspan="7"> Required fields for XML Schema 1.0 Date/Time Datatypes.<br/> <i>(timezone is optional for all date/time datatypes)</i> </th> </tr> </thead> <tbody> <tr> <td>Datatype</td> <td>year</td> <td>month</td> <td>day</td> <td>hour</td> <td>minute</td> <td>second</td> </tr> <tr> <td> {@link DatatypeConstants#DATETIME}</td> <td>X</td> <td>X</td> <td>X</td> <td>X</td> <td>X</td> <td>X</td> </tr> <tr> <td> {@link DatatypeConstants#DATE}</td> <td>X</td> <td>X</td> <td>X</td> <td></td> <td></td> <td></td> </tr> <tr> <td> {@link DatatypeConstants#TIME}</td> <td></td> <td></td> <td></td> <td>X</td> <td>X</td> <td>X</td> </tr> <tr> <td> {@link DatatypeConstants#GYEARMONTH}</td> <td>X</td> <td>X</td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td> {@link DatatypeConstants#GMONTHDAY}</td> <td></td> <td>X</td> <td>X</td> <td></td> <td></td> <td></td> </tr> <tr> <td> {@link DatatypeConstants#GYEAR}</td> <td>X</td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td> {@link DatatypeConstants#GMONTH}</td> <td></td> <td>X</td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td> {@link DatatypeConstants#GDAY}</td> <td></td> <td></td> <td>X</td> <td></td> <td></td> <td></td> </tr> </tbody> </table>

 * @throws java.lang.IllegalStateException if the combination of set fieldsdoes not match one of the eight defined XML Schema builtin  date/time datatypes.

 * @return One of the following class constants:{@link DatatypeConstants#DATETIME}, {@link DatatypeConstants#TIME}, {@link DatatypeConstants#DATE}, {@link DatatypeConstants#GYEARMONTH}, {@link DatatypeConstants#GMONTHDAY}, {@link DatatypeConstants#GYEAR}, {@link DatatypeConstants#GMONTH} or{@link DatatypeConstants#GDAY}.

 */

public QName getXMLSchemaType(){

  if (year != DatatypeConstants.FIELD_UNDEFINED && month != DatatypeConstants.FIELD_UNDEFINED && day != DatatypeConstants.FIELD_UNDEFINED && hour != DatatypeConstants.FIELD_UNDEFINED && minute != DatatypeConstants.FIELD_UNDEFINED && second != DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.DATETIME;

  }

  if (year != DatatypeConstants.FIELD_UNDEFINED && month != DatatypeConstants.FIELD_UNDEFINED && day != DatatypeConstants.FIELD_UNDEFINED && hour == DatatypeConstants.FIELD_UNDEFINED && minute == DatatypeConstants.FIELD_UNDEFINED && second == DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.DATE;

  }

  if (year == DatatypeConstants.FIELD_UNDEFINED && month == DatatypeConstants.FIELD_UNDEFINED && day == DatatypeConstants.FIELD_UNDEFINED && hour != DatatypeConstants.FIELD_UNDEFINED && minute != DatatypeConstants.FIELD_UNDEFINED && second != DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.TIME;

  }

  if (year != DatatypeConstants.FIELD_UNDEFINED && month != DatatypeConstants.FIELD_UNDEFINED && day == DatatypeConstants.FIELD_UNDEFINED && hour == DatatypeConstants.FIELD_UNDEFINED && minute == DatatypeConstants.FIELD_UNDEFINED && second == DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.GYEARMONTH;

  }

  if (year == DatatypeConstants.FIELD_UNDEFINED && month != DatatypeConstants.FIELD_UNDEFINED && day != DatatypeConstants.FIELD_UNDEFINED && hour == DatatypeConstants.FIELD_UNDEFINED && minute == DatatypeConstants.FIELD_UNDEFINED && second == DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.GMONTHDAY;

  }

  if (year != DatatypeConstants.FIELD_UNDEFINED && month == DatatypeConstants.FIELD_UNDEFINED && day == DatatypeConstants.FIELD_UNDEFINED && hour == DatatypeConstants.FIELD_UNDEFINED && minute == DatatypeConstants.FIELD_UNDEFINED && second == DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.GYEAR;

  }

  if (year == DatatypeConstants.FIELD_UNDEFINED && month != DatatypeConstants.FIELD_UNDEFINED && day == DatatypeConstants.FIELD_UNDEFINED && hour == DatatypeConstants.FIELD_UNDEFINED && minute == DatatypeConstants.FIELD_UNDEFINED && second == DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.GMONTH;

  }

  if (year == DatatypeConstants.FIELD_UNDEFINED && month == DatatypeConstants.FIELD_UNDEFINED && day != DatatypeConstants.FIELD_UNDEFINED && hour == DatatypeConstants.FIELD_UNDEFINED && minute == DatatypeConstants.FIELD_UNDEFINED && second == DatatypeConstants.FIELD_UNDEFINED) {

    return DatatypeConstants.GDAY;

  }

  throw new IllegalStateException(this.getClass().getName() + "#getXMLSchemaType() :" + DatatypeMessageFormatter.formatMessage(null,"InvalidXGCFields",null));

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return low order component for XML Schema 1.0 dateTime datatype field for  <code>year</code> or  {@link DatatypeConstants#FIELD_UNDEFINED}.</p> <p>Value constraints for this value are summarized in  <a href="#datetimefield-year">year field of date/time field mapping table</a>.</p>

 * @return year  of this <code>XMLGregorianCalendar</code>.

 * @see #getEon()

 * @see #getEonAndYear()

 */

public int getYear(){

  return year;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Implements Step B from http://www.w3.org/TR/xmlschema-2/#dateTime-order </p>

 * @param P calendar instance with normalized timezone offset or having same timezone as Q

 * @param Q calendar instance with normalized timezone offset or having same timezone as P

 * @return result of comparing P and Q, value of{@link DatatypeConstants#EQUAL}, {@link DatatypeConstants#LESSER}, {@link DatatypeConstants#GREATER} or {@link DatatypeConstants#INDETERMINATE}.

 */

private static int internalCompare(XMLGregorianCalendar P,XMLGregorianCalendar Q){

  int result;

  if (P.getEon() == Q.getEon()) {

    result=compareField(P.getYear(),Q.getYear());

    if (result != DatatypeConstants.EQUAL) {

      return result;

    }

  }

 else {

    result=compareField(P.getEonAndYear(),Q.getEonAndYear());

    if (result != DatatypeConstants.EQUAL) {

      return result;

    }

  }

  result=compareField(P.getMonth(),Q.getMonth());

  if (result != DatatypeConstants.EQUAL) {

    return result;

  }

  result=compareField(P.getDay(),Q.getDay());

  if (result != DatatypeConstants.EQUAL) {

    return result;

  }

  result=compareField(P.getHour(),Q.getHour());

  if (result != DatatypeConstants.EQUAL) {

    return result;

  }

  result=compareField(P.getMinute(),Q.getMinute());

  if (result != DatatypeConstants.EQUAL) {

    return result;

  }

  result=compareField(P.getSecond(),Q.getSecond());

  if (result != DatatypeConstants.EQUAL) {

    return result;

  }

  result=compareField(P.getFractionalSecond(),Q.getFractionalSecond());

  return result;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Validate instance by <code>getXMLSchemaType()</code> constraints.

 * @return true if data values are valid.

 */

public boolean isValid(){

  if (month != DatatypeConstants.FIELD_UNDEFINED && day != DatatypeConstants.FIELD_UNDEFINED) {

    if (year != DatatypeConstants.FIELD_UNDEFINED) {

      if (eon == null) {

        if (day > maximumDayInMonthFor(year,month)) {

          return false;

        }

      }

 else       if (day > maximumDayInMonthFor(getEonAndYear(),month)) {

        return false;

      }

    }

 else     if (day > maximumDayInMonthFor(2000,month)) {

      return false;

    }

  }

  if (hour == 24 && (minute != 0 || second != 0 || (fractionalSecond != null && fractionalSecond.compareTo(DECIMAL_ZERO) != 0))) {

    return false;

  }

  if (eon == null && year == 0) {

    return false;

  }

  return true;

}

Location: XMLGregorianCalendarImpl.java

Content: 

private static int maximumDayInMonthFor(BigInteger year,int month){

  if (month != DatatypeConstants.FEBRUARY) {

    return DaysInMonth.table[month];

  }

 else {

    if (year.mod(FOUR_HUNDRED).equals(BigInteger.ZERO) || (!year.mod(HUNDRED).equals(BigInteger.ZERO) && year.mod(FOUR).equals(BigInteger.ZERO))) {

      return 29;

    }

 else {

      return DaysInMonth.table[month];

    }

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

private static int maximumDayInMonthFor(int year,int month){

  if (month != DatatypeConstants.FEBRUARY) {

    return DaysInMonth.table[month];

  }

 else {

    if (((year % 400) == 0) || (((year % 100) != 0) && ((year % 4) == 0))) {

      return 29;

    }

 else {

      return DaysInMonth.table[DatatypeConstants.FEBRUARY];

    }

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Normalize this instance to UTC.</p> <p>2000-03-04T23:00:00+03:00 normalizes to 2000-03-04T20:00:00Z</p> <p>Implements W3C XML Schema Part 2, Section 3.2.7.3 (A).</p>

 */

private XMLGregorianCalendar normalizeToTimezone(XMLGregorianCalendar cal,int timezone){

  int minutes=timezone;

  XMLGregorianCalendar result=(XMLGregorianCalendar)cal.clone();

  minutes=-minutes;

  Duration d=new DurationImpl(minutes >= 0,0,0,0,0,minutes < 0 ? -minutes : minutes,0);

  result.add(d);

  result.setTimezone(0);

  return result;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Prints an BigInteger as a String. 

 * @param out The formatted string will be appended into this buffer.

 * @param number The integer to be printed. 

 * @param nDigits The field will be printed by using at least this number of digits. For example, 5 will be printed as "0005" if nDigits==4. 

 */

private void printNumber(StringBuffer out,BigInteger number,int nDigits){

  String s=number.toString();

  for (int i=s.length(); i < nDigits; i++) {

    out.append('0');

  }

  out.append(s);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Prints an integer as a String. 

 * @param out The formatted string will be appended into this buffer.

 * @param number The integer to be printed. 

 * @param nDigits The field will be printed by using at least this number of digits. For example, 5 will be printed as "0005" if nDigits==4. 

 */

private void printNumber(StringBuffer out,int number,int nDigits){

  String s=String.valueOf(number);

  for (int i=s.length(); i < nDigits; i++) {

    out.append('0');

  }

  out.append(s);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Compute <code>value*signum</code> where value==null is treated as value==0.

 * @return non-null {@link BigInteger}.

 */

static BigInteger sanitize(Number value,int signum){

  if (signum == 0 || value == null) {

    return BigInteger.ZERO;

  }

  return (signum < 0) ? ((BigInteger)value).negate() : (BigInteger)value;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 */

private void save(){

  orig_eon=eon;

  orig_year=year;

  orig_month=month;

  orig_day=day;

  orig_hour=hour;

  orig_minute=minute;

  orig_second=second;

  orig_fracSeconds=fractionalSecond;

  orig_timezone=timezone;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set days in month.</p> <p>Unset this field by invoking the setter with a parameter value of  {@link DatatypeConstants#FIELD_UNDEFINED}.</p>

 * @param day value constraints summarized in <a href="#datetimefield-day">day field of date/time field mapping table</a>.

 * @throws IllegalArgumentException if <code>day</code> parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public void setDay(int day){

  checkFieldValueConstraint(DAY,day);

  this.day=day;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set high order part of XSD <code>dateTime</code> year field.</p> <p>Unset this field by invoking the setter with a parameter value of  <code>null</code>.</p>

 * @param eon value constraints summarized in <a href="#datetimefield-year">year field of date/time field mapping table</a>.

 */

private void setEon(BigInteger eon){

  if (eon != null && eon.compareTo(BigInteger.ZERO) == 0) {

    this.eon=null;

  }

 else {

    this.eon=eon;

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

public void setFractionalSecond(BigDecimal fractional){

  if (fractional != null) {

    if ((fractional.compareTo(DECIMAL_ZERO) < 0) || (fractional.compareTo(DECIMAL_ONE) > 0)) {

      throw new IllegalArgumentException(DatatypeMessageFormatter.formatMessage(null,"InvalidFractional",new Object[]{fractional}));

    }

  }

  this.fractionalSecond=fractional;

}

Location: XMLGregorianCalendarImpl.java

Content: 

public void setHour(int hour){

  checkFieldValueConstraint(HOUR,hour);

  this.hour=hour;

}

Location: XMLGregorianCalendarImpl.java

Content: 

public void setMillisecond(int millisecond){

  if (millisecond == DatatypeConstants.FIELD_UNDEFINED) {

    fractionalSecond=null;

  }

 else {

    checkFieldValueConstraint(MILLISECOND,millisecond);

    fractionalSecond=BigDecimal.valueOf(millisecond,3);

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

public void setMinute(int minute){

  checkFieldValueConstraint(MINUTE,minute);

  this.minute=minute;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set month.</p> <p>Unset this field by invoking the setter with a parameter value of  {@link DatatypeConstants#FIELD_UNDEFINED}.</p>

 * @param month value constraints summarized in <a href="#datetimefield-month">month field of date/time field mapping table</a>.

 * @throws IllegalArgumentException if <code>month</code> parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public void setMonth(int month){

  checkFieldValueConstraint(MONTH,month);

  this.month=month;

}

Location: XMLGregorianCalendarImpl.java

Content: 

public void setSecond(int second){

  checkFieldValueConstraint(SECOND,second);

  this.second=second;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set the number of minutes in the timezone offset.</p> <p>Unset this field by invoking the setter with a parameter value of  {@link DatatypeConstants#FIELD_UNDEFINED}.</p>

 * @param offset value constraints summarized in <a href="#datetimefield-timezone">timezone field of date/time field mapping table</a>.

 * @throws IllegalArgumentException if <code>offset</code> parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public void setTimezone(int offset){

  checkFieldValueConstraint(TIMEZONE,offset);

  this.timezone=offset;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set time as one unit.</p>

 * @param hour value constraints are summarized in <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.

 * @param minute value constraints are summarized in <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.

 * @param second value constraints are summarized in <a href="#datetimefield-second">second field of date/time field mapping table</a>.

 * @see #setTime(int,int,int,BigDecimal)

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public void setTime(int hour,int minute,int second){

  setTime(hour,minute,second,null);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set time as one unit, including the optional infinite precison  fractional seconds.</p>

 * @param hour value constraints are summarized in <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.

 * @param minute value constraints are summarized in <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.

 * @param second value constraints are summarized in <a href="#datetimefield-second">second field of date/time field mapping table</a>.

 * @param fractional value of <code>null</code> indicates this optional field is not set.

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public void setTime(int hour,int minute,int second,BigDecimal fractional){

  setHour(hour);

  setMinute(minute);

  setSecond(second);

  setFractionalSecond(fractional);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set time as one unit, including optional milliseconds.</p>

 * @param hour value constraints are summarized in <a href="#datetimefield-hour">hour field of date/time field mapping table</a>.

 * @param minute value constraints are summarized in <a href="#datetimefield-minute">minute field of date/time field mapping table</a>.

 * @param second value constraints are summarized in <a href="#datetimefield-second">second field of date/time field mapping table</a>.

 * @param millisecond value of {@link DatatypeConstants#FIELD_UNDEFINED} indicates this optional field is not set. 

 * @throws IllegalArgumentException if any parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public void setTime(int hour,int minute,int second,int millisecond){

  setHour(hour);

  setMinute(minute);

  setSecond(second);

  setMillisecond(millisecond);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set low and high order component of XSD <code>dateTime</code> year field.</p> <p>Unset this field by invoking the setter with a parameter value of <code>null</code>.</p>

 * @param year value constraints summarized in <a href="#datetimefield-year">year field of date/time field mapping table</a>.     

 * @throws IllegalArgumentException if <code>year</code> parameter is outside value constraints for the field as specified in  <a href="#datetimefieldmapping">date/time field mapping table</a>.

 */

public void setYear(BigInteger year){

  if (year == null) {

    this.eon=null;

    this.year=DatatypeConstants.FIELD_UNDEFINED;

  }

 else {

    BigInteger temp=year.remainder(BILLION_B);

    this.year=temp.intValue();

    setEon(year.subtract(temp));

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Set year of XSD <code>dateTime</code> year field.</p> <p>Unset this field by invoking the setter with a parameter value of  {@link DatatypeConstants#FIELD_UNDEFINED}.</p> <p>Note: if the absolute value of the <code>year</code> parameter  is less than 10^9, the eon component of the XSD year field is set to  <code>null</code> by this method.</p>

 * @param year value constraints are summarized in <a href="#datetimefield-year">year field of date/time field mapping table</a>.If year is  {@link DatatypeConstants#FIELD_UNDEFINED}, then eon is set to <code>null</code>.

 */

public void setYear(int year){

  if (year == DatatypeConstants.FIELD_UNDEFINED) {

    this.year=DatatypeConstants.FIELD_UNDEFINED;

    this.eon=null;

  }

 else   if (Math.abs(year) < BILLION_I) {

    this.year=year;

    this.eon=null;

  }

 else {

    BigInteger theYear=BigInteger.valueOf((long)year);

    BigInteger remainder=theYear.remainder(BILLION_B);

    this.year=remainder.intValue();

    setEon(theYear.subtract(remainder));

  }

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Convert <code>this</code> to <code>java.util.GregorianCalendar</code>.</p> <p>When <code>this</code> instance has an undefined field, this conversion relies on the <code>java.util.GregorianCalendar</code> default  for its corresponding field. A notable difference between XML Schema 1.0 date/time datatypes and <code>java.util.GregorianCalendar</code> is that Timezone value is optional for date/time datatypes and it is a required field for <code>java.util.GregorianCalendar</code>. See javadoc for <code>java.util.TimeZone.getDefault()</code> on how the default is determined. To explicitly specify the <code>TimeZone</code> instance, see  {@link #toGregorianCalendar(TimeZone,Locale,XMLGregorianCalendar)}.</p> <table border="2" rules="all" cellpadding="2"> <thead> <tr> <th align="center" colspan="2"> Field by Field Conversion from this class to  <code>java.util.GregorianCalendar</code> </th> </tr> </thead> <tbody> <tr> <th><code>java.util.GregorianCalendar</code> field</th> <th><code>javax.xml.datatype.XMLGregorianCalendar</code> field</th> </tr> <tr> <th><code>ERA</code></th> <th> {@link #getEonAndYear()}<code>.signum() < 0 ? GregorianCalendar.BC : GregorianCalendar.AD</code></th> </tr> <tr> <th><code>YEAR</code></th> <th> {@link #getEonAndYear()}<code>.abs().intValue()</code><i>*</i></th> </tr> <tr> <th><code>MONTH</code></th> <th> {@link #getMonth()}<code> - 1</code></th> </tr> <tr> <th><code>DAY_OF_MONTH</code></th> <th> {@link #getDay()}</th> </tr> <tr> <th><code>AM_PM</code></th> <th> {@link #getHour()} < 12 : Calendar.AM : Calendar.PM</th></tr> <tr> <th><code>HOUR_OF_DAY</code></th> <th> {@link #getHour()}</th> </tr> <tr> <th><code>MINUTE</code></th> <th> {@link #getMinute()}</th> </tr> <tr> <th><code>SECOND</code></th> <th> {@link #getSecond()}</th> </tr> <tr> <th><code>MILLISECOND</code></th> <th>get millisecond order from  {@link #getFractionalSecond()}<i>*</i> </th> </tr> <tr> <th><code>GregorianCalendar.setTimeZone(TimeZone)</code></th> <th> {@link #getTimezone()} formatted into Custom timezone id</th></tr> </tbody> </table> <i>*</i> designates possible loss of precision during the conversion due to source datatype having higer precison than target datatype. <p>To ensure consistency in conversion implementations, the new <code>GregorianCalendar</code> should be instantiated in following manner. <ul> <li>Using <code>timeZone</code> value as defined above, create a new  <code>java.util.GregorianCalendar(timeZone,Locale.getDefault())</code>. </li> <li>Initialize all GregorianCalendar fields by calling {(@link GegorianCalendar#clear()}.</li> <li>Obtain a pure Gregorian Calendar by invoking <code>GregorianCalendar.setGregorianChange( new Date(Long.MIN_VALUE))</code>.</li> <li>Its fields ERA, YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY,  MINUTE, SECOND and MILLISECOND are set using the method  <code>Calendar.set(int,int)</code></li> </ul> </p>

 * @see #toGregorianCalendar(java.util.TimeZone,java.util.Locale,XMLGregorianCalendar)

 */

public java.util.GregorianCalendar toGregorianCalendar(){

  GregorianCalendar result=null;

  final int DEFAULT_TIMEZONE_OFFSET=DatatypeConstants.FIELD_UNDEFINED;

  TimeZone tz=getTimeZone(DEFAULT_TIMEZONE_OFFSET);

  Locale locale=java.util.Locale.getDefault();

  result=new GregorianCalendar(tz,locale);

  result.clear();

  result.setGregorianChange(PURE_GREGORIAN_CHANGE);

  if (year != DatatypeConstants.FIELD_UNDEFINED) {

    if (eon == null) {

      result.set(Calendar.ERA,year < 0 ? GregorianCalendar.BC : GregorianCalendar.AD);

      result.set(Calendar.YEAR,Math.abs(year));

    }

 else {

      BigInteger eonAndYear=getEonAndYear();

      result.set(Calendar.ERA,eonAndYear.signum() == -1 ? GregorianCalendar.BC : GregorianCalendar.AD);

      result.set(Calendar.YEAR,eonAndYear.abs().intValue());

    }

  }

  if (month != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.MONTH,month - 1);

  }

  if (day != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.DAY_OF_MONTH,day);

  }

  if (hour != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.HOUR_OF_DAY,hour);

  }

  if (minute != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.MINUTE,minute);

  }

  if (second != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.SECOND,second);

  }

  if (fractionalSecond != null) {

    result.set(Calendar.MILLISECOND,getMillisecond());

  }

  return result;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Convert <code>this</code> along with provided parameters to <code>java.util.GregorianCalendar</code> instance.</p> <p> Since XML Schema 1.0 date/time datetypes has no concept of timezone ids or daylight savings timezone ids, this conversion operation allows the user to explicitly specify one with <code>timezone</code> parameter.</p> <p>To compute the return value's <code>TimeZone</code> field, <ul> <li>when parameter <code>timeZone</code> is non-null,  it is the timezone field.</li> <li>else when <code>this.getTimezone() != DatatypeConstants.FIELD_UNDEFINED</code>, create a <code>java.util.TimeZone</code> with a custom timezone id  using the <code>this.getTimezone()</code>.</li> <li>else when <code>defaults.getTimezone() != DatatypeConstants.FIELD_UNDEFINED</code>,  create a <code>java.util.TimeZone</code> with a custom timezone id  using <code>defaults.getTimezone()</code>.</li> <li>else use the <code>GregorianCalendar</code> default timezone value  for the host is definedas specified by  <code>java.util.TimeZone.getDefault()</code>.</li></p> <p>To ensure consistency in conversion implementations, the new <code>GregorianCalendar</code> should be instantiated in following manner. <ul> <li>Create a new <code>java.util.GregorianCalendar(TimeZone,  Locale)</code> with TimeZone set as specified above and the <code>Locale</code> parameter.  </li> <li>Initialize all GregorianCalendar fields by calling {(@link GegorianCalendar#clear()}.</li> <li>Obtain a pure Gregorian Calendar by invoking <code>GregorianCalendar.setGregorianChange( new Date(Long.MIN_VALUE))</code>.</li> <li>Its fields ERA, YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY,  MINUTE, SECOND and MILLISECOND are set using the method  <code>Calendar.set(int,int)</code></li> </ul>

 * @param timezone provide Timezone. <code>null</code> is a legal value.

 * @param aLocale  provide explicit Locale. Use default GregorianCalendar locale ifvalue is <code>null</code>.

 * @param defaults provide default field values to use when correspondingfield for this instance is DatatypeConstants.FIELD_UNDEFINED or null.  If <code>defaults</code>is <code>null</code> or a field within the specified <code>defaults</code> is undefined, just use <code>java.util.GregorianCalendar</code> defaults.

 * @return a java.util.GregorianCalendar conversion of this instance.

 * @see #LEAP_YEAR_DEFAULT

 */

public GregorianCalendar toGregorianCalendar(java.util.TimeZone timezone,java.util.Locale aLocale,XMLGregorianCalendar defaults){

  GregorianCalendar result=null;

  TimeZone tz=timezone;

  if (tz == null) {

    int defaultZoneoffset=DatatypeConstants.FIELD_UNDEFINED;

    if (defaults != null) {

      defaultZoneoffset=defaults.getTimezone();

    }

    tz=getTimeZone(defaultZoneoffset);

  }

  if (aLocale == null) {

    aLocale=java.util.Locale.getDefault();

  }

  result=new GregorianCalendar(tz,aLocale);

  result.clear();

  result.setGregorianChange(PURE_GREGORIAN_CHANGE);

  if (year != DatatypeConstants.FIELD_UNDEFINED) {

    if (eon == null) {

      result.set(Calendar.ERA,year < 0 ? GregorianCalendar.BC : GregorianCalendar.AD);

      result.set(Calendar.YEAR,Math.abs(year));

    }

 else {

      final BigInteger eonAndYear=getEonAndYear();

      result.set(Calendar.ERA,eonAndYear.signum() == -1 ? GregorianCalendar.BC : GregorianCalendar.AD);

      result.set(Calendar.YEAR,eonAndYear.abs().intValue());

    }

  }

 else {

    if (defaults != null) {

      final int defaultYear=defaults.getYear();

      if (defaultYear != DatatypeConstants.FIELD_UNDEFINED) {

        if (defaults.getEon() == null) {

          result.set(Calendar.ERA,defaultYear < 0 ? GregorianCalendar.BC : GregorianCalendar.AD);

          result.set(Calendar.YEAR,Math.abs(defaultYear));

        }

 else {

          final BigInteger defaultEonAndYear=defaults.getEonAndYear();

          result.set(Calendar.ERA,defaultEonAndYear.signum() == -1 ? GregorianCalendar.BC : GregorianCalendar.AD);

          result.set(Calendar.YEAR,defaultEonAndYear.abs().intValue());

        }

      }

    }

  }

  if (month != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.MONTH,month - 1);

  }

 else {

    final int defaultMonth=(defaults != null) ? defaults.getMonth() : DatatypeConstants.FIELD_UNDEFINED;

    if (defaultMonth != DatatypeConstants.FIELD_UNDEFINED) {

      result.set(Calendar.MONTH,defaultMonth - 1);

    }

  }

  if (day != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.DAY_OF_MONTH,day);

  }

 else {

    final int defaultDay=(defaults != null) ? defaults.getDay() : DatatypeConstants.FIELD_UNDEFINED;

    if (defaultDay != DatatypeConstants.FIELD_UNDEFINED) {

      result.set(Calendar.DAY_OF_MONTH,defaultDay);

    }

  }

  if (hour != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.HOUR_OF_DAY,hour);

  }

 else {

    int defaultHour=(defaults != null) ? defaults.getHour() : DatatypeConstants.FIELD_UNDEFINED;

    if (defaultHour != DatatypeConstants.FIELD_UNDEFINED) {

      result.set(Calendar.HOUR_OF_DAY,defaultHour);

    }

  }

  if (minute != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.MINUTE,minute);

  }

 else {

    final int defaultMinute=(defaults != null) ? defaults.getMinute() : DatatypeConstants.FIELD_UNDEFINED;

    if (defaultMinute != DatatypeConstants.FIELD_UNDEFINED) {

      result.set(Calendar.MINUTE,defaultMinute);

    }

  }

  if (second != DatatypeConstants.FIELD_UNDEFINED) {

    result.set(Calendar.SECOND,second);

  }

 else {

    final int defaultSecond=(defaults != null) ? defaults.getSecond() : DatatypeConstants.FIELD_UNDEFINED;

    if (defaultSecond != DatatypeConstants.FIELD_UNDEFINED) {

      result.set(Calendar.SECOND,defaultSecond);

    }

  }

  if (fractionalSecond != null) {

    result.set(Calendar.MILLISECOND,getMillisecond());

  }

 else {

    final BigDecimal defaultFractionalSecond=(defaults != null) ? defaults.getFractionalSecond() : null;

    if (defaultFractionalSecond != null) {

      result.set(Calendar.MILLISECOND,defaults.getMillisecond());

    }

  }

  return result;

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Turns  {@link BigDecimal} to a string representation.</p><p>Due to a behavior change in the  {@link BigDecimal#toString()}method in JDK1.5, this had to be implemented here.</p>

 * @param bd <code>BigDecimal</code> to format as a <code>String</code>

 * @return  <code>String</code> representation of <code>BigDecimal</code> 

 */

private String toString(BigDecimal bd){

  String intString=bd.unscaledValue().toString();

  int scale=bd.scale();

  if (scale == 0) {

    return intString;

  }

  StringBuffer buf;

  int insertionPoint=intString.length() - scale;

  if (insertionPoint == 0) {

    return "0." + intString;

  }

 else   if (insertionPoint > 0) {

    buf=new StringBuffer(intString);

    buf.insert(insertionPoint,'.');

  }

 else {

    buf=new StringBuffer(3 - insertionPoint + intString.length());

    buf.append("0.");

    for (int i=0; i < -insertionPoint; i++) {

      buf.append('0');

    }

    buf.append(intString);

  }

  return buf.toString();

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Return the lexical representation of <code>this</code> instance.  The format is specified in  <a href="http://www.w3.org/TR/xmlschema-2/#dateTime-order">XML Schema 1.0 Part 2, Section 3.2.[7-14].1, <i>Lexical Representation</i>".</a></p> <p>Specific target lexical representation format is determined by  {@link #getXMLSchemaType()}.</p>

 * @return XML, as <code>String</code>, representation of this <code>XMLGregorianCalendar</code> 

 * @throws java.lang.IllegalStateException if the combination of set fieldsdoes not match one of the eight defined XML Schema builtin date/time datatypes. 

 */

public String toXMLFormat(){

  QName typekind=getXMLSchemaType();

  String formatString=null;

  if (typekind == DatatypeConstants.DATETIME) {

    formatString="%Y-%M-%DT%h:%m:%s" + "%z";

  }

 else   if (typekind == DatatypeConstants.DATE) {

    formatString="%Y-%M-%D" + "%z";

  }

 else   if (typekind == DatatypeConstants.TIME) {

    formatString="%h:%m:%s" + "%z";

  }

 else   if (typekind == DatatypeConstants.GMONTH) {

    formatString="--%M--%z";

  }

 else   if (typekind == DatatypeConstants.GDAY) {

    formatString="---%D" + "%z";

  }

 else   if (typekind == DatatypeConstants.GYEAR) {

    formatString="%Y" + "%z";

  }

 else   if (typekind == DatatypeConstants.GYEARMONTH) {

    formatString="%Y-%M" + "%z";

  }

 else   if (typekind == DatatypeConstants.GMONTHDAY) {

    formatString="--%M-%D" + "%z";

  }

  return format(formatString);

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Writes  {@link XMLGregorianCalendar} as a lexical representationfor maximum future compatibility.

 * @return An object that encapsulates the string returned by <code>this.toXMLFormat()</code>.

 */

private Object writeReplace() throws IOException {

  return new SerializedXMLGregorianCalendar(toXMLFormat());

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Create an instance with all date/time datatype fields set to  {@link DatatypeConstants#FIELD_UNDEFINED} or null respectively.</p>

 */

public XMLGregorianCalendarImpl(){

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Private constructor allowing for complete value spaces allowed by  W3C XML Schema 1.0 recommendation for xsd:dateTime and related  builtin datatypes. Note that <code>year</code> parameter supports arbitrarily large numbers and fractionalSecond has infinite  precision.</p>

 * @param year of <code>XMLGregorianCalendar</code> to be created.

 * @param month of <code>XMLGregorianCalendar</code> to be created.

 * @param day of <code>XMLGregorianCalendar</code> to be created.

 * @param hour of <code>XMLGregorianCalendar</code> to be created.

 * @param minute of <code>XMLGregorianCalendar</code> to be created.

 * @param second of <code>XMLGregorianCalendar</code> to be created.

 * @param fractionalSecond of <code>XMLGregorianCalendar</code> to be created.

 * @param timezone of <code>XMLGregorianCalendar</code> to be created.

 */

protected XMLGregorianCalendarImpl(BigInteger year,int month,int day,int hour,int minute,int second,BigDecimal fractionalSecond,int timezone){

  setYear(year);

  setMonth(month);

  setDay(day);

  setTime(hour,minute,second,fractionalSecond);

  setTimezone(timezone);

  if (!isValid()) {

    throw new IllegalArgumentException(DatatypeMessageFormatter.formatMessage(null,"InvalidXGCValue-fractional",new Object[]{year,new Integer(month),new Integer(day),new Integer(hour),new Integer(minute),new Integer(second),fractionalSecond,new Integer(timezone)}));

  }

  save();

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Convert a <code>java.util.GregorianCalendar</code> to XML Schema 1.0  representation.</p> <table border="2" rules="all" cellpadding="2"> <thead> <tr> <th align="center" colspan="2"> Field by Field Conversion from <code>java.util.GregorianCalendar</code> to this class  </th> </tr> </thead> <tbody> <tr> <th><code>javax.xml.datatype.XMLGregorianCalendar</code> field</th> <th><code>java.util.GregorianCalendar</code> field</th> </tr> <tr> <th> {@link #setYear(int)}</th> <th><code>ERA == GregorianCalendar.BC ? -YEAR : YEAR</code></th> </tr> <tr> <th> {@link #setMonth(int)}</th> <th><code>MONTH + 1</code></th> </tr> <tr> <th> {@link #setDay(int)}</th> <th><code>DAY_OF_MONTH</code></th> </tr> <tr> <th> {@link #setTime(int,int,int,BigDecimal)}</th> <th><code>HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND</code></th> </tr> <tr> <th> {@link #setTimezone(int)}<i>*</i></th> <th><code>(ZONE_OFFSET + DST_OFFSET) / (60*1000)</code><br/> <i>(in minutes)</i> </th> </tr> </tbody> </table> <p><i>*</i>conversion loss of information. It is not possible to represent  a <code>java.util.GregorianCalendar</code> daylight savings timezone id in the  XML Schema 1.0 date/time datatype representation.</p> <p>To compute the return value's <code>TimeZone</code> field, <ul> <li>when <code>this.getTimezone() != DatatypeConstants.FIELD_UNDEFINED</code>, create a <code>java.util.TimeZone</code> with a custom timezone id  using the <code>this.getTimezone()</code>.</li> <li>else use the <code>GregorianCalendar</code> default timezone value  for the host is defined as specified by  <code>java.util.TimeZone.getDefault()</code>.</li></p>     

 * @param cal <code>java.util.GregorianCalendar</code> used to create <code>XMLGregorianCalendar</code>

 */

public XMLGregorianCalendarImpl(GregorianCalendar cal){

  int year=cal.get(Calendar.YEAR);

  if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {

    year=-year;

  }

  this.setYear(year);

  this.setMonth(cal.get(Calendar.MONTH) + 1);

  this.setDay(cal.get(Calendar.DAY_OF_MONTH));

  this.setTime(cal.get(Calendar.HOUR_OF_DAY),cal.get(Calendar.MINUTE),cal.get(Calendar.SECOND),cal.get(Calendar.MILLISECOND));

  int offsetInMinutes=(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / (60 * 1000);

  this.setTimezone(offsetInMinutes);

  save();

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * <p>Private constructor of value spaces that a <code>java.util.GregorianCalendar</code> instance would need to convert to an <code>XMLGregorianCalendar</code> instance.</p> <p><code>XMLGregorianCalendar eon</code> and  <code>fractionalSecond</code> are set to <code>null</code></p>

 * @param year of <code>XMLGregorianCalendar</code> to be created.

 * @param month of <code>XMLGregorianCalendar</code> to be created.

 * @param day of <code>XMLGregorianCalendar</code> to be created.

 * @param hour of <code>XMLGregorianCalendar</code> to be created.

 * @param minute of <code>XMLGregorianCalendar</code> to be created.

 * @param second of <code>XMLGregorianCalendar</code> to be created.

 * @param millisecond of <code>XMLGregorianCalendar</code> to be created.

 * @param timezone of <code>XMLGregorianCalendar</code> to be created.

 */

private XMLGregorianCalendarImpl(int year,int month,int day,int hour,int minute,int second,int millisecond,int timezone){

  setYear(year);

  setMonth(month);

  setDay(day);

  setTime(hour,minute,second);

  setTimezone(timezone);

  BigDecimal realMilliseconds=null;

  if (millisecond != DatatypeConstants.FIELD_UNDEFINED) {

    realMilliseconds=BigDecimal.valueOf(millisecond,3);

  }

  setFractionalSecond(realMilliseconds);

  if (!isValid()) {

    throw new IllegalArgumentException(DatatypeMessageFormatter.formatMessage(null,"InvalidXGCValue-milli",new Object[]{new Integer(year),new Integer(month),new Integer(day),new Integer(hour),new Integer(minute),new Integer(second),new Integer(millisecond),new Integer(timezone)}));

  }

  save();

}

Location: XMLGregorianCalendarImpl.java

Content: 

/** 

 * Constructs a new XMLGregorianCalendar object. String parsing documented by  {@link #parse(String)}. Returns a non-null valid XMLGregorianCalendar object that holds the  value indicated by the lexicalRepresentation parameter.

 * @param lexicalRepresentation Lexical representation of one the eight XML Schema date/time datatypes.

 * @throws IllegalArgumentException If the given string does not conform as documented in  {@link #parse(String)}.

 * @throws NullPointerException If the given string is null.

 */

protected XMLGregorianCalendarImpl(String lexicalRepresentation) throws IllegalArgumentException {

  String format=null;

  String lexRep=lexicalRepresentation;

  final int NOT_FOUND=-1;

  int lexRepLength=lexRep.length();

  if (lexRep.indexOf('T') != NOT_FOUND) {

    format="%Y-%M-%DT%h:%m:%s" + "%z";

  }

 else   if (lexRepLength >= 3 && lexRep.charAt(2) == ':') {

    format="%h:%m:%s" + "%z";

  }

 else   if (lexRep.startsWith("--")) {

    if (lexRepLength >= 3 && lexRep.charAt(2) == '-') {

      format="---%D" + "%z";

    }

 else     if (lexRepLength == 4 || (lexRepLength >= 6 && (lexRep.charAt(4) == '+' || (lexRep.charAt(4) == '-' && (lexRep.charAt(5) == '-' || lexRepLength == 10))))) {

      format="--%M--%z";

      Parser p=new Parser(format,lexRep);

      try {

        p.parse();

        if (!isValid()) {

          throw new IllegalArgumentException(DatatypeMessageFormatter.formatMessage(null,"InvalidXGCRepresentation",new Object[]{lexicalRepresentation}));

        }

        save();

        return;

      }

 catch (      IllegalArgumentException e) {

        format="--%M%z";

      }

    }

 else {

      format="--%M-%D" + "%z";

    }

  }

 else {

    int countSeparator=0;

    int timezoneOffset=lexRep.indexOf(':');

    if (timezoneOffset != NOT_FOUND) {

      lexRepLength-=6;

    }

    for (int i=1; i < lexRepLength; i++) {

      if (lexRep.charAt(i) == '-') {

        countSeparator++;

      }

    }

    if (countSeparator == 0) {

      format="%Y" + "%z";

    }

 else     if (countSeparator == 1) {

      format="%Y-%M" + "%z";

    }

 else {

      format="%Y-%M-%D" + "%z";

    }

  }

  Parser p=new Parser(format,lexRep);

  p.parse();

  if (!isValid()) {

    throw new IllegalArgumentException(DatatypeMessageFormatter.formatMessage(null,"InvalidXGCRepresentation",new Object[]{lexicalRepresentation}));

  }

  save();

}

