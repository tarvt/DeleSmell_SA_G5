Location: URI.java

Content: 

/** 

 * Absolutize URI with given base URI.

 * @param p_base base URI for absolutization

 */

public void absolutize(URI p_base){

  if (m_path.length() == 0 && m_scheme == null && m_host == null && m_regAuthority == null) {

    m_scheme=p_base.getScheme();

    m_userinfo=p_base.getUserinfo();

    m_host=p_base.getHost();

    m_port=p_base.getPort();

    m_regAuthority=p_base.getRegBasedAuthority();

    m_path=p_base.getPath();

    if (m_queryString == null) {

      m_queryString=p_base.getQueryString();

      if (m_fragment == null) {

        m_fragment=p_base.getFragment();

      }

    }

    return;

  }

  if (m_scheme == null) {

    m_scheme=p_base.getScheme();

  }

 else {

    return;

  }

  if (m_host == null && m_regAuthority == null) {

    m_userinfo=p_base.getUserinfo();

    m_host=p_base.getHost();

    m_port=p_base.getPort();

    m_regAuthority=p_base.getRegBasedAuthority();

  }

 else {

    return;

  }

  if (m_path.length() > 0 && m_path.startsWith("/")) {

    return;

  }

  String path="";

  String basePath=p_base.getPath();

  if (basePath != null && basePath.length() > 0) {

    int lastSlash=basePath.lastIndexOf('/');

    if (lastSlash != -1) {

      path=basePath.substring(0,lastSlash + 1);

    }

  }

 else   if (m_path.length() > 0) {

    path="/";

  }

  path=path.concat(m_path);

  int index=-1;

  while ((index=path.indexOf("/./")) != -1) {

    path=path.substring(0,index + 1).concat(path.substring(index + 3));

  }

  if (path.endsWith("/.")) {

    path=path.substring(0,path.length() - 1);

  }

  index=1;

  int segIndex=-1;

  String tempString=null;

  while ((index=path.indexOf("/../",index)) > 0) {

    tempString=path.substring(0,path.indexOf("/../"));

    segIndex=tempString.lastIndexOf('/');

    if (segIndex != -1) {

      if (!tempString.substring(segIndex).equals("..")) {

        path=path.substring(0,segIndex + 1).concat(path.substring(index + 4));

        index=segIndex;

      }

 else {

        index+=4;

      }

    }

 else {

      index+=4;

    }

  }

  if (path.endsWith("/..")) {

    tempString=path.substring(0,path.length() - 3);

    segIndex=tempString.lastIndexOf('/');

    if (segIndex != -1) {

      path=path.substring(0,segIndex + 1);

    }

  }

  m_path=path;

}

Location: URI.java

Content: 

/** 

 * Append to the end of the path of this URI. If the current path does not end in a slash and the path to be appended does not begin with a slash, a slash will be appended to the current path before the new segment is added. Also, if the current path ends in a slash and the new segment begins with a slash, the extra slash will be removed before the new segment is appended.

 * @param p_addToPath the new segment to be added to the current path

 * @exception MalformedURIException if p_addToPath contains syntaxerrors

 */

public void appendPath(String p_addToPath) throws MalformedURIException {

  if (p_addToPath == null || p_addToPath.trim().length() == 0) {

    return;

  }

  if (!isURIString(p_addToPath)) {

    throw new MalformedURIException("Path contains invalid character!");

  }

  if (m_path == null || m_path.trim().length() == 0) {

    if (p_addToPath.startsWith("/")) {

      m_path=p_addToPath;

    }

 else {

      m_path="/" + p_addToPath;

    }

  }

 else   if (m_path.endsWith("/")) {

    if (p_addToPath.startsWith("/")) {

      m_path=m_path.concat(p_addToPath.substring(1));

    }

 else {

      m_path=m_path.concat(p_addToPath);

    }

  }

 else {

    if (p_addToPath.startsWith("/")) {

      m_path=m_path.concat(p_addToPath);

    }

 else {

      m_path=m_path.concat("/" + p_addToPath);

    }

  }

}

Location: URI.java

Content: 

/** 

 * Get the authority for this URI.

 * @return the authority

 */

public String getAuthority(){

  StringBuffer authority=new StringBuffer();

  if (m_host != null || m_regAuthority != null) {

    authority.append("//");

    if (m_host != null) {

      if (m_userinfo != null) {

        authority.append(m_userinfo);

        authority.append('@');

      }

      authority.append(m_host);

      if (m_port != -1) {

        authority.append(':');

        authority.append(m_port);

      }

    }

 else {

      authority.append(m_regAuthority);

    }

  }

  return authority.toString();

}

Location: URI.java

Content: 

/** 

 * Get the fragment for this URI.

 * @return the fragment for this URI. Null is returned if therewas no "#" in the URI spec, empty string if there was a "#" but no fragment following it.

 */

public String getFragment(){

  return m_fragment;

}

Location: URI.java

Content: 

/** 

 * Get the host for this URI.

 * @return the host for this URI (null if not specified).

 */

public String getHost(){

  return m_host;

}

Location: URI.java

Content: 

/** 

 * Get the path for this URI. Note that the value returned is the path only and does not include the query string or fragment.

 * @return the path for this URI.

 */

public String getPath(){

  return m_path;

}

Location: URI.java

Content: 

/** 

 * Get the path for this URI (optionally with the query string and fragment).

 * @param p_includeQueryString if true (and query string is not null),then a "?" followed by the query string will be appended

 * @param p_includeFragment if true (and fragment is not null),then a "#" followed by the fragment will be appended

 * @return the path for this URI possibly including the query stringand fragment

 */

public String getPath(boolean p_includeQueryString,boolean p_includeFragment){

  StringBuffer pathString=new StringBuffer(m_path);

  if (p_includeQueryString && m_queryString != null) {

    pathString.append('?');

    pathString.append(m_queryString);

  }

  if (p_includeFragment && m_fragment != null) {

    pathString.append('#');

    pathString.append(m_fragment);

  }

  return pathString.toString();

}

Location: URI.java

Content: 

/** 

 * Get the port for this URI.

 * @return the port for this URI (-1 if not specified).

 */

public int getPort(){

  return m_port;

}

Location: URI.java

Content: 

/** 

 * Get the query string for this URI.

 * @return the query string for this URI. Null is returned if therewas no "?" in the URI spec, empty string if there was a "?" but no query string following it.

 */

public String getQueryString(){

  return m_queryString;

}

Location: URI.java

Content: 

/** 

 * Get the registry based authority for this URI.

 * @return the registry based authority (null if not specified).

 */

public String getRegBasedAuthority(){

  return m_regAuthority;

}

Location: URI.java

Content: 

/** 

 * Get the scheme for this URI.

 * @return the scheme for this URI

 */

public String getScheme(){

  return m_scheme;

}

Location: URI.java

Content: 

/** 

 * Get the scheme-specific part for this URI (everything following the scheme and the first colon). See RFC 2396 Section 5.2 for spec.

 * @return the scheme-specific part for this URI

 */

public String getSchemeSpecificPart(){

  StringBuffer schemespec=new StringBuffer();

  if (m_host != null || m_regAuthority != null) {

    schemespec.append("//");

    if (m_host != null) {

      if (m_userinfo != null) {

        schemespec.append(m_userinfo);

        schemespec.append('@');

      }

      schemespec.append(m_host);

      if (m_port != -1) {

        schemespec.append(':');

        schemespec.append(m_port);

      }

    }

 else {

      schemespec.append(m_regAuthority);

    }

  }

  if (m_path != null) {

    schemespec.append((m_path));

  }

  if (m_queryString != null) {

    schemespec.append('?');

    schemespec.append(m_queryString);

  }

  if (m_fragment != null) {

    schemespec.append('#');

    schemespec.append(m_fragment);

  }

  return schemespec.toString();

}

Location: URI.java

Content: 

/** 

 * Get the userinfo for this URI.

 * @return the userinfo for this URI (null if not specified).

 */

public String getUserinfo(){

  return m_userinfo;

}

Location: URI.java

Content: 

/** 

 * Initialize the authority (either server or registry based) for this URI from a URI string spec.

 * @param p_uriSpec the URI specification (cannot be null)

 * @return true if the given string matched server or registrybased authority

 */

private boolean initializeAuthority(String p_uriSpec){

  int index=0;

  int start=0;

  int end=p_uriSpec.length();

  char testChar='\0';

  String userinfo=null;

  if (p_uriSpec.indexOf('@',start) != -1) {

    while (index < end) {

      testChar=p_uriSpec.charAt(index);

      if (testChar == '@') {

        break;

      }

      index++;

    }

    userinfo=p_uriSpec.substring(start,index);

    index++;

  }

  String host=null;

  start=index;

  boolean hasPort=false;

  if (index < end) {

    if (p_uriSpec.charAt(start) == '[') {

      int bracketIndex=p_uriSpec.indexOf(']',start);

      index=(bracketIndex != -1) ? bracketIndex : end;

      if (index + 1 < end && p_uriSpec.charAt(index + 1) == ':') {

        ++index;

        hasPort=true;

      }

 else {

        index=end;

      }

    }

 else {

      int colonIndex=p_uriSpec.lastIndexOf(':',end);

      index=(colonIndex > start) ? colonIndex : end;

      hasPort=(index != end);

    }

  }

  host=p_uriSpec.substring(start,index);

  int port=-1;

  if (host.length() > 0) {

    if (hasPort) {

      index++;

      start=index;

      while (index < end) {

        index++;

      }

      String portStr=p_uriSpec.substring(start,index);

      if (portStr.length() > 0) {

        try {

          port=Integer.parseInt(portStr);

          if (port == -1)           --port;

        }

 catch (        NumberFormatException nfe) {

          port=-2;

        }

      }

    }

  }

  if (isValidServerBasedAuthority(host,port,userinfo)) {

    m_host=host;

    m_port=port;

    m_userinfo=userinfo;

    return true;

  }

 else   if (isValidRegistryBasedAuthority(p_uriSpec)) {

    m_regAuthority=p_uriSpec;

    return true;

  }

  return false;

}

Location: URI.java

Content: 

/** 

 * Initialize the path for this URI from a URI string spec.

 * @param p_uriSpec the URI specification (cannot be null)

 * @param p_nStartIndex the index to begin scanning from

 * @exception MalformedURIException if p_uriSpec violates syntax rules

 */

private void initializePath(String p_uriSpec,int p_nStartIndex) throws MalformedURIException {

  if (p_uriSpec == null) {

    throw new MalformedURIException("Cannot initialize path from null string!");

  }

  int index=p_nStartIndex;

  int start=p_nStartIndex;

  int end=p_uriSpec.length();

  char testChar='\0';

  if (start < end) {

    if (getScheme() == null || p_uriSpec.charAt(start) == '/') {

      while (index < end) {

        testChar=p_uriSpec.charAt(index);

        if (testChar == '%') {

          if (index + 2 >= end || !isHex(p_uriSpec.charAt(index + 1)) || !isHex(p_uriSpec.charAt(index + 2))) {

            throw new MalformedURIException("Path contains invalid escape sequence!");

          }

          index+=2;

        }

 else         if (!isPathCharacter(testChar)) {

          if (testChar == '?' || testChar == '#') {

            break;

          }

          throw new MalformedURIException("Path contains invalid character: " + testChar);

        }

        ++index;

      }

    }

 else {

      while (index < end) {

        testChar=p_uriSpec.charAt(index);

        if (testChar == '?' || testChar == '#') {

          break;

        }

        if (testChar == '%') {

          if (index + 2 >= end || !isHex(p_uriSpec.charAt(index + 1)) || !isHex(p_uriSpec.charAt(index + 2))) {

            throw new MalformedURIException("Opaque part contains invalid escape sequence!");

          }

          index+=2;

        }

 else         if (!isURICharacter(testChar)) {

          throw new MalformedURIException("Opaque part contains invalid character: " + testChar);

        }

        ++index;

      }

    }

  }

  m_path=p_uriSpec.substring(start,index);

  if (testChar == '?') {

    index++;

    start=index;

    while (index < end) {

      testChar=p_uriSpec.charAt(index);

      if (testChar == '#') {

        break;

      }

      if (testChar == '%') {

        if (index + 2 >= end || !isHex(p_uriSpec.charAt(index + 1)) || !isHex(p_uriSpec.charAt(index + 2))) {

          throw new MalformedURIException("Query string contains invalid escape sequence!");

        }

        index+=2;

      }

 else       if (!isURICharacter(testChar)) {

        throw new MalformedURIException("Query string contains invalid character: " + testChar);

      }

      index++;

    }

    m_queryString=p_uriSpec.substring(start,index);

  }

  if (testChar == '#') {

    index++;

    start=index;

    while (index < end) {

      testChar=p_uriSpec.charAt(index);

      if (testChar == '%') {

        if (index + 2 >= end || !isHex(p_uriSpec.charAt(index + 1)) || !isHex(p_uriSpec.charAt(index + 2))) {

          throw new MalformedURIException("Fragment contains invalid escape sequence!");

        }

        index+=2;

      }

 else       if (!isURICharacter(testChar)) {

        throw new MalformedURIException("Fragment contains invalid character: " + testChar);

      }

      index++;

    }

    m_fragment=p_uriSpec.substring(start,index);

  }

}

Location: URI.java

Content: 

/** 

 * Initialize the scheme for this URI from a URI string spec.

 * @param p_uriSpec the URI specification (cannot be null)

 * @exception MalformedURIException if URI does not have a conformantscheme

 */

private void initializeScheme(String p_uriSpec) throws MalformedURIException {

  int uriSpecLen=p_uriSpec.length();

  int index=0;

  String scheme=null;

  char testChar='\0';

  while (index < uriSpecLen) {

    testChar=p_uriSpec.charAt(index);

    if (testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#') {

      break;

    }

    index++;

  }

  scheme=p_uriSpec.substring(0,index);

  if (scheme.length() == 0) {

    throw new MalformedURIException("No scheme found in URI.");

  }

 else {

    setScheme(scheme);

  }

}

Location: URI.java

Content: 

/** 

 * Initialize all fields of this URI from another URI.

 * @param p_other the URI to copy (cannot be null)

 */

private void initialize(URI p_other){

  m_scheme=p_other.getScheme();

  m_userinfo=p_other.getUserinfo();

  m_host=p_other.getHost();

  m_port=p_other.getPort();

  m_regAuthority=p_other.getRegBasedAuthority();

  m_path=p_other.getPath();

  m_queryString=p_other.getQueryString();

  m_fragment=p_other.getFragment();

}

Location: URI.java

Content: 

/** 

 * Initializes this URI from a base URI and a URI specification string. See RFC 2396 Section 4 and Appendix B for specifications on parsing the URI and Section 5 for specifications on resolving relative URIs and relative paths.

 * @param p_base the base URI (may be null if p_uriSpec is an absoluteURI)

 * @param p_uriSpec the URI spec string which may be an absolute orrelative URI (can only be null/empty if p_base is not null)

 * @exception MalformedURIException if p_base is null and p_uriSpecis not an absolute URI or if p_uriSpec violates syntax rules

 */

private void initialize(URI p_base,String p_uriSpec) throws MalformedURIException {

  String uriSpec=p_uriSpec;

  int uriSpecLen=(uriSpec != null) ? uriSpec.length() : 0;

  if (p_base == null && uriSpecLen == 0) {

    throw new MalformedURIException("Cannot initialize URI with empty parameters.");

  }

  if (uriSpecLen == 0) {

    initialize(p_base);

    return;

  }

  int index=0;

  int colonIdx=uriSpec.indexOf(':');

  if (colonIdx != -1) {

    final int searchFrom=colonIdx - 1;

    int slashIdx=uriSpec.lastIndexOf('/',searchFrom);

    int queryIdx=uriSpec.lastIndexOf('?',searchFrom);

    int fragmentIdx=uriSpec.lastIndexOf('#',searchFrom);

    if (colonIdx == 0 || slashIdx != -1 || queryIdx != -1 || fragmentIdx != -1) {

      if (colonIdx == 0 || (p_base == null && fragmentIdx != 0)) {

        throw new MalformedURIException("No scheme found in URI.");

      }

    }

 else {

      initializeScheme(uriSpec);

      index=m_scheme.length() + 1;

      if (colonIdx == uriSpecLen - 1 || uriSpec.charAt(colonIdx + 1) == '#') {

        throw new MalformedURIException("Scheme specific part cannot be empty.");

      }

    }

  }

 else   if (p_base == null && uriSpec.indexOf('#') != 0) {

    throw new MalformedURIException("No scheme found in URI.");

  }

  if (((index + 1) < uriSpecLen) && (uriSpec.charAt(index) == '/' && uriSpec.charAt(index + 1) == '/')) {

    index+=2;

    int startPos=index;

    char testChar='\0';

    while (index < uriSpecLen) {

      testChar=uriSpec.charAt(index);

      if (testChar == '/' || testChar == '?' || testChar == '#') {

        break;

      }

      index++;

    }

    if (index > startPos) {

      if (!initializeAuthority(uriSpec.substring(startPos,index))) {

        index=startPos - 2;

      }

    }

 else {

      m_host="";

    }

  }

  initializePath(uriSpec,index);

  if (p_base != null) {

    absolutize(p_base);

  }

}

Location: URI.java

Content: 

/** 

 * Initializes this URI from a base URI and a URI specification string. See RFC 2396 Section 4 and Appendix B for specifications on parsing the URI and Section 5 for specifications on resolving relative URIs and relative paths.

 * @param p_base the base URI (may be null if p_uriSpec is an absoluteURI)

 * @param p_uriSpec the URI spec string which may be an absolute orrelative URI (can only be null/empty if p_base is not null)

 * @param allowNonAbsoluteURI true to permit non-absolute URIs, in case of relative URI, false otherwise.

 * @exception MalformedURIException if p_base is null and p_uriSpecis not an absolute URI or if p_uriSpec violates syntax rules

 */

private void initialize(URI p_base,String p_uriSpec,boolean allowNonAbsoluteURI) throws MalformedURIException {

  String uriSpec=p_uriSpec;

  int uriSpecLen=(uriSpec != null) ? uriSpec.length() : 0;

  if (p_base == null && uriSpecLen == 0) {

    if (allowNonAbsoluteURI) {

      m_path="";

      return;

    }

    throw new MalformedURIException("Cannot initialize URI with empty parameters.");

  }

  if (uriSpecLen == 0) {

    initialize(p_base);

    return;

  }

  int index=0;

  int colonIdx=uriSpec.indexOf(':');

  if (colonIdx != -1) {

    final int searchFrom=colonIdx - 1;

    int slashIdx=uriSpec.lastIndexOf('/',searchFrom);

    int queryIdx=uriSpec.lastIndexOf('?',searchFrom);

    int fragmentIdx=uriSpec.lastIndexOf('#',searchFrom);

    if (colonIdx == 0 || slashIdx != -1 || queryIdx != -1 || fragmentIdx != -1) {

      if (colonIdx == 0 || (p_base == null && fragmentIdx != 0 && !allowNonAbsoluteURI)) {

        throw new MalformedURIException("No scheme found in URI.");

      }

    }

 else {

      initializeScheme(uriSpec);

      index=m_scheme.length() + 1;

      if (colonIdx == uriSpecLen - 1 || uriSpec.charAt(colonIdx + 1) == '#') {

        throw new MalformedURIException("Scheme specific part cannot be empty.");

      }

    }

  }

 else   if (p_base == null && uriSpec.indexOf('#') != 0 && !allowNonAbsoluteURI) {

    throw new MalformedURIException("No scheme found in URI.");

  }

  if (((index + 1) < uriSpecLen) && (uriSpec.charAt(index) == '/' && uriSpec.charAt(index + 1) == '/')) {

    index+=2;

    int startPos=index;

    char testChar='\0';

    while (index < uriSpecLen) {

      testChar=uriSpec.charAt(index);

      if (testChar == '/' || testChar == '?' || testChar == '#') {

        break;

      }

      index++;

    }

    if (index > startPos) {

      if (!initializeAuthority(uriSpec.substring(startPos,index))) {

        index=startPos - 2;

      }

    }

 else {

      m_host="";

    }

  }

  initializePath(uriSpec,index);

  if (p_base != null) {

    absolutize(p_base);

  }

}

Location: URI.java

Content: 

/** 

 * Returns whether this URI represents an absolute URI.

 * @return true if this URI represents an absolute URI, falseotherwise

 */

public boolean isAbsoluteURI(){

  return (m_scheme != null);

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is an alphanumeric: 0-9, a-z or A-Z

 * @return true if the char is alphanumeric, false otherwise

 */

private static boolean isAlphanum(char p_char){

  return (p_char <= 'z' && (fgLookupTable[p_char] & MASK_ALPHA_NUMERIC) != 0);

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is an alphabetic character: a-z or A-Z

 * @return true if the char is alphabetic, false otherwise

 */

private static boolean isAlpha(char p_char){

  return ((p_char >= 'a' && p_char <= 'z') || (p_char >= 'A' && p_char <= 'Z'));

}

Location: URI.java

Content: 

/** 

 * Determine whether a scheme conforms to the rules for a scheme name. A scheme is conformant if it starts with an alphanumeric, and contains only alphanumerics, '+','-' and '.'.

 * @return true if the scheme is conformant, false otherwise

 */

public static boolean isConformantSchemeName(String p_scheme){

  if (p_scheme == null || p_scheme.trim().length() == 0) {

    return false;

  }

  if (!isAlpha(p_scheme.charAt(0))) {

    return false;

  }

  char testChar;

  int schemeLength=p_scheme.length();

  for (int i=1; i < schemeLength; ++i) {

    testChar=p_scheme.charAt(i);

    if (!isSchemeCharacter(testChar)) {

      return false;

    }

  }

  return true;

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is a digit.

 * @return true if the char is betweeen '0' and '9', false otherwise

 */

private static boolean isDigit(char p_char){

  return p_char >= '0' && p_char <= '9';

}

Location: URI.java

Content: 

/** 

 * Get the indicator as to whether this URI uses the "generic URI" syntax.

 * @return true if this URI uses the "generic URI" syntax, falseotherwise

 */

public boolean isGenericURI(){

  return (m_host != null);

}

Location: URI.java

Content: 

/** 

 * Determine whether a character is a hexadecimal character.

 * @return true if the char is betweeen '0' and '9', 'a' and 'f'or 'A' and 'F', false otherwise

 */

private static boolean isHex(char p_char){

  return (p_char <= 'f' && (fgLookupTable[p_char] & ASCII_HEX_CHARACTERS) != 0);

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is a path character.

 * @return true if the char is a path character, false otherwise

 */

private static boolean isPathCharacter(char p_char){

  return (p_char <= '~' && (fgLookupTable[p_char] & MASK_PATH_CHARACTER) != 0);

}

Location: URI.java

Content: 

/** 

 * Determine whether a character is a reserved character: ';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '[', or ']'

 * @return true if the string contains any reserved characters

 */

private static boolean isReservedCharacter(char p_char){

  return (p_char <= ']' && (fgLookupTable[p_char] & RESERVED_CHARACTERS) != 0);

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is a scheme character.

 * @return true if the char is a scheme character, false otherwise

 */

private static boolean isSchemeCharacter(char p_char){

  return (p_char <= 'z' && (fgLookupTable[p_char] & MASK_SCHEME_CHARACTER) != 0);

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is an unreserved character.

 * @return true if the char is unreserved, false otherwise

 */

private static boolean isUnreservedCharacter(char p_char){

  return (p_char <= '~' && (fgLookupTable[p_char] & MASK_UNRESERVED_MASK) != 0);

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is a URI character (reserved or  unreserved, not including '%' for escaped octets).

 * @return true if the char is a URI character, false otherwise

 */

private static boolean isURICharacter(char p_char){

  return (p_char <= '~' && (fgLookupTable[p_char] & MASK_URI_CHARACTER) != 0);

}

Location: URI.java

Content: 

/** 

 * Determine whether a given string contains only URI characters (also called "uric" in RFC 2396). uric consist of all reserved characters, unreserved characters and escaped characters.

 * @return true if the string is comprised of uric, false otherwise

 */

private static boolean isURIString(String p_uric){

  if (p_uric == null) {

    return false;

  }

  int end=p_uric.length();

  char testChar='\0';

  for (int i=0; i < end; i++) {

    testChar=p_uric.charAt(i);

    if (testChar == '%') {

      if (i + 2 >= end || !isHex(p_uric.charAt(i + 1)) || !isHex(p_uric.charAt(i + 2))) {

        return false;

      }

 else {

        i+=2;

        continue;

      }

    }

    if (isURICharacter(testChar)) {

      continue;

    }

 else {

      return false;

    }

  }

  return true;

}

Location: URI.java

Content: 

/** 

 * Determine whether a char is a userinfo character.

 * @return true if the char is a userinfo character, false otherwise

 */

private static boolean isUserinfoCharacter(char p_char){

  return (p_char <= 'z' && (fgLookupTable[p_char] & MASK_USERINFO_CHARACTER) != 0);

}

Location: URI.java

Content: 

/** 

 * Determines whether the given string is a registry based authority.

 * @param authority the authority component of a URI

 * @return true if the given string is a registry based authority

 */

private boolean isValidRegistryBasedAuthority(String authority){

  int index=0;

  int end=authority.length();

  char testChar;

  while (index < end) {

    testChar=authority.charAt(index);

    if (testChar == '%') {

      if (index + 2 >= end || !isHex(authority.charAt(index + 1)) || !isHex(authority.charAt(index + 2))) {

        return false;

      }

      index+=2;

    }

 else     if (!isPathCharacter(testChar)) {

      return false;

    }

    ++index;

  }

  return true;

}

Location: URI.java

Content: 

/** 

 * Determines whether the components host, port, and user info are valid as a server authority.

 * @param host the host component of authority

 * @param port the port number component of authority

 * @param userinfo the user info component of authority

 * @return true if the given host, port, and userinfo composea valid server authority

 */

private boolean isValidServerBasedAuthority(String host,int port,String userinfo){

  if (!isWellFormedAddress(host)) {

    return false;

  }

  if (port < -1 || port > 65535) {

    return false;

  }

  if (userinfo != null) {

    int index=0;

    int end=userinfo.length();

    char testChar='\0';

    while (index < end) {

      testChar=userinfo.charAt(index);

      if (testChar == '%') {

        if (index + 2 >= end || !isHex(userinfo.charAt(index + 1)) || !isHex(userinfo.charAt(index + 2))) {

          return false;

        }

        index+=2;

      }

 else       if (!isUserinfoCharacter(testChar)) {

        return false;

      }

      ++index;

    }

  }

  return true;

}

Location: URI.java

Content: 

/** 

 * Determine whether a string is syntactically capable of representing a valid IPv4 address, IPv6 reference or the domain name of a network host.  A valid IPv4 address consists of four decimal digit groups separated by a '.'. Each group must consist of one to three digits. See RFC 2732 Section 3, and RFC 2373 Section 2.2, for the definition of IPv6 references. A hostname  consists of domain labels (each of which must begin and end with an alphanumeric  but may contain '-') separated & by a '.'. See RFC 2396 Section 3.2.2.

 * @return true if the string is a syntactically valid IPv4 address, IPv6 reference or hostname

 */

public static boolean isWellFormedAddress(String address){

  if (address == null) {

    return false;

  }

  int addrLength=address.length();

  if (addrLength == 0) {

    return false;

  }

  if (address.startsWith("[")) {

    return isWellFormedIPv6Reference(address);

  }

  if (address.startsWith(".") || address.startsWith("-") || address.endsWith("-")) {

    return false;

  }

  int index=address.lastIndexOf('.');

  if (address.endsWith(".")) {

    index=address.substring(0,index).lastIndexOf('.');

  }

  if (index + 1 < addrLength && isDigit(address.charAt(index + 1))) {

    return isWellFormedIPv4Address(address);

  }

 else {

    if (addrLength > 255) {

      return false;

    }

    char testChar;

    int labelCharCount=0;

    for (int i=0; i < addrLength; i++) {

      testChar=address.charAt(i);

      if (testChar == '.') {

        if (!isAlphanum(address.charAt(i - 1))) {

          return false;

        }

        if (i + 1 < addrLength && !isAlphanum(address.charAt(i + 1))) {

          return false;

        }

        labelCharCount=0;

      }

 else       if (!isAlphanum(testChar) && testChar != '-') {

        return false;

      }

 else       if (++labelCharCount > 63) {

        return false;

      }

    }

  }

  return true;

}

Location: URI.java

Content: 

/** 

 * <p>Determines whether a string is an IPv4 address as defined by  RFC 2373, and under the further constraint that it must be a 32-bit address. Though not expressed in the grammar, in order to satisfy  the 32-bit address constraint, each segment of the address cannot  be greater than 255 (8 bits of information).</p> <p><code>IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT</code></p>

 * @return true if the string is a syntactically valid IPv4 address

 */

public static boolean isWellFormedIPv4Address(String address){

  int addrLength=address.length();

  char testChar;

  int numDots=0;

  int numDigits=0;

  for (int i=0; i < addrLength; i++) {

    testChar=address.charAt(i);

    if (testChar == '.') {

      if ((i > 0 && !isDigit(address.charAt(i - 1))) || (i + 1 < addrLength && !isDigit(address.charAt(i + 1)))) {

        return false;

      }

      numDigits=0;

      if (++numDots > 3) {

        return false;

      }

    }

 else     if (!isDigit(testChar)) {

      return false;

    }

 else     if (++numDigits > 3) {

      return false;

    }

 else     if (numDigits == 3) {

      char first=address.charAt(i - 2);

      char second=address.charAt(i - 1);

      if (!(first < '2' || (first == '2' && (second < '5' || (second == '5' && testChar <= '5'))))) {

        return false;

      }

    }

  }

  return (numDots == 3);

}

Location: URI.java

Content: 

/** 

 * <p>Determines whether a string is an IPv6 reference as defined by RFC 2732, where IPv6address is defined in RFC 2373. The  IPv6 address is parsed according to Section 2.2 of RFC 2373, with the additional constraint that the address be composed of 128 bits of information.</p> <p><code>IPv6reference = "[" IPv6address "]"</code></p> <p>Note: The BNF expressed in RFC 2373 Appendix B does not  accurately describe section 2.2, and was in fact removed from RFC 3513, the successor of RFC 2373.</p>

 * @return true if the string is a syntactically valid IPv6 reference

 */

public static boolean isWellFormedIPv6Reference(String address){

  int addrLength=address.length();

  int index=1;

  int end=addrLength - 1;

  if (!(addrLength > 2 && address.charAt(0) == '[' && address.charAt(end) == ']')) {

    return false;

  }

  int[] counter=new int[1];

  index=scanHexSequence(address,index,end,counter);

  if (index == -1) {

    return false;

  }

 else   if (index == end) {

    return (counter[0] == 8);

  }

  if (index + 1 < end && address.charAt(index) == ':') {

    if (address.charAt(index + 1) == ':') {

      if (++counter[0] > 8) {

        return false;

      }

      index+=2;

      if (index == end) {

        return true;

      }

    }

 else {

      return (counter[0] == 6) && isWellFormedIPv4Address(address.substring(index + 1,end));

    }

  }

 else {

    return false;

  }

  int prevCount=counter[0];

  index=scanHexSequence(address,index,end,counter);

  return (index == end) || (index != -1 && isWellFormedIPv4Address(address.substring((counter[0] > prevCount) ? index + 1 : index,end)));

}

Location: URI.java

Content: 

/** 

 * Helper method for isWellFormedIPv6Reference which scans the  hex sequences of an IPv6 address. It returns the index of the  next character to scan in the address, or -1 if the string  cannot match a valid IPv6 address. 

 * @param address the string to be scanned

 * @param index the beginning index (inclusive)

 * @param end the ending index (exclusive)

 * @param counter a counter for the number of 16-bit sections readin the address

 * @return the index of the next character to scan, or -1 if thestring cannot match a valid IPv6 address

 */

private static int scanHexSequence(String address,int index,int end,int[] counter){

  char testChar;

  int numDigits=0;

  int start=index;

  for (; index < end; ++index) {

    testChar=address.charAt(index);

    if (testChar == ':') {

      if (numDigits > 0 && ++counter[0] > 8) {

        return -1;

      }

      if (numDigits == 0 || ((index + 1 < end) && address.charAt(index + 1) == ':')) {

        return index;

      }

      numDigits=0;

    }

 else     if (!isHex(testChar)) {

      if (testChar == '.' && numDigits < 4 && numDigits > 0 && counter[0] <= 6) {

        int back=index - numDigits - 1;

        return (back >= start) ? back : (back + 1);

      }

      return -1;

    }

 else     if (++numDigits > 4) {

      return -1;

    }

  }

  return (numDigits > 0 && ++counter[0] <= 8) ? end : -1;

}

Location: URI.java

Content: 

/** 

 * Set the fragment for this URI. A non-null value is valid only if this is a URI conforming to the generic URI syntax and the path value is not null.

 * @param p_fragment the fragment for this URI

 * @exception MalformedURIException if p_fragment is not null and thisURI does not conform to the generic URI syntax or if the path is null

 */

public void setFragment(String p_fragment) throws MalformedURIException {

  if (p_fragment == null) {

    m_fragment=null;

  }

 else   if (!isGenericURI()) {

    throw new MalformedURIException("Fragment can only be set for a generic URI!");

  }

 else   if (getPath() == null) {

    throw new MalformedURIException("Fragment cannot be set when path is null!");

  }

 else   if (!isURIString(p_fragment)) {

    throw new MalformedURIException("Fragment contains invalid character!");

  }

 else {

    m_fragment=p_fragment;

  }

}

Location: URI.java

Content: 

/** 

 * <p>Set the host for this URI. If null is passed in, the userinfo field is also set to null and the port is set to -1.</p> <p>Note: This method overwrites registry based authority if it previously existed in this URI.</p>

 * @param p_host the host for this URI

 * @exception MalformedURIException if p_host is not a valid IPaddress or DNS hostname.

 */

public void setHost(String p_host) throws MalformedURIException {

  if (p_host == null || p_host.length() == 0) {

    if (p_host != null) {

      m_regAuthority=null;

    }

    m_host=p_host;

    m_userinfo=null;

    m_port=-1;

    return;

  }

 else   if (!isWellFormedAddress(p_host)) {

    throw new MalformedURIException("Host is not a well formed address!");

  }

  m_host=p_host;

  m_regAuthority=null;

}

Location: URI.java

Content: 

/** 

 * Set the path for this URI. If the supplied path is null, then the query string and fragment are set to null as well. If the supplied path includes a query string and/or fragment, these fields will be parsed and set as well. Note that, for URIs following the "generic URI" syntax, the path specified should start with a slash. For URIs that do not follow the generic URI syntax, this method sets the scheme-specific part.

 * @param p_path the path for this URI (may be null)

 * @exception MalformedURIException if p_path contains invalidcharacters

 */

public void setPath(String p_path) throws MalformedURIException {

  if (p_path == null) {

    m_path=null;

    m_queryString=null;

    m_fragment=null;

  }

 else {

    initializePath(p_path,0);

  }

}

Location: URI.java

Content: 

/** 

 * Set the port for this URI. -1 is used to indicate that the port is not specified, otherwise valid port numbers are  between 0 and 65535. If a valid port number is passed in and the host field is null, an exception is thrown.

 * @param p_port the port number for this URI

 * @exception MalformedURIException if p_port is not -1 and not avalid port number

 */

public void setPort(int p_port) throws MalformedURIException {

  if (p_port >= 0 && p_port <= 65535) {

    if (m_host == null) {

      throw new MalformedURIException("Port cannot be set when host is null!");

    }

  }

 else   if (p_port != -1) {

    throw new MalformedURIException("Invalid port number!");

  }

  m_port=p_port;

}

Location: URI.java

Content: 

/** 

 * Set the query string for this URI. A non-null value is valid only if this is an URI conforming to the generic URI syntax and the path value is not null.

 * @param p_queryString the query string for this URI

 * @exception MalformedURIException if p_queryString is not null and thisURI does not conform to the generic URI syntax or if the path is null

 */

public void setQueryString(String p_queryString) throws MalformedURIException {

  if (p_queryString == null) {

    m_queryString=null;

  }

 else   if (!isGenericURI()) {

    throw new MalformedURIException("Query string can only be set for a generic URI!");

  }

 else   if (getPath() == null) {

    throw new MalformedURIException("Query string cannot be set when path is null!");

  }

 else   if (!isURIString(p_queryString)) {

    throw new MalformedURIException("Query string contains invalid character!");

  }

 else {

    m_queryString=p_queryString;

  }

}

Location: URI.java

Content: 

/** 

 * <p>Sets the registry based authority for this URI.</p> <p>Note: This method overwrites server based authority if it previously existed in this URI.</p>

 * @param authority the registry based authority for this URI

 * @exception MalformedURIException it authority is not awell formed registry based authority

 */

public void setRegBasedAuthority(String authority) throws MalformedURIException {

  if (authority == null) {

    m_regAuthority=null;

    return;

  }

 else   if (authority.length() < 1 || !isValidRegistryBasedAuthority(authority) || authority.indexOf('/') != -1) {

    throw new MalformedURIException("Registry based authority is not well formed.");

  }

  m_regAuthority=authority;

  m_host=null;

  m_userinfo=null;

  m_port=-1;

}

Location: URI.java

Content: 

/** 

 * Set the scheme for this URI. The scheme is converted to lowercase before it is set.

 * @param p_scheme the scheme for this URI (cannot be null)

 * @exception MalformedURIException if p_scheme is not a conformantscheme name

 */

public void setScheme(String p_scheme) throws MalformedURIException {

  if (p_scheme == null) {

    throw new MalformedURIException("Cannot set scheme from null string!");

  }

  if (!isConformantSchemeName(p_scheme)) {

    throw new MalformedURIException("The scheme is not conformant.");

  }

  m_scheme=p_scheme.toLowerCase(Locale.ENGLISH);

}

Location: URI.java

Content: 

/** 

 * Set the userinfo for this URI. If a non-null value is passed in and the host value is null, then an exception is thrown.

 * @param p_userinfo the userinfo for this URI

 * @exception MalformedURIException if p_userinfo contains invalidcharacters

 */

public void setUserinfo(String p_userinfo) throws MalformedURIException {

  if (p_userinfo == null) {

    m_userinfo=null;

    return;

  }

 else {

    if (m_host == null) {

      throw new MalformedURIException("Userinfo cannot be set when host is null!");

    }

    int index=0;

    int end=p_userinfo.length();

    char testChar='\0';

    while (index < end) {

      testChar=p_userinfo.charAt(index);

      if (testChar == '%') {

        if (index + 2 >= end || !isHex(p_userinfo.charAt(index + 1)) || !isHex(p_userinfo.charAt(index + 2))) {

          throw new MalformedURIException("Userinfo contains invalid escape sequence!");

        }

      }

 else       if (!isUserinfoCharacter(testChar)) {

        throw new MalformedURIException("Userinfo contains invalid character:" + testChar);

      }

      index++;

    }

  }

  m_userinfo=p_userinfo;

}

Location: URI.java

Content: 

/** 

 * Construct a new and uninitialized URI.

 */

public URI(){

}

Location: URI.java

Content: 

/** 

 * Construct a new URI from a URI specification string. If the specification follows the "generic URI" syntax, (two slashes following the first colon), the specification will be parsed accordingly - setting the scheme, userinfo, host,port, path, query string and fragment fields as necessary. If the specification does not follow the "generic URI" syntax, the specification is parsed into a scheme and scheme-specific part (stored as the path) only.

 * @param p_uriSpec the URI specification string (cannot be null orempty)

 * @exception MalformedURIException if p_uriSpec violates any syntaxrules

 */

public URI(String p_uriSpec) throws MalformedURIException {

  this((URI)null,p_uriSpec);

}

Location: URI.java

Content: 

/** 

 * Construct a new URI from a URI specification string. If the specification follows the "generic URI" syntax, (two slashes following the first colon), the specification will be parsed accordingly - setting the scheme, userinfo, host,port, path, query string and fragment fields as necessary. If the specification does not follow the "generic URI" syntax, the specification is parsed into a scheme and scheme-specific part (stored as the path) only. Construct a relative URI if boolean is assigned to "true" and p_uriSpec is not valid absolute URI, instead of throwing an exception. 

 * @param p_uriSpec the URI specification string (cannot be null orempty)

 * @param allowNonAbsoluteURI true to permit non-absolute URIs, false otherwise.

 * @exception MalformedURIException if p_uriSpec violates any syntaxrules

 */

public URI(String p_uriSpec,boolean allowNonAbsoluteURI) throws MalformedURIException {

  this((URI)null,p_uriSpec,allowNonAbsoluteURI);

}

Location: URI.java

Content: 

/** 

 * Construct a new URI that does not follow the generic URI syntax. Only the scheme and scheme-specific part (stored as the path) are initialized.

 * @param p_scheme the URI scheme (cannot be null or empty)

 * @param p_schemeSpecificPart the scheme-specific part (cannot benull or empty)

 * @exception MalformedURIException if p_scheme violates anysyntax rules

 */

public URI(String p_scheme,String p_schemeSpecificPart) throws MalformedURIException {

  if (p_scheme == null || p_scheme.trim().length() == 0) {

    throw new MalformedURIException("Cannot construct URI with null/empty scheme!");

  }

  if (p_schemeSpecificPart == null || p_schemeSpecificPart.trim().length() == 0) {

    throw new MalformedURIException("Cannot construct URI with null/empty scheme-specific part!");

  }

  setScheme(p_scheme);

  setPath(p_schemeSpecificPart);

}

Location: URI.java

Content: 

/** 

 * Construct a new URI that follows the generic URI syntax from its component parts. Each component is validated for syntax and some basic semantic checks are performed as well.  See the individual setter methods for specifics.

 * @param p_scheme the URI scheme (cannot be null or empty)

 * @param p_userinfo the URI userinfo (cannot be specified if hostis null)

 * @param p_host the hostname, IPv4 address or IPv6 reference for the URI

 * @param p_port the URI port (may be -1 for "unspecified"; cannotbe specified if host is null)

 * @param p_path the URI path - if the path contains '?' or '#',then the query string and/or fragment will be set from the path; however, if the query and fragment are specified both in the path and as separate parameters, an exception is thrown

 * @param p_queryString the URI query string (cannot be specifiedif path is null)

 * @param p_fragment the URI fragment (cannot be specified if pathis null)

 * @exception MalformedURIException if any of the parameters violatessyntax rules or semantic rules

 */

public URI(String p_scheme,String p_userinfo,String p_host,int p_port,String p_path,String p_queryString,String p_fragment) throws MalformedURIException {

  if (p_scheme == null || p_scheme.trim().length() == 0) {

    throw new MalformedURIException("Scheme is required!");

  }

  if (p_host == null) {

    if (p_userinfo != null) {

      throw new MalformedURIException("Userinfo may not be specified if host is not specified!");

    }

    if (p_port != -1) {

      throw new MalformedURIException("Port may not be specified if host is not specified!");

    }

  }

  if (p_path != null) {

    if (p_path.indexOf('?') != -1 && p_queryString != null) {

      throw new MalformedURIException("Query string cannot be specified in path and query string!");

    }

    if (p_path.indexOf('#') != -1 && p_fragment != null) {

      throw new MalformedURIException("Fragment cannot be specified in both the path and fragment!");

    }

  }

  setScheme(p_scheme);

  setHost(p_host);

  setPort(p_port);

  setUserinfo(p_userinfo);

  setPath(p_path);

  setQueryString(p_queryString);

  setFragment(p_fragment);

}

Location: URI.java

Content: 

/** 

 * Construct a new URI that follows the generic URI syntax from its component parts. Each component is validated for syntax and some basic semantic checks are performed as well.  See the individual setter methods for specifics.

 * @param p_scheme the URI scheme (cannot be null or empty)

 * @param p_host the hostname, IPv4 address or IPv6 reference for the URI

 * @param p_path the URI path - if the path contains '?' or '#',then the query string and/or fragment will be set from the path; however, if the query and fragment are specified both in the path and as separate parameters, an exception is thrown

 * @param p_queryString the URI query string (cannot be specifiedif path is null)

 * @param p_fragment the URI fragment (cannot be specified if pathis null)

 * @exception MalformedURIException if any of the parameters violatessyntax rules or semantic rules

 */

public URI(String p_scheme,String p_host,String p_path,String p_queryString,String p_fragment) throws MalformedURIException {

  this(p_scheme,null,p_host,-1,p_path,p_queryString,p_fragment);

}

Location: URI.java

Content: 

/** 

 * Construct a new URI from another URI. All fields for this URI are set equal to the fields of the URI passed in.

 * @param p_other the URI to copy (cannot be null)

 */

public URI(URI p_other){

  initialize(p_other);

}

Location: URI.java

Content: 

/** 

 * Construct a new URI from a base URI and a URI specification string. The URI specification string may be a relative URI.

 * @param p_base the base URI (cannot be null if p_uriSpec is null orempty)

 * @param p_uriSpec the URI specification string (cannot be null orempty if p_base is null)

 * @exception MalformedURIException if p_uriSpec violates any syntaxrules

 */

public URI(URI p_base,String p_uriSpec) throws MalformedURIException {

  initialize(p_base,p_uriSpec);

}

Location: URI.java

Content: 

/** 

 * Construct a new URI from a base URI and a URI specification string. The URI specification string may be a relative URI. Construct a relative URI if boolean is assigned to "true" and p_uriSpec is not valid absolute URI and p_base is null instead of throwing an exception. 

 * @param p_base the base URI (cannot be null if p_uriSpec is null orempty)

 * @param p_uriSpec the URI specification string (cannot be null orempty if p_base is null)

 * @param allowNonAbsoluteURI true to permit non-absolute URIs, false otherwise.

 * @exception MalformedURIException if p_uriSpec violates any syntaxrules

 */

public URI(URI p_base,String p_uriSpec,boolean allowNonAbsoluteURI) throws MalformedURIException {

  initialize(p_base,p_uriSpec,allowNonAbsoluteURI);

}

