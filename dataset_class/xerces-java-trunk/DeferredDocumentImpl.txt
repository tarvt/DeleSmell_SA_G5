Location: DeferredDocumentImpl.java

Content: 

/** 

 * Appends a child to the specified parent in the table. 

 */

public void appendChild(int parentIndex,int childIndex){

  int pchunk=parentIndex >> CHUNK_SHIFT;

  int pindex=parentIndex & CHUNK_MASK;

  int cchunk=childIndex >> CHUNK_SHIFT;

  int cindex=childIndex & CHUNK_MASK;

  setChunkIndex(fNodeParent,parentIndex,cchunk,cindex);

  int olast=getChunkIndex(fNodeLastChild,pchunk,pindex);

  setChunkIndex(fNodePrevSib,olast,cchunk,cindex);

  setChunkIndex(fNodeLastChild,childIndex,pchunk,pindex);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Performs a binary search for a target value in an array of values. The array of values must be in ascending sorted order before calling this method and all array values must be non-negative.

 * @param values  The array of values to search.

 * @param start   The starting offset of the search.

 * @param end     The ending offset of the search.

 * @param target  The target value.

 * @return This function will return the <i>first</i> occurrenceof the target value, or -1 if the target value cannot be found.

 */

protected static int binarySearch(final int values[],int start,int end,int target){

  if (DEBUG_IDS) {

    System.out.println("binarySearch(), target: " + target);

  }

  while (start <= end) {

    int middle=(start + end) >>> 1;

    int value=values[middle];

    if (DEBUG_IDS) {

      System.out.print("  value: " + value + ", target: "+ target+ " // ");

      print(values,start,end,middle,target);

    }

    if (value == target) {

      while (middle > 0 && values[middle - 1] == target) {

        middle--;

      }

      if (DEBUG_IDS) {

        System.out.println("FOUND AT " + middle);

      }

      return middle;

    }

    if (value > target) {

      end=middle - 1;

    }

 else {

      start=middle + 1;

    }

  }

  if (DEBUG_IDS) {

    System.out.println("NOT FOUND!");

  }

  return -1;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Clears the specified value in the given data at the chunk and index. Note that this method will clear the given chunk if the reference count becomes zero.

 * @return Returns the old value.

 */

private final int clearChunkIndex(int data[][],int chunk,int index){

  int value=data[chunk] != null ? data[chunk][index] : -1;

  if (value != -1) {

    data[chunk][CHUNK_SIZE]--;

    data[chunk][index]=-1;

    if (data[chunk][CHUNK_SIZE] == 0) {

      data[chunk]=null;

    }

  }

  return value;

}

Location: DeferredDocumentImpl.java

Content: 

private final String clearChunkValue(Object data[][],int chunk,int index){

  String value=data[chunk] != null ? (String)data[chunk][index] : null;

  if (value != null) {

    data[chunk][index]=null;

    RefCount c=(RefCount)data[chunk][CHUNK_SIZE];

    c.fCount--;

    if (c.fCount == 0) {

      data[chunk]=null;

    }

  }

  return value;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a clone of the specified node. 

 */

public int cloneNode(int nodeIndex,boolean deep){

  int nchunk=nodeIndex >> CHUNK_SHIFT;

  int nindex=nodeIndex & CHUNK_MASK;

  int nodeType=fNodeType[nchunk][nindex];

  int cloneIndex=createNode((short)nodeType);

  int cchunk=cloneIndex >> CHUNK_SHIFT;

  int cindex=cloneIndex & CHUNK_MASK;

  setChunkValue(fNodeName,fNodeName[nchunk][nindex],cchunk,cindex);

  setChunkValue(fNodeValue,fNodeValue[nchunk][nindex],cchunk,cindex);

  setChunkValue(fNodeURI,fNodeURI[nchunk][nindex],cchunk,cindex);

  int extraIndex=fNodeExtra[nchunk][nindex];

  if (extraIndex != -1) {

    if (nodeType != Node.ATTRIBUTE_NODE && nodeType != Node.TEXT_NODE) {

      extraIndex=cloneNode(extraIndex,false);

    }

    setChunkIndex(fNodeExtra,extraIndex,cchunk,cindex);

  }

  if (deep) {

    int prevIndex=-1;

    int childIndex=getLastChild(nodeIndex,false);

    while (childIndex != -1) {

      int clonedChildIndex=cloneNode(childIndex,deep);

      insertBefore(cloneIndex,clonedChildIndex,prevIndex);

      prevIndex=clonedChildIndex;

      childIndex=getRealPrevSibling(childIndex,false);

    }

  }

  return cloneIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates the specified chunk in the given array of chunks. 

 */

private final void createChunk(int data[][],int chunk){

  data[chunk]=new int[CHUNK_SIZE + 1];

  System.arraycopy(INIT_ARRAY,0,data[chunk],0,CHUNK_SIZE);

}

Location: DeferredDocumentImpl.java

Content: 

private final void createChunk(Object data[][],int chunk){

  data[chunk]=new Object[CHUNK_SIZE + 1];

  data[chunk][CHUNK_SIZE]=new RefCount();

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an attribute in the table. 

 */

public int createDeferredAttribute(String attrName,String attrValue,boolean specified){

  return createDeferredAttribute(attrName,null,attrValue,specified);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an attribute with a URI in the table. 

 */

public int createDeferredAttribute(String attrName,String attrURI,String attrValue,boolean specified){

  int nodeIndex=createNode(NodeImpl.ATTRIBUTE_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeName,attrName,chunk,index);

  setChunkValue(fNodeURI,attrURI,chunk,index);

  setChunkValue(fNodeValue,attrValue,chunk,index);

  int extra=specified ? SPECIFIED : 0;

  setChunkIndex(fNodeExtra,extra,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a CDATA section node in the table. 

 */

public int createDeferredCDATASection(String data){

  int nodeIndex=createNode(Node.CDATA_SECTION_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeValue,data,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a comment node in the table. 

 */

public int createDeferredComment(String data){

  int nodeIndex=createNode(Node.COMMENT_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeValue,data,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a document node in the table. 

 */

public int createDeferredDocument(){

  int nodeIndex=createNode(Node.DOCUMENT_NODE);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a doctype. 

 */

public int createDeferredDocumentType(String rootElementName,String publicId,String systemId){

  int nodeIndex=createNode(Node.DOCUMENT_TYPE_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeName,rootElementName,chunk,index);

  setChunkValue(fNodeValue,publicId,chunk,index);

  setChunkValue(fNodeURI,systemId,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an element definition in the table.

 */

public int createDeferredElementDefinition(String elementName){

  int nodeIndex=createNode(NodeImpl.ELEMENT_DEFINITION_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeName,elementName,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an element node in the table.

 * @deprecated 

 */

public int createDeferredElement(String elementName){

  return createDeferredElement(null,elementName);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an element node with a URI in the table. 

 */

public int createDeferredElement(String elementURI,String elementName){

  int elementNodeIndex=createNode(Node.ELEMENT_NODE);

  int elementChunk=elementNodeIndex >> CHUNK_SHIFT;

  int elementIndex=elementNodeIndex & CHUNK_MASK;

  setChunkValue(fNodeName,elementName,elementChunk,elementIndex);

  setChunkValue(fNodeURI,elementURI,elementChunk,elementIndex);

  return elementNodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an element node with a URI in the table and type information.

 * @deprecated

 */

public int createDeferredElement(String elementURI,String elementName,Object type){

  int elementNodeIndex=createNode(Node.ELEMENT_NODE);

  int elementChunk=elementNodeIndex >> CHUNK_SHIFT;

  int elementIndex=elementNodeIndex & CHUNK_MASK;

  setChunkValue(fNodeName,elementName,elementChunk,elementIndex);

  setChunkValue(fNodeURI,elementURI,elementChunk,elementIndex);

  setChunkValue(fNodeValue,type,elementChunk,elementIndex);

  return elementNodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an entity reference node in the table. 

 */

public int createDeferredEntityReference(String name,String baseURI){

  int nodeIndex=createNode(Node.ENTITY_REFERENCE_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeName,name,chunk,index);

  setChunkValue(fNodeValue,baseURI,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates an entity in the table. 

 */

public int createDeferredEntity(String entityName,String publicId,String systemId,String notationName,String baseURI){

  int nodeIndex=createNode(Node.ENTITY_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  int extraDataIndex=createNode(Node.ENTITY_NODE);

  int echunk=extraDataIndex >> CHUNK_SHIFT;

  int eindex=extraDataIndex & CHUNK_MASK;

  setChunkValue(fNodeName,entityName,chunk,index);

  setChunkValue(fNodeValue,publicId,chunk,index);

  setChunkValue(fNodeURI,systemId,chunk,index);

  setChunkIndex(fNodeExtra,extraDataIndex,chunk,index);

  setChunkValue(fNodeName,notationName,echunk,eindex);

  setChunkValue(fNodeValue,null,echunk,eindex);

  setChunkValue(fNodeURI,null,echunk,eindex);

  int extraDataIndex2=createNode(Node.ENTITY_NODE);

  int echunk2=extraDataIndex2 >> CHUNK_SHIFT;

  int eindex2=extraDataIndex2 & CHUNK_MASK;

  setChunkIndex(fNodeExtra,extraDataIndex2,echunk,eindex);

  setChunkValue(fNodeName,baseURI,echunk2,eindex2);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a notation in the table. 

 */

public int createDeferredNotation(String notationName,String publicId,String systemId,String baseURI){

  int nodeIndex=createNode(Node.NOTATION_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  int extraDataIndex=createNode(Node.NOTATION_NODE);

  int echunk=extraDataIndex >> CHUNK_SHIFT;

  int eindex=extraDataIndex & CHUNK_MASK;

  setChunkValue(fNodeName,notationName,chunk,index);

  setChunkValue(fNodeValue,publicId,chunk,index);

  setChunkValue(fNodeURI,systemId,chunk,index);

  setChunkIndex(fNodeExtra,extraDataIndex,chunk,index);

  setChunkValue(fNodeName,baseURI,echunk,eindex);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a processing instruction node in the table. 

 */

public int createDeferredProcessingInstruction(String target,String data){

  int nodeIndex=createNode(Node.PROCESSING_INSTRUCTION_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeName,target,chunk,index);

  setChunkValue(fNodeValue,data,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a text node in the table. 

 */

public int createDeferredTextNode(String data,boolean ignorableWhitespace){

  int nodeIndex=createNode(Node.TEXT_NODE);

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  setChunkValue(fNodeValue,data,chunk,index);

  setChunkIndex(fNodeExtra,ignorableWhitespace ? 1 : 0,chunk,index);

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Creates a node of the specified type. 

 */

protected int createNode(short nodeType){

  int chunk=fNodeCount >> CHUNK_SHIFT;

  int index=fNodeCount & CHUNK_MASK;

  ensureCapacity(chunk);

  setChunkIndex(fNodeType,nodeType,chunk,index);

  return fNodeCount++;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * NON-DOM: Actually creating a Document is outside the DOM's spec, since it has to operate in terms of a particular implementation.

 */

public DeferredDocumentImpl(){

  this(false);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * NON-DOM: Actually creating a Document is outside the DOM's spec, since it has to operate in terms of a particular implementation.

 */

public DeferredDocumentImpl(boolean namespacesEnabled){

  this(namespacesEnabled,false);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Experimental constructor. 

 */

public DeferredDocumentImpl(boolean namespaces,boolean grammarAccess){

  super(grammarAccess);

  needsSyncData(true);

  needsSyncChildren(true);

  fNamespacesEnabled=namespaces;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the attribute value of the given name. 

 */

public String getAttribute(int elemIndex,String name){

  if (elemIndex == -1 || name == null) {

    return null;

  }

  int echunk=elemIndex >> CHUNK_SHIFT;

  int eindex=elemIndex & CHUNK_MASK;

  int attrIndex=getChunkIndex(fNodeExtra,echunk,eindex);

  while (attrIndex != -1) {

    int achunk=attrIndex >> CHUNK_SHIFT;

    int aindex=attrIndex & CHUNK_MASK;

    if (getChunkValue(fNodeName,achunk,aindex) == name) {

      return getChunkValue(fNodeValue,achunk,aindex);

    }

    attrIndex=getChunkIndex(fNodePrevSib,achunk,aindex);

  }

  return null;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the specified value in the given data at the chunk and index.

 */

private final int getChunkIndex(int data[][],int chunk,int index){

  return data[chunk] != null ? data[chunk][index] : -1;

}

Location: DeferredDocumentImpl.java

Content: 

private final String getChunkValue(Object data[][],int chunk,int index){

  return data[chunk] != null ? (String)data[chunk][index] : null;

}

Location: DeferredDocumentImpl.java

Content: 

public String getDeferredEntityBaseURI(int entityIndex){

  if (entityIndex != -1) {

    int extraDataIndex=getNodeExtra(entityIndex,false);

    extraDataIndex=getNodeExtra(extraDataIndex,false);

    return getNodeName(extraDataIndex,false);

  }

  return null;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the last child of the given node. 

 */

public int getLastChild(int nodeIndex){

  return getLastChild(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the last child of the given node.

 * @param free True to free child index.

 */

public int getLastChild(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return -1;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? clearChunkIndex(fNodeLastChild,chunk,index) : getChunkIndex(fNodeLastChild,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the cached parser.getNamespaces() value.

 */

boolean getNamespacesEnabled(){

  return fNamespacesEnabled;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the extra info of the given node. Used by AttrImpl to store specified value (1 == true).

 */

public int getNodeExtra(int nodeIndex){

  return getNodeExtra(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the extra info of the given node.

 * @param free True to free the value index.

 */

public int getNodeExtra(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return -1;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? clearChunkIndex(fNodeExtra,chunk,index) : getChunkIndex(fNodeExtra,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the name of the given node. 

 */

public String getNodeName(int nodeIndex){

  return getNodeName(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the name of the given node.

 * @param free True to free the string index.

 */

public String getNodeName(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return null;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? clearChunkValue(fNodeName,chunk,index) : getChunkValue(fNodeName,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Instantiates the requested node object. 

 */

public DeferredNode getNodeObject(int nodeIndex){

  if (nodeIndex == -1) {

    return null;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  int type=getChunkIndex(fNodeType,chunk,index);

  if (type != Node.TEXT_NODE && type != Node.CDATA_SECTION_NODE) {

    clearChunkIndex(fNodeType,chunk,index);

  }

  DeferredNode node=null;

switch (type) {

case Node.ATTRIBUTE_NODE:

{

      if (fNamespacesEnabled) {

        node=new DeferredAttrNSImpl(this,nodeIndex);

      }

 else {

        node=new DeferredAttrImpl(this,nodeIndex);

      }

      break;

    }

case Node.CDATA_SECTION_NODE:

{

    node=new DeferredCDATASectionImpl(this,nodeIndex);

    break;

  }

case Node.COMMENT_NODE:

{

  node=new DeferredCommentImpl(this,nodeIndex);

  break;

}

case Node.DOCUMENT_NODE:

{

node=this;

break;

}

case Node.DOCUMENT_TYPE_NODE:

{

node=new DeferredDocumentTypeImpl(this,nodeIndex);

docType=(DocumentTypeImpl)node;

break;

}

case Node.ELEMENT_NODE:

{

if (DEBUG_IDS) {

System.out.println("getNodeObject(ELEMENT_NODE): " + nodeIndex);

}

if (fNamespacesEnabled) {

node=new DeferredElementNSImpl(this,nodeIndex);

}

 else {

node=new DeferredElementImpl(this,nodeIndex);

}

if (fIdElement != null) {

int idIndex=binarySearch(fIdElement,0,fIdCount - 1,nodeIndex);

while (idIndex != -1) {

if (DEBUG_IDS) {

  System.out.println("  id index: " + idIndex);

  System.out.println("  fIdName[" + idIndex + "]: "+ fIdName[idIndex]);

}

String name=fIdName[idIndex];

if (name != null) {

  if (DEBUG_IDS) {

    System.out.println("  name: " + name);

    System.out.print("getNodeObject()#");

  }

  putIdentifier0(name,(Element)node);

  fIdName[idIndex]=null;

}

if (idIndex + 1 < fIdCount && fIdElement[idIndex + 1] == nodeIndex) {

  idIndex++;

}

 else {

  idIndex=-1;

}

}

}

break;

}

case Node.ENTITY_NODE:

{

node=new DeferredEntityImpl(this,nodeIndex);

break;

}

case Node.ENTITY_REFERENCE_NODE:

{

node=new DeferredEntityReferenceImpl(this,nodeIndex);

break;

}

case Node.NOTATION_NODE:

{

node=new DeferredNotationImpl(this,nodeIndex);

break;

}

case Node.PROCESSING_INSTRUCTION_NODE:

{

node=new DeferredProcessingInstructionImpl(this,nodeIndex);

break;

}

case Node.TEXT_NODE:

{

node=new DeferredTextImpl(this,nodeIndex);

break;

}

case NodeImpl.ELEMENT_DEFINITION_NODE:

{

node=new DeferredElementDefinitionImpl(this,nodeIndex);

break;

}

default :

{

throw new IllegalArgumentException("type: " + type);

}

}

if (node != null) {

return node;

}

throw new IllegalArgumentException();

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the type of the given node. 

 */

public short getNodeType(int nodeIndex){

  return getNodeType(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the type of the given node.

 * @param free True to free type index.

 */

public short getNodeType(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return -1;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? (short)clearChunkIndex(fNodeType,chunk,index) : (short)getChunkIndex(fNodeType,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the URI of the given node. 

 */

public String getNodeURI(int nodeIndex){

  return getNodeURI(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the URI of the given node.

 * @param free True to free URI index.

 */

public String getNodeURI(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return null;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? clearChunkValue(fNodeURI,chunk,index) : getChunkValue(fNodeURI,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the real value of the given node. 

 */

public String getNodeValueString(int nodeIndex){

  return getNodeValueString(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the real value of the given node.

 * @param free True to free the string index.

 */

public String getNodeValueString(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return null;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  String value=free ? clearChunkValue(fNodeValue,chunk,index) : getChunkValue(fNodeValue,chunk,index);

  if (value == null) {

    return null;

  }

  int type=getChunkIndex(fNodeType,chunk,index);

  if (type == Node.TEXT_NODE) {

    int prevSib=getRealPrevSibling(nodeIndex);

    if (prevSib != -1 && getNodeType(prevSib,false) == Node.TEXT_NODE) {

      fStrChunks.add(value);

      do {

        chunk=prevSib >> CHUNK_SHIFT;

        index=prevSib & CHUNK_MASK;

        value=getChunkValue(fNodeValue,chunk,index);

        fStrChunks.add(value);

        prevSib=getChunkIndex(fNodePrevSib,chunk,index);

        if (prevSib == -1) {

          break;

        }

      }

 while (getNodeType(prevSib,false) == Node.TEXT_NODE);

      int chunkCount=fStrChunks.size();

      for (int i=chunkCount - 1; i >= 0; i--) {

        fBufferStr.append((String)fStrChunks.get(i));

      }

      value=fBufferStr.toString();

      fStrChunks.clear();

      fBufferStr.setLength(0);

      return value;

    }

  }

 else   if (type == Node.CDATA_SECTION_NODE) {

    int child=getLastChild(nodeIndex,false);

    if (child != -1) {

      fBufferStr.append(value);

      while (child != -1) {

        chunk=child >> CHUNK_SHIFT;

        index=child & CHUNK_MASK;

        value=getChunkValue(fNodeValue,chunk,index);

        fStrChunks.add(value);

        child=getChunkIndex(fNodePrevSib,chunk,index);

      }

      for (int i=fStrChunks.size() - 1; i >= 0; i--) {

        fBufferStr.append((String)fStrChunks.get(i));

      }

      value=fBufferStr.toString();

      fStrChunks.clear();

      fBufferStr.setLength(0);

      return value;

    }

  }

  return value;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the value of the given node.

 */

public String getNodeValue(int nodeIndex){

  return getNodeValue(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the value of the given node.

 * @param free True to free the value index.

 */

public String getNodeValue(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return null;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? clearChunkValue(fNodeValue,chunk,index) : getChunkValue(fNodeValue,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

private final String getNodeValue(int chunk,int index){

  Object data=fNodeValue[chunk][index];

  if (data == null) {

    return null;

  }

 else   if (data instanceof String) {

    return (String)data;

  }

 else {

    return data.toString();

  }

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the parent node of the given node. <em>Calling this method does not free the parent index.</em>

 */

public int getParentNode(int nodeIndex){

  return getParentNode(nodeIndex,false);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the parent node of the given node.

 * @param free True to free parent node.

 */

public int getParentNode(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return -1;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? clearChunkIndex(fNodeParent,chunk,index) : getChunkIndex(fNodeParent,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the prev sibling of the given node. This is post-normalization of Text Nodes.

 */

public int getPrevSibling(int nodeIndex){

  return getPrevSibling(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the prev sibling of the given node.

 * @param free True to free sibling index.

 */

public int getPrevSibling(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return -1;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  int type=getChunkIndex(fNodeType,chunk,index);

  if (type == Node.TEXT_NODE) {

    do {

      nodeIndex=getChunkIndex(fNodePrevSib,chunk,index);

      if (nodeIndex == -1) {

        break;

      }

      chunk=nodeIndex >> CHUNK_SHIFT;

      index=nodeIndex & CHUNK_MASK;

      type=getChunkIndex(fNodeType,chunk,index);

    }

 while (type == Node.TEXT_NODE);

  }

 else {

    nodeIndex=getChunkIndex(fNodePrevSib,chunk,index);

  }

  return nodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the <i>real</i> prev sibling of the given node, directly from the data structures. Used by TextImpl#getNodeValue() to normalize values.

 */

public int getRealPrevSibling(int nodeIndex){

  return getRealPrevSibling(nodeIndex,true);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the <i>real</i> prev sibling of the given node.

 * @param free True to free sibling index.

 */

public int getRealPrevSibling(int nodeIndex,boolean free){

  if (nodeIndex == -1) {

    return -1;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  return free ? clearChunkIndex(fNodePrevSib,chunk,index) : getChunkIndex(fNodePrevSib,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Clears the type info that is stored in the fNodeValue array

 * @param nodeIndex

 * @return Object - type information for the attribute/element node

 */

public Object getTypeInfo(int nodeIndex){

  if (nodeIndex == -1) {

    return null;

  }

  int chunk=nodeIndex >> CHUNK_SHIFT;

  int index=nodeIndex & CHUNK_MASK;

  Object value=fNodeValue[chunk] != null ? fNodeValue[chunk][index] : null;

  if (value != null) {

    fNodeValue[chunk][index]=null;

    RefCount c=(RefCount)fNodeValue[chunk][CHUNK_SIZE];

    c.fCount--;

    if (c.fCount == 0) {

      fNodeValue[chunk]=null;

    }

  }

  return value;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Inserts a child before the specified node in the table. 

 */

public int insertBefore(int parentIndex,int newChildIndex,int refChildIndex){

  if (refChildIndex == -1) {

    appendChild(parentIndex,newChildIndex);

    return newChildIndex;

  }

  int nchunk=newChildIndex >> CHUNK_SHIFT;

  int nindex=newChildIndex & CHUNK_MASK;

  int rchunk=refChildIndex >> CHUNK_SHIFT;

  int rindex=refChildIndex & CHUNK_MASK;

  int previousIndex=getChunkIndex(fNodePrevSib,rchunk,rindex);

  setChunkIndex(fNodePrevSib,newChildIndex,rchunk,rindex);

  setChunkIndex(fNodePrevSib,previousIndex,nchunk,nindex);

  return newChildIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Returns the index of the element definition in the table with the specified name index, or -1 if no such definition exists.

 */

public int lookupElementDefinition(String elementName){

  if (fNodeCount > 1) {

    int docTypeIndex=-1;

    int nchunk=0;

    int nindex=0;

    for (int index=getChunkIndex(fNodeLastChild,nchunk,nindex); index != -1; index=getChunkIndex(fNodePrevSib,nchunk,nindex)) {

      nchunk=index >> CHUNK_SHIFT;

      nindex=index & CHUNK_MASK;

      if (getChunkIndex(fNodeType,nchunk,nindex) == Node.DOCUMENT_TYPE_NODE) {

        docTypeIndex=index;

        break;

      }

    }

    if (docTypeIndex == -1) {

      return -1;

    }

    nchunk=docTypeIndex >> CHUNK_SHIFT;

    nindex=docTypeIndex & CHUNK_MASK;

    for (int index=getChunkIndex(fNodeLastChild,nchunk,nindex); index != -1; index=getChunkIndex(fNodePrevSib,nchunk,nindex)) {

      nchunk=index >> CHUNK_SHIFT;

      nindex=index & CHUNK_MASK;

      if (getChunkIndex(fNodeType,nchunk,nindex) == NodeImpl.ELEMENT_DEFINITION_NODE && getChunkValue(fNodeName,nchunk,nindex) == elementName) {

        return index;

      }

    }

  }

  return -1;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Prints the ID array. 

 */

private static void print(int values[],int start,int end,int middle,int target){

  if (DEBUG_IDS) {

    System.out.print(start);

    System.out.print(" [");

    for (int i=start; i < end; i++) {

      if (middle == i) {

        System.out.print("!");

      }

      System.out.print(values[i]);

      if (values[i] == target) {

        System.out.print("*");

      }

      if (i < end - 1) {

        System.out.print(" ");

      }

    }

    System.out.println("] " + end);

  }

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * This version of putIdentifier is needed to avoid fluffing all of the paths to ID attributes when a node object is created that contains an ID attribute.

 */

private final void putIdentifier0(String idName,Element element){

  if (DEBUG_IDS) {

    System.out.println("putIdentifier0(" + idName + ", "+ element+ ')');

  }

  if (identifiers == null) {

    identifiers=new java.util.Hashtable();

  }

  identifiers.put(idName,element);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Registers an identifier name with a specified element node. 

 */

public void putIdentifier(String name,int elementNodeIndex){

  if (DEBUG_IDS) {

    System.out.println("putIdentifier(" + name + ", "+ elementNodeIndex+ ')'+ " // "+ getChunkValue(fNodeName,elementNodeIndex >> CHUNK_SHIFT,elementNodeIndex & CHUNK_MASK));

  }

  if (fIdName == null) {

    fIdName=new String[64];

    fIdElement=new int[64];

  }

  if (fIdCount == fIdName.length) {

    String idName[]=new String[fIdCount * 2];

    System.arraycopy(fIdName,0,idName,0,fIdCount);

    fIdName=idName;

    int idElement[]=new int[idName.length];

    System.arraycopy(fIdElement,0,idElement,0,fIdCount);

    fIdElement=idElement;

  }

  fIdName[fIdCount]=name;

  fIdElement[fIdCount]=elementNodeIndex;

  fIdCount++;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Sets the last child of the parentIndex to childIndex. 

 */

public void setAsLastChild(int parentIndex,int childIndex){

  int pchunk=parentIndex >> CHUNK_SHIFT;

  int pindex=parentIndex & CHUNK_MASK;

  setChunkIndex(fNodeLastChild,childIndex,pchunk,pindex);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Adds an attribute node to the specified element. 

 */

public int setAttributeNode(int elemIndex,int attrIndex){

  int echunk=elemIndex >> CHUNK_SHIFT;

  int eindex=elemIndex & CHUNK_MASK;

  int achunk=attrIndex >> CHUNK_SHIFT;

  int aindex=attrIndex & CHUNK_MASK;

  String attrName=getChunkValue(fNodeName,achunk,aindex);

  int oldAttrIndex=getChunkIndex(fNodeExtra,echunk,eindex);

  int nextIndex=-1;

  int oachunk=-1;

  int oaindex=-1;

  while (oldAttrIndex != -1) {

    oachunk=oldAttrIndex >> CHUNK_SHIFT;

    oaindex=oldAttrIndex & CHUNK_MASK;

    String oldAttrName=getChunkValue(fNodeName,oachunk,oaindex);

    if (oldAttrName.equals(attrName)) {

      break;

    }

    nextIndex=oldAttrIndex;

    oldAttrIndex=getChunkIndex(fNodePrevSib,oachunk,oaindex);

  }

  if (oldAttrIndex != -1) {

    int prevIndex=getChunkIndex(fNodePrevSib,oachunk,oaindex);

    if (nextIndex == -1) {

      setChunkIndex(fNodeExtra,prevIndex,echunk,eindex);

    }

 else {

      int pchunk=nextIndex >> CHUNK_SHIFT;

      int pindex=nextIndex & CHUNK_MASK;

      setChunkIndex(fNodePrevSib,prevIndex,pchunk,pindex);

    }

    clearChunkIndex(fNodeType,oachunk,oaindex);

    clearChunkValue(fNodeName,oachunk,oaindex);

    clearChunkValue(fNodeValue,oachunk,oaindex);

    clearChunkIndex(fNodeParent,oachunk,oaindex);

    clearChunkIndex(fNodePrevSib,oachunk,oaindex);

    int attrTextIndex=clearChunkIndex(fNodeLastChild,oachunk,oaindex);

    int atchunk=attrTextIndex >> CHUNK_SHIFT;

    int atindex=attrTextIndex & CHUNK_MASK;

    clearChunkIndex(fNodeType,atchunk,atindex);

    clearChunkValue(fNodeValue,atchunk,atindex);

    clearChunkIndex(fNodeParent,atchunk,atindex);

    clearChunkIndex(fNodeLastChild,atchunk,atindex);

  }

  int prevIndex=getChunkIndex(fNodeExtra,echunk,eindex);

  setChunkIndex(fNodeExtra,attrIndex,echunk,eindex);

  setChunkIndex(fNodePrevSib,prevIndex,achunk,aindex);

  return oldAttrIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Sets the specified value in the given of data at the chunk and index.

 * @return Returns the old value.

 */

private final int setChunkIndex(int data[][],int value,int chunk,int index){

  if (value == -1) {

    return clearChunkIndex(data,chunk,index);

  }

  int[] dataChunk=data[chunk];

  if (dataChunk == null) {

    createChunk(data,chunk);

    dataChunk=data[chunk];

  }

  int ovalue=dataChunk[index];

  if (ovalue == -1) {

    dataChunk[CHUNK_SIZE]++;

  }

  dataChunk[index]=value;

  return ovalue;

}

Location: DeferredDocumentImpl.java

Content: 

private final String setChunkValue(Object data[][],Object value,int chunk,int index){

  if (value == null) {

    return clearChunkValue(data,chunk,index);

  }

  Object[] dataChunk=data[chunk];

  if (dataChunk == null) {

    createChunk(data,chunk);

    dataChunk=data[chunk];

  }

  String ovalue=(String)dataChunk[index];

  if (ovalue == null) {

    RefCount c=(RefCount)dataChunk[CHUNK_SIZE];

    c.fCount++;

  }

  dataChunk[index]=value;

  return ovalue;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Sets an attribute on an element node.

 * @deprecated

 */

public int setDeferredAttribute(int elementNodeIndex,String attrName,String attrURI,String attrValue,boolean specified){

  int attrNodeIndex=createDeferredAttribute(attrName,attrURI,attrValue,specified);

  int attrChunk=attrNodeIndex >> CHUNK_SHIFT;

  int attrIndex=attrNodeIndex & CHUNK_MASK;

  setChunkIndex(fNodeParent,elementNodeIndex,attrChunk,attrIndex);

  int elementChunk=elementNodeIndex >> CHUNK_SHIFT;

  int elementIndex=elementNodeIndex & CHUNK_MASK;

  int lastAttrNodeIndex=getChunkIndex(fNodeExtra,elementChunk,elementIndex);

  if (lastAttrNodeIndex != 0) {

    setChunkIndex(fNodePrevSib,lastAttrNodeIndex,attrChunk,attrIndex);

  }

  setChunkIndex(fNodeExtra,attrNodeIndex,elementChunk,elementIndex);

  return attrNodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * This method is used by the DOMParser to create attributes.

 * @param elementNodeIndex

 * @param attrName

 * @param attrURI

 * @param attrValue

 * @param specified

 * @param id

 * @param type

 * @return int

 */

public int setDeferredAttribute(int elementNodeIndex,String attrName,String attrURI,String attrValue,boolean specified,boolean id,Object type){

  int attrNodeIndex=createDeferredAttribute(attrName,attrURI,attrValue,specified);

  int attrChunk=attrNodeIndex >> CHUNK_SHIFT;

  int attrIndex=attrNodeIndex & CHUNK_MASK;

  setChunkIndex(fNodeParent,elementNodeIndex,attrChunk,attrIndex);

  int elementChunk=elementNodeIndex >> CHUNK_SHIFT;

  int elementIndex=elementNodeIndex & CHUNK_MASK;

  int lastAttrNodeIndex=getChunkIndex(fNodeExtra,elementChunk,elementIndex);

  if (lastAttrNodeIndex != 0) {

    setChunkIndex(fNodePrevSib,lastAttrNodeIndex,attrChunk,attrIndex);

  }

  setChunkIndex(fNodeExtra,attrNodeIndex,elementChunk,elementIndex);

  int extra=getChunkIndex(fNodeExtra,attrChunk,attrIndex);

  if (id) {

    extra=extra | ID;

    setChunkIndex(fNodeExtra,extra,attrChunk,attrIndex);

    String value=getChunkValue(fNodeValue,attrChunk,attrIndex);

    putIdentifier(value,elementNodeIndex);

  }

  if (type != null) {

    int extraDataIndex=createNode(DeferredNode.TYPE_NODE);

    int echunk=extraDataIndex >> CHUNK_SHIFT;

    int eindex=extraDataIndex & CHUNK_MASK;

    setChunkIndex(fNodeLastChild,extraDataIndex,attrChunk,attrIndex);

    setChunkValue(fNodeValue,type,echunk,eindex);

  }

  return attrNodeIndex;

}

Location: DeferredDocumentImpl.java

Content: 

public void setEntityInfo(int currentEntityDecl,String version,String encoding){

  int eNodeIndex=getNodeExtra(currentEntityDecl,false);

  if (eNodeIndex != -1) {

    int echunk=eNodeIndex >> CHUNK_SHIFT;

    int eindex=eNodeIndex & CHUNK_MASK;

    setChunkValue(fNodeValue,version,echunk,eindex);

    setChunkValue(fNodeURI,encoding,echunk,eindex);

  }

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Adds an attribute node to the specified element. 

 */

public void setIdAttributeNode(int elemIndex,int attrIndex){

  int chunk=attrIndex >> CHUNK_SHIFT;

  int index=attrIndex & CHUNK_MASK;

  int extra=getChunkIndex(fNodeExtra,chunk,index);

  extra=extra | ID;

  setChunkIndex(fNodeExtra,extra,chunk,index);

  String value=getChunkValue(fNodeValue,chunk,index);

  putIdentifier(value,elemIndex);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Sets type of attribute 

 */

public void setIdAttribute(int attrIndex){

  int chunk=attrIndex >> CHUNK_SHIFT;

  int index=attrIndex & CHUNK_MASK;

  int extra=getChunkIndex(fNodeExtra,chunk,index);

  extra=extra | ID;

  setChunkIndex(fNodeExtra,extra,chunk,index);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * DOM Internal  An attribute specifying the actual encoding of this document. This is <code>null</code> otherwise. <br> This attribute represents the property [character encoding scheme] defined in .

 */

public void setInputEncoding(int currentEntityDecl,String value){

  int nodeIndex=getNodeExtra(currentEntityDecl,false);

  int extraDataIndex=getNodeExtra(nodeIndex,false);

  int echunk=extraDataIndex >> CHUNK_SHIFT;

  int eindex=extraDataIndex & CHUNK_MASK;

  setChunkValue(fNodeValue,value,echunk,eindex);

}

Location: DeferredDocumentImpl.java

Content: 

public void setInternalSubset(int doctypeIndex,String subset){

  int chunk=doctypeIndex >> CHUNK_SHIFT;

  int index=doctypeIndex & CHUNK_MASK;

  int extraDataIndex=createNode(Node.DOCUMENT_TYPE_NODE);

  int echunk=extraDataIndex >> CHUNK_SHIFT;

  int eindex=extraDataIndex & CHUNK_MASK;

  setChunkIndex(fNodeExtra,extraDataIndex,chunk,index);

  setChunkValue(fNodeValue,subset,echunk,eindex);

}

Location: DeferredDocumentImpl.java

Content: 

void setNamespacesEnabled(boolean enable){

  fNamespacesEnabled=enable;

}

Location: DeferredDocumentImpl.java

Content: 

public void setTypeInfo(int elementNodeIndex,Object type){

  int elementChunk=elementNodeIndex >> CHUNK_SHIFT;

  int elementIndex=elementNodeIndex & CHUNK_MASK;

  setChunkValue(fNodeValue,type,elementChunk,elementIndex);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Synchronizes the node's children with the internal structure. Fluffing the children at once solves a lot of work to keep the two structures in sync. The problem gets worse when editing the tree -- this makes it a lot easier. This is not directly used in this class but this method is here so that it can be shared by all deferred subclasses of AttrImpl.

 */

protected final void synchronizeChildren(AttrImpl a,int nodeIndex){

  boolean orig=getMutationEvents();

  setMutationEvents(false);

  a.needsSyncChildren(false);

  int last=getLastChild(nodeIndex);

  int prev=getPrevSibling(last);

  if (prev == -1) {

    a.value=getNodeValueString(nodeIndex);

    a.hasStringValue(true);

  }

 else {

    ChildNode firstNode=null;

    ChildNode lastNode=null;

    for (int index=last; index != -1; index=getPrevSibling(index)) {

      ChildNode node=(ChildNode)getNodeObject(index);

      if (lastNode == null) {

        lastNode=node;

      }

 else {

        firstNode.previousSibling=node;

      }

      node.ownerNode=a;

      node.isOwned(true);

      node.nextSibling=firstNode;

      firstNode=node;

    }

    if (lastNode != null) {

      a.value=firstNode;

      firstNode.isFirstChild(true);

      a.lastChild(lastNode);

    }

    a.hasStringValue(false);

  }

  setMutationEvents(orig);

}

Location: DeferredDocumentImpl.java

Content: 

/** 

 * Synchronizes the node's children with the internal structure. Fluffing the children at once solves a lot of work to keep the two structures in sync. The problem gets worse when editing the tree -- this makes it a lot easier. This is not directly used in this class but this method is here so that it can be shared by all deferred subclasses of ParentNode.

 */

protected final void synchronizeChildren(ParentNode p,int nodeIndex){

  boolean orig=getMutationEvents();

  setMutationEvents(false);

  p.needsSyncChildren(false);

  ChildNode firstNode=null;

  ChildNode lastNode=null;

  for (int index=getLastChild(nodeIndex); index != -1; index=getPrevSibling(index)) {

    ChildNode node=(ChildNode)getNodeObject(index);

    if (lastNode == null) {

      lastNode=node;

    }

 else {

      firstNode.previousSibling=node;

    }

    node.ownerNode=p;

    node.isOwned(true);

    node.nextSibling=firstNode;

    firstNode=node;

  }

  if (lastNode != null) {

    p.firstChild=firstNode;

    firstNode.isFirstChild(true);

    p.lastChild(lastNode);

  }

  setMutationEvents(orig);

}

