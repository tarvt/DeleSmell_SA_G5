Location: DTDGrammar.java

Content: 

/** 

 * Create an XMLContentSpec for a two child leaf

 * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_

 * @param leftNodeIndex handle to an XMLContentSpec

 * @param rightNodeIndex handle to an XMLContentSpec

 * @return handle to the newly create XMLContentSpec

 */

protected int addContentSpecNode(short nodeType,int leftNodeIndex,int rightNodeIndex){

  int contentSpecIndex=createContentSpec();

  int[] leftIntArray=new int[1];

  int[] rightIntArray=new int[1];

  leftIntArray[0]=leftNodeIndex;

  rightIntArray[0]=rightNodeIndex;

  fContentSpec.setValues(nodeType,leftIntArray,rightIntArray);

  setContentSpec(contentSpecIndex,fContentSpec);

  return contentSpecIndex;

}

Location: DTDGrammar.java

Content: 

/** 

 * Create an XMLContentSpec for a single non-leaf

 * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_

 * @param nodeValue handle to an XMLContentSpec

 * @return handle to the newly create XMLContentSpec

 */

protected int addContentSpecNode(short nodeType,String nodeValue){

  int contentSpecIndex=createContentSpec();

  fContentSpec.setValues(nodeType,nodeValue,null);

  setContentSpec(contentSpecIndex,fContentSpec);

  return contentSpecIndex;

}

Location: DTDGrammar.java

Content: 

/** 

 * create an XMLContentSpec for a leaf

 * @param elementName  the name (Element) for the node

 * @return handle to the newly create XMLContentSpec

 */

protected int addUniqueLeafNode(String elementName){

  int contentSpecIndex=createContentSpec();

  fContentSpec.setValues(XMLContentSpec.CONTENTSPECNODE_LEAF,elementName,null);

  setContentSpec(contentSpecIndex,fContentSpec);

  return contentSpecIndex;

}

Location: DTDGrammar.java

Content: 

private void appendContentSpec(XMLContentSpec contentSpec,StringBuffer str,boolean parens,int parentContentSpecType){

  int thisContentSpec=contentSpec.type & 0x0f;

switch (thisContentSpec) {

case XMLContentSpec.CONTENTSPECNODE_LEAF:

{

      if (contentSpec.value == null && contentSpec.otherValue == null) {

        str.append("#PCDATA");

      }

 else       if (contentSpec.value == null && contentSpec.otherValue != null) {

        str.append("##any:uri=").append(contentSpec.otherValue);

      }

 else       if (contentSpec.value == null) {

        str.append("##any");

      }

 else {

        str.append(contentSpec.value);

      }

      break;

    }

case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE:

{

    if (parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE || parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) {

      getContentSpec(((int[])contentSpec.value)[0],contentSpec);

      str.append('(');

      appendContentSpec(contentSpec,str,true,thisContentSpec);

      str.append(')');

    }

 else {

      getContentSpec(((int[])contentSpec.value)[0],contentSpec);

      appendContentSpec(contentSpec,str,true,thisContentSpec);

    }

    str.append('?');

    break;

  }

case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE:

{

  if (parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE || parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) {

    getContentSpec(((int[])contentSpec.value)[0],contentSpec);

    str.append('(');

    appendContentSpec(contentSpec,str,true,thisContentSpec);

    str.append(')');

  }

 else {

    getContentSpec(((int[])contentSpec.value)[0],contentSpec);

    appendContentSpec(contentSpec,str,true,thisContentSpec);

  }

  str.append('*');

  break;

}

case XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE:

{

if (parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE || parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || parentContentSpecType == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) {

  str.append('(');

  getContentSpec(((int[])contentSpec.value)[0],contentSpec);

  appendContentSpec(contentSpec,str,true,thisContentSpec);

  str.append(')');

}

 else {

  getContentSpec(((int[])contentSpec.value)[0],contentSpec);

  appendContentSpec(contentSpec,str,true,thisContentSpec);

}

str.append('+');

break;

}

case XMLContentSpec.CONTENTSPECNODE_CHOICE:

case XMLContentSpec.CONTENTSPECNODE_SEQ:

{

if (parens) {

str.append('(');

}

int type=contentSpec.type;

int otherValue=((int[])contentSpec.otherValue)[0];

getContentSpec(((int[])contentSpec.value)[0],contentSpec);

appendContentSpec(contentSpec,str,contentSpec.type != type,thisContentSpec);

if (type == XMLContentSpec.CONTENTSPECNODE_CHOICE) {

str.append('|');

}

 else {

str.append(',');

}

getContentSpec(otherValue,contentSpec);

appendContentSpec(contentSpec,str,true,thisContentSpec);

if (parens) {

str.append(')');

}

break;

}

case XMLContentSpec.CONTENTSPECNODE_ANY:

{

str.append("##any");

if (contentSpec.otherValue != null) {

str.append(":uri=");

str.append(contentSpec.otherValue);

}

break;

}

case XMLContentSpec.CONTENTSPECNODE_ANY_OTHER:

{

str.append("##other:uri=");

str.append(contentSpec.otherValue);

break;

}

case XMLContentSpec.CONTENTSPECNODE_ANY_LOCAL:

{

str.append("##local");

break;

}

default :

{

str.append("???");

break;

}

}

}

Location: DTDGrammar.java

Content: 

private final CMNode buildSyntaxTree(int startNode,XMLContentSpec contentSpec){

  CMNode nodeRet=null;

  getContentSpec(startNode,contentSpec);

  if ((contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY) {

    nodeRet=new CMAny(contentSpec.type,(String)contentSpec.otherValue,fLeafCount++);

  }

 else   if ((contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_OTHER) {

    nodeRet=new CMAny(contentSpec.type,(String)contentSpec.otherValue,fLeafCount++);

  }

 else   if ((contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_LOCAL) {

    nodeRet=new CMAny(contentSpec.type,null,fLeafCount++);

  }

 else   if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_LEAF) {

    fQName.setValues(null,(String)contentSpec.value,(String)contentSpec.value,(String)contentSpec.otherValue);

    nodeRet=new CMLeaf(fQName,fLeafCount++);

  }

 else {

    final int leftNode=((int[])contentSpec.value)[0];

    final int rightNode=((int[])contentSpec.otherValue)[0];

    if ((contentSpec.type == XMLContentSpec.CONTENTSPECNODE_CHOICE) || (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_SEQ)) {

      nodeRet=new CMBinOp(contentSpec.type,buildSyntaxTree(leftNode,contentSpec),buildSyntaxTree(rightNode,contentSpec));

    }

 else     if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE) {

      nodeRet=new CMUniOp(contentSpec.type,buildSyntaxTree(leftNode,contentSpec));

    }

 else     if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE || contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE) {

      nodeRet=new CMUniOp(contentSpec.type,buildSyntaxTree(leftNode,contentSpec));

    }

 else {

      throw new RuntimeException("ImplementationMessages.VAL_CST");

    }

  }

  return nodeRet;

}

Location: DTDGrammar.java

Content: 

/** 

 * Build a vector of valid QNames from Content Spec table.

 * @param contentSpecIndex Content Spec index

 * @param vectorQName Array of QName

 * @exception RuntimeException

 */

private void contentSpecTree(int contentSpecIndex,XMLContentSpec contentSpec,ChildrenList children){

  getContentSpec(contentSpecIndex,contentSpec);

  if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_LEAF || (contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY || (contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_LOCAL || (contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_OTHER) {

    if (children.length == children.qname.length) {

      QName[] newQName=new QName[children.length * 2];

      System.arraycopy(children.qname,0,newQName,0,children.length);

      children.qname=newQName;

      int[] newType=new int[children.length * 2];

      System.arraycopy(children.type,0,newType,0,children.length);

      children.type=newType;

    }

    children.qname[children.length]=new QName(null,(String)contentSpec.value,(String)contentSpec.value,(String)contentSpec.otherValue);

    children.type[children.length]=contentSpec.type;

    children.length++;

    return;

  }

  final int leftNode=contentSpec.value != null ? ((int[])(contentSpec.value))[0] : -1;

  int rightNode=-1;

  if (contentSpec.otherValue != null)   rightNode=((int[])(contentSpec.otherValue))[0];

 else   return;

  if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_CHOICE || contentSpec.type == XMLContentSpec.CONTENTSPECNODE_SEQ) {

    contentSpecTree(leftNode,contentSpec,children);

    contentSpecTree(rightNode,contentSpec,children);

    return;

  }

  if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE || contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE) {

    contentSpecTree(leftNode,contentSpec,children);

    return;

  }

  throw new RuntimeException("Invalid content spec type seen in contentSpecTree() method of AbstractDTDGrammar class : " + contentSpec.type);

}

Location: DTDGrammar.java

Content: 

protected int createAttributeDecl(){

  int chunk=fAttributeDeclCount >> CHUNK_SHIFT;

  int index=fAttributeDeclCount & CHUNK_MASK;

  ensureAttributeDeclCapacity(chunk);

  fAttributeDeclName[chunk][index]=new QName();

  fAttributeDeclType[chunk][index]=-1;

  fAttributeDeclDatatypeValidator[chunk][index]=null;

  fAttributeDeclEnumeration[chunk][index]=null;

  fAttributeDeclDefaultType[chunk][index]=XMLSimpleType.DEFAULT_TYPE_IMPLIED;

  fAttributeDeclDefaultValue[chunk][index]=null;

  fAttributeDeclNonNormalizedDefaultValue[chunk][index]=null;

  fAttributeDeclNextAttributeDeclIndex[chunk][index]=-1;

  return fAttributeDeclCount++;

}

Location: DTDGrammar.java

Content: 

/** 

 * When the element has a 'CHILDREN' model, this method is called to create the content model object. It looks for some special case simple models and creates SimpleContentModel objects for those. For the rest it creates the standard DFA style model.

 */

private synchronized ContentModelValidator createChildModel(int contentSpecIndex){

  XMLContentSpec contentSpec=new XMLContentSpec();

  getContentSpec(contentSpecIndex,contentSpec);

  if ((contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY || (contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_OTHER || (contentSpec.type & 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_LOCAL) {

  }

 else   if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_LEAF) {

    if (contentSpec.value == null && contentSpec.otherValue == null)     throw new RuntimeException("ImplementationMessages.VAL_NPCD");

    fQName.setValues(null,(String)contentSpec.value,(String)contentSpec.value,(String)contentSpec.otherValue);

    return new SimpleContentModel(contentSpec.type,fQName,null);

  }

 else   if ((contentSpec.type == XMLContentSpec.CONTENTSPECNODE_CHOICE) || (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_SEQ)) {

    XMLContentSpec contentSpecLeft=new XMLContentSpec();

    XMLContentSpec contentSpecRight=new XMLContentSpec();

    getContentSpec(((int[])contentSpec.value)[0],contentSpecLeft);

    getContentSpec(((int[])contentSpec.otherValue)[0],contentSpecRight);

    if ((contentSpecLeft.type == XMLContentSpec.CONTENTSPECNODE_LEAF) && (contentSpecRight.type == XMLContentSpec.CONTENTSPECNODE_LEAF)) {

      fQName.setValues(null,(String)contentSpecLeft.value,(String)contentSpecLeft.value,(String)contentSpecLeft.otherValue);

      fQName2.setValues(null,(String)contentSpecRight.value,(String)contentSpecRight.value,(String)contentSpecRight.otherValue);

      return new SimpleContentModel(contentSpec.type,fQName,fQName2);

    }

  }

 else   if ((contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) || (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE) || (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE)) {

    XMLContentSpec contentSpecLeft=new XMLContentSpec();

    getContentSpec(((int[])contentSpec.value)[0],contentSpecLeft);

    if (contentSpecLeft.type == XMLContentSpec.CONTENTSPECNODE_LEAF) {

      fQName.setValues(null,(String)contentSpecLeft.value,(String)contentSpecLeft.value,(String)contentSpecLeft.otherValue);

      return new SimpleContentModel(contentSpec.type,fQName,null);

    }

  }

 else {

    throw new RuntimeException("ImplementationMessages.VAL_CST");

  }

  fLeafCount=0;

  fLeafCount=0;

  CMNode cmn=buildSyntaxTree(contentSpecIndex,contentSpec);

  return new DFAContentModel(cmn,fLeafCount,false);

}

Location: DTDGrammar.java

Content: 

protected int createContentSpec(){

  int chunk=fContentSpecCount >> CHUNK_SHIFT;

  int index=fContentSpecCount & CHUNK_MASK;

  ensureContentSpecCapacity(chunk);

  fContentSpecType[chunk][index]=-1;

  fContentSpecValue[chunk][index]=null;

  fContentSpecOtherValue[chunk][index]=null;

  return fContentSpecCount++;

}

Location: DTDGrammar.java

Content: 

protected int createElementDecl(){

  int chunk=fElementDeclCount >> CHUNK_SHIFT;

  int index=fElementDeclCount & CHUNK_MASK;

  ensureElementDeclCapacity(chunk);

  fElementDeclName[chunk][index]=new QName();

  fElementDeclType[chunk][index]=-1;

  fElementDeclContentModelValidator[chunk][index]=null;

  fElementDeclFirstAttributeDeclIndex[chunk][index]=-1;

  fElementDeclLastAttributeDeclIndex[chunk][index]=-1;

  return fElementDeclCount++;

}

Location: DTDGrammar.java

Content: 

protected int createEntityDecl(){

  int chunk=fEntityCount >> CHUNK_SHIFT;

  int index=fEntityCount & CHUNK_MASK;

  ensureEntityDeclCapacity(chunk);

  fEntityIsPE[chunk][index]=0;

  fEntityInExternal[chunk][index]=0;

  return fEntityCount++;

}

Location: DTDGrammar.java

Content: 

protected int createNotationDecl(){

  int chunk=fNotationCount >> CHUNK_SHIFT;

  ensureNotationDeclCapacity(chunk);

  return fNotationCount++;

}

Location: DTDGrammar.java

Content: 

/** 

 * Default constructor. 

 */

public DTDGrammar(SymbolTable symbolTable,XMLDTDDescription desc){

  fSymbolTable=symbolTable;

  fGrammarDescription=desc;

}

Location: DTDGrammar.java

Content: 

private void ensureAttributeDeclCapacity(int chunk){

  if (chunk >= fAttributeDeclName.length) {

    fAttributeDeclIsExternal=resize(fAttributeDeclIsExternal,fAttributeDeclIsExternal.length * 2);

    fAttributeDeclName=resize(fAttributeDeclName,fAttributeDeclName.length * 2);

    fAttributeDeclType=resize(fAttributeDeclType,fAttributeDeclType.length * 2);

    fAttributeDeclEnumeration=resize(fAttributeDeclEnumeration,fAttributeDeclEnumeration.length * 2);

    fAttributeDeclDefaultType=resize(fAttributeDeclDefaultType,fAttributeDeclDefaultType.length * 2);

    fAttributeDeclDatatypeValidator=resize(fAttributeDeclDatatypeValidator,fAttributeDeclDatatypeValidator.length * 2);

    fAttributeDeclDefaultValue=resize(fAttributeDeclDefaultValue,fAttributeDeclDefaultValue.length * 2);

    fAttributeDeclNonNormalizedDefaultValue=resize(fAttributeDeclNonNormalizedDefaultValue,fAttributeDeclNonNormalizedDefaultValue.length * 2);

    fAttributeDeclNextAttributeDeclIndex=resize(fAttributeDeclNextAttributeDeclIndex,fAttributeDeclNextAttributeDeclIndex.length * 2);

  }

 else   if (fAttributeDeclName[chunk] != null) {

    return;

  }

  fAttributeDeclIsExternal[chunk]=new int[CHUNK_SIZE];

  fAttributeDeclName[chunk]=new QName[CHUNK_SIZE];

  fAttributeDeclType[chunk]=new short[CHUNK_SIZE];

  fAttributeDeclEnumeration[chunk]=new String[CHUNK_SIZE][];

  fAttributeDeclDefaultType[chunk]=new short[CHUNK_SIZE];

  fAttributeDeclDatatypeValidator[chunk]=new DatatypeValidator[CHUNK_SIZE];

  fAttributeDeclDefaultValue[chunk]=new String[CHUNK_SIZE];

  fAttributeDeclNonNormalizedDefaultValue[chunk]=new String[CHUNK_SIZE];

  fAttributeDeclNextAttributeDeclIndex[chunk]=new int[CHUNK_SIZE];

  return;

}

Location: DTDGrammar.java

Content: 

private void ensureContentSpecCapacity(int chunk){

  if (chunk >= fContentSpecType.length) {

    fContentSpecType=resize(fContentSpecType,fContentSpecType.length * 2);

    fContentSpecValue=resize(fContentSpecValue,fContentSpecValue.length * 2);

    fContentSpecOtherValue=resize(fContentSpecOtherValue,fContentSpecOtherValue.length * 2);

  }

 else   if (fContentSpecType[chunk] != null) {

    return;

  }

  fContentSpecType[chunk]=new short[CHUNK_SIZE];

  fContentSpecValue[chunk]=new Object[CHUNK_SIZE];

  fContentSpecOtherValue[chunk]=new Object[CHUNK_SIZE];

  return;

}

Location: DTDGrammar.java

Content: 

private void ensureEntityDeclCapacity(int chunk){

  if (chunk >= fEntityName.length) {

    fEntityName=resize(fEntityName,fEntityName.length * 2);

    fEntityValue=resize(fEntityValue,fEntityValue.length * 2);

    fEntityPublicId=resize(fEntityPublicId,fEntityPublicId.length * 2);

    fEntitySystemId=resize(fEntitySystemId,fEntitySystemId.length * 2);

    fEntityBaseSystemId=resize(fEntityBaseSystemId,fEntityBaseSystemId.length * 2);

    fEntityNotation=resize(fEntityNotation,fEntityNotation.length * 2);

    fEntityIsPE=resize(fEntityIsPE,fEntityIsPE.length * 2);

    fEntityInExternal=resize(fEntityInExternal,fEntityInExternal.length * 2);

  }

 else   if (fEntityName[chunk] != null) {

    return;

  }

  fEntityName[chunk]=new String[CHUNK_SIZE];

  fEntityValue[chunk]=new String[CHUNK_SIZE];

  fEntityPublicId[chunk]=new String[CHUNK_SIZE];

  fEntitySystemId[chunk]=new String[CHUNK_SIZE];

  fEntityBaseSystemId[chunk]=new String[CHUNK_SIZE];

  fEntityNotation[chunk]=new String[CHUNK_SIZE];

  fEntityIsPE[chunk]=new byte[CHUNK_SIZE];

  fEntityInExternal[chunk]=new byte[CHUNK_SIZE];

  return;

}

Location: DTDGrammar.java

Content: 

private void ensureNotationDeclCapacity(int chunk){

  if (chunk >= fNotationName.length) {

    fNotationName=resize(fNotationName,fNotationName.length * 2);

    fNotationPublicId=resize(fNotationPublicId,fNotationPublicId.length * 2);

    fNotationSystemId=resize(fNotationSystemId,fNotationSystemId.length * 2);

    fNotationBaseSystemId=resize(fNotationBaseSystemId,fNotationBaseSystemId.length * 2);

  }

 else   if (fNotationName[chunk] != null) {

    return;

  }

  fNotationName[chunk]=new String[CHUNK_SIZE];

  fNotationPublicId[chunk]=new String[CHUNK_SIZE];

  fNotationSystemId[chunk]=new String[CHUNK_SIZE];

  fNotationBaseSystemId[chunk]=new String[CHUNK_SIZE];

  return;

}

Location: DTDGrammar.java

Content: 

public int getAttributeDeclIndex(int elementDeclIndex,String attributeDeclName){

  if (elementDeclIndex == -1) {

    return -1;

  }

  int attDefIndex=getFirstAttributeDeclIndex(elementDeclIndex);

  while (attDefIndex != -1) {

    getAttributeDecl(attDefIndex,fAttributeDecl);

    if (fAttributeDecl.name.rawname == attributeDeclName || attributeDeclName.equals(fAttributeDecl.name.rawname)) {

      return attDefIndex;

    }

    attDefIndex=getNextAttributeDeclIndex(attDefIndex);

  }

  return -1;

}

Location: DTDGrammar.java

Content: 

/** 

 * Returns true if the specified attribute declaration is external.

 * @param attributeDeclIndex Attribute declaration index.

 */

public boolean getAttributeDeclIsExternal(int attributeDeclIndex){

  if (attributeDeclIndex < 0) {

    return false;

  }

  int chunk=attributeDeclIndex >> CHUNK_SHIFT;

  int index=attributeDeclIndex & CHUNK_MASK;

  return (fAttributeDeclIsExternal[chunk][index] != 0);

}

Location: DTDGrammar.java

Content: 

/** 

 * getAttributeDecl

 * @param attributeDeclIndex 

 * @param attributeDecl The values of this structure are set by this call.

 * @return true if getAttributeDecl was able to fill in the value of attributeDecl

 */

public boolean getAttributeDecl(int attributeDeclIndex,XMLAttributeDecl attributeDecl){

  if (attributeDeclIndex < 0 || attributeDeclIndex >= fAttributeDeclCount) {

    return false;

  }

  int chunk=attributeDeclIndex >> CHUNK_SHIFT;

  int index=attributeDeclIndex & CHUNK_MASK;

  attributeDecl.name.setValues(fAttributeDeclName[chunk][index]);

  short attributeType;

  boolean isList;

  if (fAttributeDeclType[chunk][index] == -1) {

    attributeType=-1;

    isList=false;

  }

 else {

    attributeType=(short)(fAttributeDeclType[chunk][index] & LIST_MASK);

    isList=(fAttributeDeclType[chunk][index] & LIST_FLAG) != 0;

  }

  attributeDecl.simpleType.setValues(attributeType,fAttributeDeclName[chunk][index].localpart,fAttributeDeclEnumeration[chunk][index],isList,fAttributeDeclDefaultType[chunk][index],fAttributeDeclDefaultValue[chunk][index],fAttributeDeclNonNormalizedDefaultValue[chunk][index],fAttributeDeclDatatypeValidator[chunk][index]);

  return true;

}

Location: DTDGrammar.java

Content: 

/** 

 * getContentSpecAsString

 * @param elementDeclIndex

 * @return String

 */

public String getContentSpecAsString(int elementDeclIndex){

  if (elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount) {

    return null;

  }

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  int contentSpecIndex=fElementDeclContentSpecIndex[chunk][index];

  XMLContentSpec contentSpec=new XMLContentSpec();

  if (getContentSpec(contentSpecIndex,contentSpec)) {

    StringBuffer str=new StringBuffer();

    int parentContentSpecType=contentSpec.type & 0x0f;

    int nextContentSpec;

switch (parentContentSpecType) {

case XMLContentSpec.CONTENTSPECNODE_LEAF:

{

        str.append('(');

        if (contentSpec.value == null && contentSpec.otherValue == null) {

          str.append("#PCDATA");

        }

 else {

          str.append(contentSpec.value);

        }

        str.append(')');

        break;

      }

case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE:

{

      getContentSpec(((int[])contentSpec.value)[0],contentSpec);

      nextContentSpec=contentSpec.type;

      if (nextContentSpec == XMLContentSpec.CONTENTSPECNODE_LEAF) {

        str.append('(');

        str.append(contentSpec.value);

        str.append(')');

      }

 else       if (nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE || nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) {

        str.append('(');

        appendContentSpec(contentSpec,str,true,parentContentSpecType);

        str.append(')');

      }

 else {

        appendContentSpec(contentSpec,str,true,parentContentSpecType);

      }

      str.append('?');

      break;

    }

case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE:

{

    getContentSpec(((int[])contentSpec.value)[0],contentSpec);

    nextContentSpec=contentSpec.type;

    if (nextContentSpec == XMLContentSpec.CONTENTSPECNODE_LEAF) {

      str.append('(');

      if (contentSpec.value == null && contentSpec.otherValue == null) {

        str.append("#PCDATA");

      }

 else       if (contentSpec.otherValue != null) {

        str.append("##any:uri=").append(contentSpec.otherValue);

      }

 else       if (contentSpec.value == null) {

        str.append("##any");

      }

 else {

        appendContentSpec(contentSpec,str,true,parentContentSpecType);

      }

      str.append(')');

    }

 else     if (nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE || nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) {

      str.append('(');

      appendContentSpec(contentSpec,str,true,parentContentSpecType);

      str.append(')');

    }

 else {

      appendContentSpec(contentSpec,str,true,parentContentSpecType);

    }

    str.append('*');

    break;

  }

case XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE:

{

  getContentSpec(((int[])contentSpec.value)[0],contentSpec);

  nextContentSpec=contentSpec.type;

  if (nextContentSpec == XMLContentSpec.CONTENTSPECNODE_LEAF) {

    str.append('(');

    if (contentSpec.value == null && contentSpec.otherValue == null) {

      str.append("#PCDATA");

    }

 else     if (contentSpec.otherValue != null) {

      str.append("##any:uri=").append(contentSpec.otherValue);

    }

 else     if (contentSpec.value == null) {

      str.append("##any");

    }

 else {

      str.append(contentSpec.value);

    }

    str.append(')');

  }

 else   if (nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE || nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || nextContentSpec == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) {

    str.append('(');

    appendContentSpec(contentSpec,str,true,parentContentSpecType);

    str.append(')');

  }

 else {

    appendContentSpec(contentSpec,str,true,parentContentSpecType);

  }

  str.append('+');

  break;

}

case XMLContentSpec.CONTENTSPECNODE_CHOICE:

case XMLContentSpec.CONTENTSPECNODE_SEQ:

{

appendContentSpec(contentSpec,str,true,parentContentSpecType);

break;

}

case XMLContentSpec.CONTENTSPECNODE_ANY:

{

str.append("##any");

if (contentSpec.otherValue != null) {

str.append(":uri=");

str.append(contentSpec.otherValue);

}

break;

}

case XMLContentSpec.CONTENTSPECNODE_ANY_OTHER:

{

str.append("##other:uri=");

str.append(contentSpec.otherValue);

break;

}

case XMLContentSpec.CONTENTSPECNODE_ANY_LOCAL:

{

str.append("##local");

break;

}

default :

{

str.append("???");

}

}

return str.toString();

}

return null;

}

Location: DTDGrammar.java

Content: 

/** 

 * Returns the index to the content spec for the given element  declaration, or <code>-1</code> if the element declaration index was invalid.

 */

public int getContentSpecIndex(int elementDeclIndex){

  if (elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount) {

    return -1;

  }

  final int chunk=elementDeclIndex >> CHUNK_SHIFT;

  final int index=elementDeclIndex & CHUNK_MASK;

  return fElementDeclContentSpecIndex[chunk][index];

}

Location: DTDGrammar.java

Content: 

/** 

 * getContentSpec

 * @param contentSpecIndex 

 * @param contentSpec

 * @return true if find the requested contentSpec node, false otherwise

 */

public boolean getContentSpec(int contentSpecIndex,XMLContentSpec contentSpec){

  if (contentSpecIndex < 0 || contentSpecIndex >= fContentSpecCount)   return false;

  int chunk=contentSpecIndex >> CHUNK_SHIFT;

  int index=contentSpecIndex & CHUNK_MASK;

  contentSpec.type=fContentSpecType[chunk][index];

  contentSpec.value=fContentSpecValue[chunk][index];

  contentSpec.otherValue=fContentSpecOtherValue[chunk][index];

  return true;

}

Location: DTDGrammar.java

Content: 

/** 

 * getElementContentModelValidator

 * @param elementDeclIndex 

 * @return its ContentModelValidator if any.

 */

protected ContentModelValidator getElementContentModelValidator(int elementDeclIndex){

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  ContentModelValidator contentModel=fElementDeclContentModelValidator[chunk][index];

  if (contentModel != null) {

    return contentModel;

  }

  int contentType=fElementDeclType[chunk][index];

  if (contentType == XMLElementDecl.TYPE_SIMPLE) {

    return null;

  }

  int contentSpecIndex=fElementDeclContentSpecIndex[chunk][index];

  XMLContentSpec contentSpec=new XMLContentSpec();

  getContentSpec(contentSpecIndex,contentSpec);

  if (contentType == XMLElementDecl.TYPE_MIXED) {

    ChildrenList children=new ChildrenList();

    contentSpecTree(contentSpecIndex,contentSpec,children);

    contentModel=new MixedContentModel(children.qname,children.type,0,children.length,false);

  }

 else   if (contentType == XMLElementDecl.TYPE_CHILDREN) {

    contentModel=createChildModel(contentSpecIndex);

  }

 else {

    throw new RuntimeException("Unknown content type for a element decl " + "in getElementContentModelValidator() in AbstractDTDGrammar class");

  }

  fElementDeclContentModelValidator[chunk][index]=contentModel;

  return contentModel;

}

Location: DTDGrammar.java

Content: 

/** 

 * Returns the element decl index.

 * @param elementDeclQName qualilfied name of the element

 */

public int getElementDeclIndex(QName elementDeclQName){

  return getElementDeclIndex(elementDeclQName.rawname);

}

Location: DTDGrammar.java

Content: 

/** 

 * getElementDeclIndex

 * @param elementDeclName 

 * @return index of the elementDeclName in scope

 */

public int getElementDeclIndex(String elementDeclName){

  int mapping=fElementIndexMap.get(elementDeclName);

  return mapping;

}

Location: DTDGrammar.java

Content: 

/** 

 * Returns true if the specified element declaration is external.

 * @param elementDeclIndex The element declaration index.

 */

public boolean getElementDeclIsExternal(int elementDeclIndex){

  if (elementDeclIndex < 0) {

    return false;

  }

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  return (fElementDeclIsExternal[chunk][index] != 0);

}

Location: DTDGrammar.java

Content: 

QName getElementDeclName(int elementDeclIndex){

  if (elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount) {

    return null;

  }

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  return fElementDeclName[chunk][index];

}

Location: DTDGrammar.java

Content: 

/** 

 * getElementDecl

 * @param elementDeclIndex 

 * @param elementDecl The values of this structure are set by this call.

 * @return True if find the element, False otherwise. 

 */

public boolean getElementDecl(int elementDeclIndex,XMLElementDecl elementDecl){

  if (elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount) {

    return false;

  }

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  elementDecl.name.setValues(fElementDeclName[chunk][index]);

  if (fElementDeclType[chunk][index] == -1) {

    elementDecl.type=-1;

    elementDecl.simpleType.list=false;

  }

 else {

    elementDecl.type=(short)(fElementDeclType[chunk][index] & LIST_MASK);

    elementDecl.simpleType.list=(fElementDeclType[chunk][index] & LIST_FLAG) != 0;

  }

  if (elementDecl.type == XMLElementDecl.TYPE_CHILDREN || elementDecl.type == XMLElementDecl.TYPE_MIXED) {

    elementDecl.contentModelValidator=getElementContentModelValidator(elementDeclIndex);

  }

  elementDecl.simpleType.datatypeValidator=null;

  elementDecl.simpleType.defaultType=-1;

  elementDecl.simpleType.defaultValue=null;

  return true;

}

Location: DTDGrammar.java

Content: 

/** 

 * getEntityDeclIndex

 * @param entityDeclName 

 * @return the index of the EntityDecl

 */

public int getEntityDeclIndex(String entityDeclName){

  if (entityDeclName == null) {

    return -1;

  }

  return fEntityIndexMap.get(entityDeclName);

}

Location: DTDGrammar.java

Content: 

/** 

 * getEntityDecl

 * @param entityDeclIndex 

 * @param entityDecl 

 * @return true if getEntityDecl was able to fill entityDecl with the contents of the entitywith index entityDeclIndex

 */

public boolean getEntityDecl(int entityDeclIndex,XMLEntityDecl entityDecl){

  if (entityDeclIndex < 0 || entityDeclIndex >= fEntityCount) {

    return false;

  }

  int chunk=entityDeclIndex >> CHUNK_SHIFT;

  int index=entityDeclIndex & CHUNK_MASK;

  entityDecl.setValues(fEntityName[chunk][index],fEntityPublicId[chunk][index],fEntitySystemId[chunk][index],fEntityBaseSystemId[chunk][index],fEntityNotation[chunk][index],fEntityValue[chunk][index],fEntityIsPE[chunk][index] == 0 ? false : true,fEntityInExternal[chunk][index] == 0 ? false : true);

  return true;

}

Location: DTDGrammar.java

Content: 

/** 

 * getFirstAttributeDeclIndex

 * @param elementDeclIndex 

 * @return index of the first attribute for element declaration elementDeclIndex

 */

public int getFirstAttributeDeclIndex(int elementDeclIndex){

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  return fElementDeclFirstAttributeDeclIndex[chunk][index];

}

Location: DTDGrammar.java

Content: 

/** 

 * Returns the index of the first element declaration. This index is then used to query more information about the element declaration.

 * @see #getNextElementDeclIndex

 * @see #getElementDecl

 */

public int getFirstElementDeclIndex(){

  return fElementDeclCount >= 0 ? 0 : -1;

}

Location: DTDGrammar.java

Content: 

/** 

 * getNextAttributeDeclIndex

 * @param attributeDeclIndex 

 * @return index of the next attribute of the attribute at attributeDeclIndex

 */

public int getNextAttributeDeclIndex(int attributeDeclIndex){

  int chunk=attributeDeclIndex >> CHUNK_SHIFT;

  int index=attributeDeclIndex & CHUNK_MASK;

  return fAttributeDeclNextAttributeDeclIndex[chunk][index];

}

Location: DTDGrammar.java

Content: 

/** 

 * Returns the next index of the element declaration following the specified element declaration.

 * @param elementDeclIndex The element declaration index.

 */

public int getNextElementDeclIndex(int elementDeclIndex){

  return elementDeclIndex < fElementDeclCount - 1 ? elementDeclIndex + 1 : -1;

}

Location: DTDGrammar.java

Content: 

/** 

 * getNotationDeclIndex

 * @param notationDeclName 

 * @return the index if found a notation with the name, otherwise -1.

 */

public int getNotationDeclIndex(String notationDeclName){

  if (notationDeclName == null) {

    return -1;

  }

  return fNotationIndexMap.get(notationDeclName);

}

Location: DTDGrammar.java

Content: 

/** 

 * getNotationDecl

 * @param notationDeclIndex 

 * @param notationDecl 

 * @return return true of getNotationDecl can fill notationDecl with information about the notation at notationDeclIndex.

 */

public boolean getNotationDecl(int notationDeclIndex,XMLNotationDecl notationDecl){

  if (notationDeclIndex < 0 || notationDeclIndex >= fNotationCount) {

    return false;

  }

  int chunk=notationDeclIndex >> CHUNK_SHIFT;

  int index=notationDeclIndex & CHUNK_MASK;

  notationDecl.setValues(fNotationName[chunk][index],fNotationPublicId[chunk][index],fNotationSystemId[chunk][index],fNotationBaseSystemId[chunk][index]);

  return true;

}

Location: DTDGrammar.java

Content: 

/** 

 * Initialize content model stack. 

 */

protected void initializeContentModelStack(){

  if (fOpStack == null) {

    fOpStack=new short[8];

    fNodeIndexStack=new int[8];

    fPrevNodeIndexStack=new int[8];

  }

 else   if (fDepth == fOpStack.length) {

    short[] newStack=new short[fDepth * 2];

    System.arraycopy(fOpStack,0,newStack,0,fDepth);

    fOpStack=newStack;

    int[] newIntStack=new int[fDepth * 2];

    System.arraycopy(fNodeIndexStack,0,newIntStack,0,fDepth);

    fNodeIndexStack=newIntStack;

    newIntStack=new int[fDepth * 2];

    System.arraycopy(fPrevNodeIndexStack,0,newIntStack,0,fDepth);

    fPrevNodeIndexStack=newIntStack;

  }

  fOpStack[fDepth]=-1;

  fNodeIndexStack[fDepth]=-1;

  fPrevNodeIndexStack[fDepth]=-1;

}

Location: DTDGrammar.java

Content: 

/** 

 * Returns whether the given attribute is of type CDATA or not

 * @param elName The element name.

 * @param atName The attribute name.

 * @return true if the attribute is of type CDATA

 */

public boolean isCDATAAttribute(QName elName,QName atName){

  int elDeclIdx=getElementDeclIndex(elName);

  if (getAttributeDecl(elDeclIdx,fAttributeDecl) && fAttributeDecl.simpleType.type != XMLSimpleType.TYPE_CDATA) {

    return false;

  }

  return true;

}

Location: DTDGrammar.java

Content: 

public void printAttributes(int elementDeclIndex){

  int attributeDeclIndex=getFirstAttributeDeclIndex(elementDeclIndex);

  System.out.print(elementDeclIndex);

  System.out.print(" [");

  while (attributeDeclIndex != -1) {

    System.out.print(' ');

    System.out.print(attributeDeclIndex);

    printAttribute(attributeDeclIndex);

    attributeDeclIndex=getNextAttributeDeclIndex(attributeDeclIndex);

    if (attributeDeclIndex != -1) {

      System.out.print(",");

    }

  }

  System.out.println(" ]");

}

Location: DTDGrammar.java

Content: 

private void printAttribute(int attributeDeclIndex){

  XMLAttributeDecl attributeDecl=new XMLAttributeDecl();

  if (getAttributeDecl(attributeDeclIndex,attributeDecl)) {

    System.out.print(" { ");

    System.out.print(attributeDecl.name.localpart);

    System.out.print(" }");

  }

}

Location: DTDGrammar.java

Content: 

public void printElements(){

  int elementDeclIndex=0;

  XMLElementDecl elementDecl=new XMLElementDecl();

  while (getElementDecl(elementDeclIndex++,elementDecl)) {

    System.out.println("element decl: " + elementDecl.name + ", "+ elementDecl.name.rawname);

  }

}

Location: DTDGrammar.java

Content: 

protected void putElementNameMapping(QName name,int scope,int elementDeclIndex){

}

Location: DTDGrammar.java

Content: 

private static byte[][] resize(byte array[][],int newsize){

  byte newarray[][]=new byte[newsize][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

private static ContentModelValidator[][] resize(ContentModelValidator array[][],int newsize){

  ContentModelValidator newarray[][]=new ContentModelValidator[newsize][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

private static DatatypeValidator[][] resize(DatatypeValidator array[][],int newsize){

  DatatypeValidator newarray[][]=new DatatypeValidator[newsize][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

private static int[][] resize(int array[][],int newsize){

  int newarray[][]=new int[newsize][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

private static Object[][] resize(Object array[][],int newsize){

  Object newarray[][]=new Object[newsize][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

private static QName[][] resize(QName array[][],int newsize){

  QName newarray[][]=new QName[newsize][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

private static short[][] resize(short array[][],int newsize){

  short newarray[][]=new short[newsize][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

private static String[][][] resize(String array[][][],int newsize){

  String newarray[][][]=new String[newsize][][];

  System.arraycopy(array,0,newarray,0,array.length);

  return newarray;

}

Location: DTDGrammar.java

Content: 

protected void setAttributeDecl(int elementDeclIndex,int attributeDeclIndex,XMLAttributeDecl attributeDecl){

  int attrChunk=attributeDeclIndex >> CHUNK_SHIFT;

  int attrIndex=attributeDeclIndex & CHUNK_MASK;

  fAttributeDeclName[attrChunk][attrIndex].setValues(attributeDecl.name);

  fAttributeDeclType[attrChunk][attrIndex]=attributeDecl.simpleType.type;

  if (attributeDecl.simpleType.list) {

    fAttributeDeclType[attrChunk][attrIndex]|=LIST_FLAG;

  }

  fAttributeDeclEnumeration[attrChunk][attrIndex]=attributeDecl.simpleType.enumeration;

  fAttributeDeclDefaultType[attrChunk][attrIndex]=attributeDecl.simpleType.defaultType;

  fAttributeDeclDatatypeValidator[attrChunk][attrIndex]=attributeDecl.simpleType.datatypeValidator;

  fAttributeDeclDefaultValue[attrChunk][attrIndex]=attributeDecl.simpleType.defaultValue;

  fAttributeDeclNonNormalizedDefaultValue[attrChunk][attrIndex]=attributeDecl.simpleType.nonNormalizedDefaultValue;

  int elemChunk=elementDeclIndex >> CHUNK_SHIFT;

  int elemIndex=elementDeclIndex & CHUNK_MASK;

  int index=fElementDeclFirstAttributeDeclIndex[elemChunk][elemIndex];

  while (index != -1) {

    if (index == attributeDeclIndex) {

      break;

    }

    attrChunk=index >> CHUNK_SHIFT;

    attrIndex=index & CHUNK_MASK;

    index=fAttributeDeclNextAttributeDeclIndex[attrChunk][attrIndex];

  }

  if (index == -1) {

    if (fElementDeclFirstAttributeDeclIndex[elemChunk][elemIndex] == -1) {

      fElementDeclFirstAttributeDeclIndex[elemChunk][elemIndex]=attributeDeclIndex;

    }

 else {

      index=fElementDeclLastAttributeDeclIndex[elemChunk][elemIndex];

      attrChunk=index >> CHUNK_SHIFT;

      attrIndex=index & CHUNK_MASK;

      fAttributeDeclNextAttributeDeclIndex[attrChunk][attrIndex]=attributeDeclIndex;

    }

    fElementDeclLastAttributeDeclIndex[elemChunk][elemIndex]=attributeDeclIndex;

  }

}

Location: DTDGrammar.java

Content: 

protected void setContentSpecIndex(int elementDeclIndex,int contentSpecIndex){

  if (elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount) {

    return;

  }

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  fElementDeclContentSpecIndex[chunk][index]=contentSpecIndex;

}

Location: DTDGrammar.java

Content: 

protected void setContentSpec(int contentSpecIndex,XMLContentSpec contentSpec){

  int chunk=contentSpecIndex >> CHUNK_SHIFT;

  int index=contentSpecIndex & CHUNK_MASK;

  fContentSpecType[chunk][index]=contentSpec.type;

  fContentSpecValue[chunk][index]=contentSpec.value;

  fContentSpecOtherValue[chunk][index]=contentSpec.otherValue;

}

Location: DTDGrammar.java

Content: 

protected void setElementDecl(int elementDeclIndex,XMLElementDecl elementDecl){

  if (elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount) {

    return;

  }

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  fElementDeclName[chunk][index].setValues(elementDecl.name);

  fElementDeclType[chunk][index]=elementDecl.type;

  fElementDeclContentModelValidator[chunk][index]=elementDecl.contentModelValidator;

  if (elementDecl.simpleType.list == true) {

    fElementDeclType[chunk][index]|=LIST_FLAG;

  }

  fElementIndexMap.put(elementDecl.name.rawname,elementDeclIndex);

}

Location: DTDGrammar.java

Content: 

protected void setEntityDecl(int entityDeclIndex,XMLEntityDecl entityDecl){

  int chunk=entityDeclIndex >> CHUNK_SHIFT;

  int index=entityDeclIndex & CHUNK_MASK;

  fEntityName[chunk][index]=entityDecl.name;

  fEntityValue[chunk][index]=entityDecl.value;

  fEntityPublicId[chunk][index]=entityDecl.publicId;

  fEntitySystemId[chunk][index]=entityDecl.systemId;

  fEntityBaseSystemId[chunk][index]=entityDecl.baseSystemId;

  fEntityNotation[chunk][index]=entityDecl.notation;

  fEntityIsPE[chunk][index]=entityDecl.isPE ? (byte)1 : (byte)0;

  fEntityInExternal[chunk][index]=entityDecl.inExternal ? (byte)1 : (byte)0;

  fEntityIndexMap.put(entityDecl.name,entityDeclIndex);

}

Location: DTDGrammar.java

Content: 

protected void setFirstAttributeDeclIndex(int elementDeclIndex,int newFirstAttrIndex){

  if (elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount) {

    return;

  }

  int chunk=elementDeclIndex >> CHUNK_SHIFT;

  int index=elementDeclIndex & CHUNK_MASK;

  fElementDeclFirstAttributeDeclIndex[chunk][index]=newFirstAttrIndex;

}

Location: DTDGrammar.java

Content: 

protected void setNotationDecl(int notationDeclIndex,XMLNotationDecl notationDecl){

  int chunk=notationDeclIndex >> CHUNK_SHIFT;

  int index=notationDeclIndex & CHUNK_MASK;

  fNotationName[chunk][index]=notationDecl.name;

  fNotationPublicId[chunk][index]=notationDecl.publicId;

  fNotationSystemId[chunk][index]=notationDecl.systemId;

  fNotationBaseSystemId[chunk][index]=notationDecl.baseSystemId;

  fNotationIndexMap.put(notationDecl.name,notationDeclIndex);

}

