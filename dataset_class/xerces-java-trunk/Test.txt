Location: Test.java

Content: 

Attr addNoisyAttr(Document doc,Element parent,int index){

  String attrName=parent.getNodeName() + "_A" + index;

  Attr a=doc.createAttribute(attrName);

  reportAllMutations(a);

  a.setNodeValue("Initialized A" + index + " of "+ parent.getNodeName());

  parent.setAttributeNode(a);

  return a;

}

Location: Test.java

Content: 

Element addNoisyElement(Document doc,Node parent,int index){

  String nodeName="Root";

  if (parent != doc)   nodeName=parent.getNodeName() + "_E" + index;

  Element e=doc.createElement(nodeName);

  reportAllMutations(e);

  parent.appendChild(e);

  return e;

}

Location: Test.java

Content: 

Text addNoisyText(Document doc,Node parent,String data){

  Text t=doc.createTextNode(data);

  reportAllMutations(t);

  parent.appendChild(t);

  return t;

}

Location: Test.java

Content: 

public void addTest(int t){

  fTests[fNumTests++]=t;

}

Location: Test.java

Content: 

protected boolean compareOutput(Reader expected,Reader actual) throws IOException {

  LineNumberReader expectedOutput=new LineNumberReader(expected);

  LineNumberReader actualOutput=new LineNumberReader(actual);

  while (expectedOutput.ready() && actualOutput.ready()) {

    String expectedLine=expectedOutput.readLine();

    String actualLine=actualOutput.readLine();

    if (!expectedLine.equals(actualLine)) {

      fLogStream.println("Mismatch on line: " + expectedOutput.getLineNumber());

      fLogStream.println("Expected: " + expectedLine);

      fLogStream.println("  Actual: " + actualLine);

      return false;

    }

  }

  if (expectedOutput.ready() && !actualOutput.ready()) {

    String expectedLine=expectedOutput.readLine();

    if (expectedLine != null) {

      fLogStream.println("Actual output contains fewer lines than expected output.");

      fLogStream.println("Line " + expectedOutput.getLineNumber() + ": "+ expectedLine);

      fLogStream.println("Above line has no match in actual output.");

      return false;

    }

  }

 else   if (!expectedOutput.ready() && actualOutput.ready()) {

    String actualLine=actualOutput.readLine();

    if (actualLine != null) {

      fLogStream.println("Actual output contains more lines than expected output.");

      fLogStream.println("Line " + actualOutput.getLineNumber() + ": "+ actualLine);

      fLogStream.println("Above line has no match in expected output.");

      return false;

    }

  }

  expectedOutput.close();

  actualOutput.close();

  return true;

}

Location: Test.java

Content: 

public static Document deserialize(String filename) throws Exception {

  System.out.println("De-Serializing parsed document");

  ObjectInputStream in=new ObjectInputStream(new FileInputStream(filename));

  Document result=(Document)in.readObject();

  return result;

}

Location: Test.java

Content: 

/** 

 * version 3.0 01/25/99

 * @return boolean

 * @param node java.lang.Object

 * @param mNameIndex int

 * @param signatureIndex int

 * @param parameters java.lang.Object[]

 * @param code short

 * @author Philip W. Davis

 */

public static boolean DOMExceptionsTest(Object node,String methodName,Class[] methodSignature,Object[] parameters,short code){

  boolean asExpected=false;

  Method method;

  try {

    method=node.getClass().getMethod(methodName,methodSignature);

    method.invoke(node,parameters);

  }

 catch (  InvocationTargetException exc) {

    Throwable realE=exc.getTargetException();

    if (realE instanceof DOMException) {

      asExpected=(((DOMException)realE).code == code);

      if (!asExpected)       System.out.println("Wrong DOMException(" + ((DOMException)realE).code + ")");

    }

 else {

      System.out.println("Wrong Exception (" + code + ")");

    }

    if (!asExpected) {

      System.out.println("Expected DOMException (" + code + ") not thrown");

    }

  }

catch (  Exception exc) {

    System.out.println("test invocation failure (" + exc + ")");

  }

  return (asExpected);

}

Location: Test.java

Content: 

public void error(String domain,String key,XMLParseException exception) throws XNIException {

  printError("Error",exception);

}

Location: Test.java

Content: 

public void fatalError(String domain,String key,XMLParseException exception) throws XNIException {

  printError("Fatal Error",exception);

}

Location: Test.java

Content: 

private static String getPathWithoutEscapes(String origPath){

  if (origPath != null && origPath.length() != 0 && origPath.indexOf('%') != -1) {

    StringTokenizer tokenizer=new StringTokenizer(origPath,"%");

    StringBuffer result=new StringBuffer(origPath.length());

    int size=tokenizer.countTokens();

    result.append(tokenizer.nextToken());

    for (int i=1; i < size; ++i) {

      String token=tokenizer.nextToken();

      result.append((char)Integer.valueOf(token.substring(0,2),16).intValue());

      result.append(token.substring(2));

    }

    return result.toString();

  }

  return origPath;

}

Location: Test.java

Content: 

/** 

 * This method is called whenever the node for which this handler is  registered is imported, cloned, or renamed.

 * @param operation Specifies the type of operation that is being performed on the node.

 * @param key Specifies the key for which this handler is being called. 

 * @param data Specifies the data for which this handler is being called. 

 * @param src Specifies the node being cloned, imported, or renamed. This is <code>null</code> when the node is being deleted.

 * @param dst Specifies the node newly created if any, or <code>null</code>.

 */

public void handle(short operation,String key,Object data,Node src,Node dst){

  lastOperation=operation;

  lastKey=key;

  lastData=data;

  lastSource=src;

  lastDestination=dst;

}

Location: Test.java

Content: 

public static void main(String[] args){

  Test tester=new Test();

  boolean testsSpecified=false;

  for (int i=0; i < args.length; i++) {

    if (args[i].charAt(0) == '-' && args[i].length() > 1) {

switch (args[i].charAt(1)) {

case 'g':

        tester.fGenerate=true;

      if (args.length > i + 1 && args[i + 1].charAt(0) != '-') {

        try {

          Integer.parseInt(args[i + 1]);

          tester.setLogFile(System.err);

        }

 catch (        NumberFormatException e) {

          tester.fOutputDirectory=args[++i];

        }

      }

    break;

case 'h':

  printUsage();

return;

case 'f':

if (args.length > i + 1 && args[i + 1].charAt(0) != '-') {

try {

  Integer.parseInt(args[i + 1]);

  tester.setLogFile(System.err);

}

 catch (NumberFormatException e) {

  try {

    tester.setLogFile(new PrintStream(new FileOutputStream(args[++i])));

  }

 catch (  IOException ioe) {

    System.err.println("Couldn't open log file: " + args[i]);

  }

}

}

 else {

tester.setLogFile(System.err);

}

break;

default :

System.err.println("Unrecognized option: " + args[i]);

}

}

 else {

testsSpecified=true;

tester.addTest(Integer.parseInt(args[i]));

}

}

if (!testsSpecified) {

for (int i=1; i <= NUM_TESTS; i++) {

tester.addTest(i);

}

}

if (tester.fGenerate) {

File outputDir=new File(tester.fOutputDirectory);

if (!outputDir.exists()) {

outputDir.mkdirs();

}

}

tester.runTests();

}

Location: Test.java

Content: 

/** 

 * Normalizes the given string. 

 */

protected String normalize(String s){

  StringBuffer str=new StringBuffer();

  int len=(s != null) ? s.length() : 0;

  for (int i=0; i < len; i++) {

    char ch=s.charAt(i);

switch (ch) {

case '<':

{

        str.append("&lt;");

        break;

      }

case '>':

{

      str.append("&gt;");

      break;

    }

case '&':

{

    str.append("&amp;");

    break;

  }

case '"':

{

  str.append("&quot;");

  break;

}

case '\r':

case '\n':

{

if (canonical) {

  str.append("&#");

  str.append(Integer.toString(ch));

  str.append(';');

  break;

}

}

default :

{

str.append(ch);

}

}

}

return (str.toString());

}

Location: Test.java

Content: 

void parseCommandLine(String argv[]){

  gRunInfo.quiet=false;

  gRunInfo.verbose=false;

  gRunInfo.numThreads=2;

  gRunInfo.validating=false;

  gRunInfo.dom=false;

  gRunInfo.reuseParser=false;

  gRunInfo.inMemory=false;

  gRunInfo.dumpOnErr=false;

  gRunInfo.totalTime=0;

  gRunInfo.numInputFiles=0;

  try {

    int argnum=0;

    int argc=argv.length;

    while (argnum < argc) {

      if (argv[argnum].equals("-quiet"))       gRunInfo.quiet=true;

 else       if (argv[argnum].equals("-verbose"))       gRunInfo.verbose=true;

 else       if (argv[argnum].equals("-v"))       gRunInfo.validating=true;

 else       if (argv[argnum].equals("-dom"))       gRunInfo.dom=true;

 else       if (argv[argnum].equals("-reuse"))       gRunInfo.reuseParser=true;

 else       if (argv[argnum].equals("-dump"))       gRunInfo.dumpOnErr=true;

 else       if (argv[argnum].equals("-mem"))       gRunInfo.inMemory=true;

 else       if (argv[argnum].equals("-threads")) {

        ++argnum;

        if (argnum >= argc)         throw new Exception();

        try {

          gRunInfo.numThreads=Integer.parseInt(argv[argnum]);

        }

 catch (        NumberFormatException e) {

          throw new Exception();

        }

        if (gRunInfo.numThreads < 0)         throw new Exception();

      }

 else       if (argv[argnum].equals("-time")) {

        ++argnum;

        if (argnum >= argc)         throw new Exception();

        try {

          gRunInfo.totalTime=Integer.parseInt(argv[argnum]);

        }

 catch (        NumberFormatException e) {

          throw new Exception();

        }

        if (gRunInfo.totalTime < 1)         throw new Exception();

      }

 else       if (argv[argnum].charAt(0) == '-') {

        System.err.println("Unrecognized command line option. Scanning" + " \"" + argv[argnum] + "\"");

        throw new Exception();

      }

 else {

        gRunInfo.numInputFiles++;

        if (gRunInfo.numInputFiles >= MAXINFILES) {

          System.err.println("Too many input files. Limit is " + MAXINFILES);

          throw new Exception();

        }

        gRunInfo.files[gRunInfo.numInputFiles - 1]=new InFileInfo();

        gRunInfo.files[gRunInfo.numInputFiles - 1].fileName=argv[argnum];

      }

      argnum++;

    }

    if (gRunInfo.numInputFiles == 0) {

      System.err.println("No input XML file specified on command line.");

      throw new Exception();

    }

    ;

  }

 catch (  Exception e) {

    System.err.print("usage: java thread.Test [-v] [-threads nnn] [-time nnn] [-quiet] [-verbose] xmlfile...\n" + "     -v             Use validating parser.  Non-validating is default. \n" + "     -dom           Use a DOM parser.  Default is SAX. \n"+ "     -quiet         Suppress periodic status display. \n"+ "     -verbose       Display extra messages. \n"+ "     -reuse         Retain and reuse parser.  Default creates new for each parse.\n"+ "     -threads nnn   Number of threads.  Default is 2. \n"+ "     -time nnn      Total time to run, in seconds.  Default is forever.\n"+ "     -dump          Dump DOM tree on error.\n"+ "     -mem           Read files into memory once only, and parse them from there.\n");

    System.exit(1);

  }

}

Location: Test.java

Content: 

public boolean performTest(String arg){

  boolean passed=true;

  try {

    Writer writer=new Writer(false);

    DOMParser parser=new DOMParser();

    if (!arg.equals("delete2") && !arg.equals("insert2")) {

      if (fStdOut)       System.out.println("\n*************** Test == " + arg + " ***************");

      for (int i=0; i < tests.length; i++) {

        if (fStdOut)         System.out.println("\n\nTest[" + i + "]");

        if (fStdOut)         System.out.println("\nBefore " + arg + ": document="+ tests[i]+ ":");

        parser.parse(new InputSource(new StringReader(tests[i])));

        DocumentImpl document=(DocumentImpl)parser.getDocument();

        Range range=document.createRange();

        Node root=document.getDocumentElement();

        boolean surround=false;

        Node surroundNode=document.createElement(SURROUND);

        if (arg.equals("surround")) {

          surround=true;

        }

        if (i == 0) {

          range.setStart(root.getFirstChild(),1);

          range.setEndBefore(root.getLastChild());

          if (surround)           range.setEnd(root.getLastChild(),1);

        }

 else         if (i == 1) {

          Node n1=root.getFirstChild().getNextSibling().getFirstChild();

          range.setStart(n1,1);

          range.setEnd(root.getLastChild(),1);

          if (surround)           range.setEnd(n1,2);

        }

 else         if (i == 2) {

          range.setStart(root.getFirstChild(),1);

          Node n2=root.getFirstChild().getNextSibling().getFirstChild();

          range.setEnd(n2,1);

          if (surround)           range.setEndBefore(root.getLastChild());

        }

 else         if (i == 3) {

          Node n3=root.getFirstChild().getFirstChild();

          range.setStart(n3,1);

          range.setEnd(root.getLastChild().getFirstChild(),1);

          if (surround) {

            range.selectNode(root.getFirstChild().getNextSibling());

          }

        }

 else         if (i == 4) {

          Node n4=root.getFirstChild().getFirstChild().getNextSibling().getFirstChild();

          range.setStartAfter(n4);

          range.setEndAfter(root.getLastChild().getFirstChild());

          if (surround) {

            range.selectNodeContents(root.getFirstChild().getNextSibling());

          }

        }

        if (fStdOut)         System.out.println("range.toString=" + range.toString());

        DocumentFragment frag=null;

        if (arg.equals("surround")) {

          try {

            if (fStdOut)             System.out.println("surroundNode=" + surroundNode);

            range.surroundContents(surroundNode);

          }

 catch (          org.w3c.dom.ranges.RangeException e) {

            if (fStdOut)             System.out.println(e);

          }

          String result=toString(document);

          if (fStdOut)           System.out.println("After surround: document=" + result + ":");

          if (!result.equals(surroundResult[i])) {

            if (fStdOut)             System.out.println("Should be: document=" + surroundResult[i] + ":");

            passed=false;

            if (fStdOut)             System.out.println("Test FAILED!");

            if (fStdOut)             System.out.println("*** Surround document Test[" + i + "] FAILED!");

          }

        }

        if (arg.equals("insert")) {

          range.insertNode(document.createTextNode(INSERT));

          String result=toString(document);

          if (fStdOut)           System.out.println("After  insert: document=" + result + ":");

          if (!result.equals(insertResult[i])) {

            if (fStdOut)             System.out.println("Should be: document=" + insertResult[i] + ":");

            passed=false;

            if (fStdOut)             System.out.println("Test FAILED!");

            if (fStdOut)             System.out.println("*** Insert document Test[" + i + "] FAILED!");

          }

        }

 else         if (arg.equals("delete")) {

          range.deleteContents();

          String result=toString(document);

          if (fStdOut)           System.out.println("After delete:" + result + ":");

          if (!result.equals(deleteResult[i])) {

            if (fStdOut)             System.out.println("Should be: document=" + deleteResult[i] + ":");

            passed=false;

            if (fStdOut)             System.out.println("Test FAILED!");

            if (fStdOut)             System.out.println("*** Delete document Test[" + i + "] FAILED!");

          }

        }

 else         if (arg.equals("extract")) {

          frag=range.extractContents();

          String result=toString(document);

          if (fStdOut)           System.out.println("After extract: document=" + result + ":");

          if (!result.equals(deleteResult[i])) {

            if (fStdOut)             System.out.println("Should be: document=" + deleteResult[i] + ":");

            passed=false;

            if (fStdOut)             System.out.println("*** Extract document Test[" + i + "] FAILED!");

          }

          String fragResult=toString(frag);

          if (fStdOut)           System.out.println("After extract: fragment=" + fragResult + ":");

          if (!fragResult.equals(extractResult[i])) {

            if (fStdOut)             System.out.println("Should be: fragment=" + extractResult[i] + ":");

            passed=false;

            if (fStdOut)             System.out.println("*** Extract Fragment Test[" + i + "] FAILED!");

          }

        }

 else         if (arg.equals("clone")) {

          frag=range.cloneContents();

          String fragResult=toString(frag);

          if (fStdOut)           System.out.println("After clone: fragment=" + fragResult);

          if (!fragResult.equals(extractResult[i])) {

            if (fStdOut)             System.out.println("Should be: fragment=" + extractResult[i] + ":");

            passed=false;

            if (fStdOut)             System.out.println("*** Clone Fragment Test[" + i + "] FAILED!");

          }

        }

      }

    }

 else     if (arg.equals("insert2")) {

      if (fStdOut)       System.out.println("\n*************** Test == " + arg + " ***************");

      for (int i=0; i < 4; i++) {

        if (fStdOut)         System.out.println("\n\nTest[" + i + "]");

        if (fStdOut)         System.out.println("\nBefore " + arg + ": document="+ INSERT2+ ":");

        parser.parse(new InputSource(new StringReader(INSERT2)));

        DocumentImpl document=(DocumentImpl)parser.getDocument();

        Node root=document.getDocumentElement();

        Range range=document.createRange();

        range.setStart(root.getFirstChild(),11);

        range.setEnd(root.getFirstChild(),18);

        Range rangei=document.createRange();

        if (i == 0) {

          rangei.setStart(root.getFirstChild(),10);

          rangei.setEnd(root.getFirstChild(),10);

        }

        if (i == 1) {

          rangei.setStart(root.getFirstChild(),11);

          rangei.setEnd(root.getFirstChild(),11);

        }

        if (i == 2) {

          rangei.setStart(root.getFirstChild(),12);

          rangei.setEnd(root.getFirstChild(),12);

        }

        if (i == 3) {

          rangei.setStart(root.getFirstChild(),17);

          rangei.setEnd(root.getFirstChild(),17);

        }

        if (DEBUG)         if (fStdOut)         System.out.println("before insert start=" + range.getStartOffset());

        if (DEBUG)         if (fStdOut)         System.out.println("before insert end=" + range.getEndOffset());

        rangei.insertNode(document.createTextNode(INSERTED_TEXT));

        if (DEBUG)         if (fStdOut)         System.out.println("after insert start=" + range.getStartOffset());

        if (DEBUG)         if (fStdOut)         System.out.println("after insert end=" + range.getEndOffset());

        String result=toString(document);

        if (fStdOut)         System.out.println("After insert2: document=" + result + ":");

        if (!result.equals(rangeInsertResult[i])) {

          if (fStdOut)           System.out.println("Should be: document=" + rangeInsertResult[i] + ":");

          passed=false;

          if (fStdOut)           System.out.println("Test FAILED!");

          if (fStdOut)           System.out.println("*** Delete Ranges document Test[" + i + "] FAILED!");

        }

      }

    }

 else     if (arg.equals("delete2")) {

      if (fStdOut)       System.out.println("\n*************** Test == " + arg + " ***************");

      for (int i=0; i < rangeDelete.length; i++) {

        if (fStdOut)         System.out.println("\n\nTest[" + i + "]");

        if (fStdOut)         System.out.println("\nBefore " + arg + ": document="+ rangeDelete[i]+ ":");

        parser.parse(new InputSource(new StringReader(rangeDelete[i])));

        DocumentImpl document=(DocumentImpl)parser.getDocument();

        Range range=document.createRange();

        Range ranged=document.createRange();

        Node root=document.getDocumentElement();

        boolean surround=false;

        Node surroundNode=document.createElement(SURROUND);

        if (arg.equals("surround")) {

          surround=true;

        }

        if (i == 0) {

          ranged.setStart(root.getFirstChild(),5);

          ranged.setEnd(root.getFirstChild(),14);

          range.setStart(root.getFirstChild(),11);

          range.setEnd(root.getFirstChild(),19);

        }

 else         if (i == 1) {

          ranged.setStart(root.getFirstChild(),5);

          ranged.setEnd(root.getFirstChild(),22);

          range.setStart(root.getFirstChild(),11);

          range.setEnd(root.getFirstChild(),21);

        }

 else         if (i == 2) {

          ranged.setStart(root.getFirstChild(),5);

          ranged.setEnd(root.getFirstChild().getNextSibling().getFirstChild(),1);

          range.setStart(root.getFirstChild(),11);

          range.setEndAfter(root.getFirstChild().getNextSibling().getFirstChild());

        }

 else         if (i == 3) {

          ranged.setStart(root.getFirstChild(),5);

          ranged.setEnd(root.getFirstChild(),11);

          range.setStart(root.getFirstChild(),11);

          range.setEnd(root.getFirstChild(),21);

        }

 else         if (i == 4) {

          ranged.selectNode(root.getFirstChild().getNextSibling());

          range.setStart(root.getFirstChild().getNextSibling().getFirstChild(),6);

          range.setEnd(root.getFirstChild().getNextSibling().getFirstChild(),15);

        }

        DocumentFragment frag=null;

        if (arg.equals("delete2")) {

          if (DEBUG) {

            if (fStdOut)             System.out.println("BEFORE deleteContents()");

            if (fStdOut)             System.out.println("ranged: startc=" + ranged.getStartContainer());

            if (fStdOut)             System.out.println("ranged: starto=" + ranged.getStartOffset());

            if (fStdOut)             System.out.println("ranged:   endc=" + ranged.getEndContainer());

            if (fStdOut)             System.out.println("ranged:   endo=" + ranged.getEndOffset());

            if (fStdOut)             System.out.println("range: startc=" + range.getStartContainer());

            if (fStdOut)             System.out.println("range: starto=" + range.getStartOffset());

            if (fStdOut)             System.out.println("range:   endc=" + range.getEndContainer());

            if (fStdOut)             System.out.println("range:   endo=" + range.getEndOffset());

          }

          ranged.deleteContents();

          String result=null;

          if (DEBUG) {

            if (fStdOut)             System.out.println("AFTER deleteContents()");

            result=toString(document);

            if (fStdOut)             System.out.println("ranged: startc=" + ranged.getStartContainer());

            if (fStdOut)             System.out.println("ranged: starto=" + ranged.getStartOffset());

            if (fStdOut)             System.out.println("ranged:   endc=" + ranged.getEndContainer());

            if (fStdOut)             System.out.println("ranged:   endo=" + ranged.getEndOffset());

            if (fStdOut)             System.out.println("range: startc=" + range.getStartContainer());

            if (fStdOut)             System.out.println("range: starto=" + range.getStartOffset());

            if (fStdOut)             System.out.println("range:   endc=" + range.getEndContainer());

            if (fStdOut)             System.out.println("range:   endo=" + range.getEndOffset());

          }

          ranged.insertNode(document.createTextNode("^"));

          result=toString(document);

          if (fStdOut)           System.out.println("After delete2: document=" + result + ":");

          if (!result.equals(rangeDeleteResult[i])) {

            if (fStdOut)             System.out.println("Should be: document=" + rangeDeleteResult[i] + ":");

            passed=false;

            if (fStdOut)             System.out.println("Test FAILED!");

            if (fStdOut)             System.out.println("*** Delete Ranges document Test[" + i + "] FAILED!");

          }

        }

      }

    }

  }

 catch (  org.xml.sax.SAXParseException spe) {

    passed=false;

  }

catch (  org.xml.sax.SAXException se) {

    if (se.getException() != null)     se.getException().printStackTrace(System.err);

 else     se.printStackTrace(System.err);

    passed=false;

  }

catch (  Exception e) {

    e.printStackTrace(System.err);

    passed=false;

  }

  if (!passed)   if (fStdOut)   System.out.println("*** The " + arg + " Test FAILED! ***");

  return passed;

}

Location: Test.java

Content: 

private void printDetailsMessage(){

  if (fLogStream != DEFAULT_LOG_STREAM) {

    System.err.println("See log output for details");

  }

 else {

    System.err.println("Re-run with -f option to get details.");

  }

}

Location: Test.java

Content: 

protected void printError(String type,SAXParseException ex){

  System.err.print("[");

  System.err.print(type);

  System.err.print("] ");

  if (ex == null) {

    System.out.println("!!!");

  }

  String systemId=ex.getSystemId();

  if (systemId != null) {

    int index=systemId.lastIndexOf('/');

    if (index != -1)     systemId=systemId.substring(index + 1);

    System.err.print(systemId);

  }

  System.err.print(':');

  System.err.print(ex.getLineNumber());

  System.err.print(':');

  System.err.print(ex.getColumnNumber());

  System.err.print(": ");

  System.err.print(ex.getMessage());

  System.err.println();

  System.err.flush();

}

Location: Test.java

Content: 

/** 

 * Prints the error message. 

 */

protected void printError(String type,XMLParseException ex){

  fOutputWriter.print("[");

  fOutputWriter.print(type);

  fOutputWriter.print("] ");

  String systemId=ex.getExpandedSystemId();

  if (systemId != null) {

    int index=systemId.lastIndexOf('/');

    if (index != -1)     systemId=systemId.substring(index + 1);

    fOutputWriter.print(systemId);

  }

  fOutputWriter.print(':');

  fOutputWriter.print(ex.getLineNumber());

  fOutputWriter.print(':');

  fOutputWriter.print(ex.getColumnNumber());

  fOutputWriter.println();

  fOutputWriter.flush();

}

Location: Test.java

Content: 

private static void printUsage(){

  System.out.println("java xinclude.Test [OPTIONS] [TESTS]");

  System.out.println("OPTIONS:");

  System.out.println("  -f [file] :      Specifies a log file to print detailed error messages to.");

  System.out.println("                   Omitting the FILE parameter makes messages print to ");

  System.out.println("                   standard error. If this option is absent, the messages");

  System.out.println("                   will not be output.");

  System.out.println("");

  System.out.println("  -g [directory] : Generates the expected output files in the ");

  System.out.println("                   given directory if specified, otherwise the files");

  System.out.println("                   are written to the expected output directory.");

  System.out.println("                   Only use this option without a target when the output ");

  System.out.println("                   is sure to be correct. The previous expected output files ");

  System.out.println("                   will be overwritten.");

  System.out.println("");

  System.out.println("  -h :             Prints this help message and exits.");

  System.out.println("TESTS:");

  System.out.println("  A whitespace separated list of tests to run, specified by test number.");

  System.out.println("  If this is absent, all tests will be run.");

}

Location: Test.java

Content: 

/** 

 * Prints the specified node, recursively. 

 */

public String print(Node node){

  if (node == null) {

    return sb.toString();

  }

  int type=node.getNodeType();

switch (type) {

case Node.DOCUMENT_NODE:

{

      return print(((Document)node).getDocumentElement());

    }

case Node.ELEMENT_NODE:

{

    sb.append('<');

    sb.append(node.getNodeName());

    Attr attrs[]=sortAttributes(node.getAttributes());

    for (int i=0; i < attrs.length; i++) {

      Attr attr=attrs[i];

      sb.append(' ');

      sb.append(attr.getNodeName());

      sb.append("=\"");

      sb.append(normalize(attr.getNodeValue()));

      sb.append('"');

    }

    sb.append('>');

    NodeList children=node.getChildNodes();

    if (children != null) {

      int len=children.getLength();

      for (int i=0; i < len; i++) {

        print(children.item(i));

      }

    }

    break;

  }

case Node.ENTITY_REFERENCE_NODE:

{

  if (canonical) {

    NodeList children=node.getChildNodes();

    if (children != null) {

      int len=children.getLength();

      for (int i=0; i < len; i++) {

        print(children.item(i));

      }

    }

  }

 else {

    sb.append('&');

    sb.append(node.getNodeName());

    sb.append(';');

  }

  break;

}

case Node.CDATA_SECTION_NODE:

{

if (canonical) {

  sb.append(normalize(node.getNodeValue()));

}

 else {

  sb.append("<![CDATA[");

  sb.append(node.getNodeValue());

  sb.append("]]>");

}

break;

}

case Node.TEXT_NODE:

{

sb.append(normalize(node.getNodeValue()));

break;

}

case Node.PROCESSING_INSTRUCTION_NODE:

{

sb.append("<?");

sb.append(node.getNodeName());

String data=node.getNodeValue();

if (data != null && data.length() > 0) {

sb.append(' ');

sb.append(data);

}

sb.append("?>");

break;

}

case Node.DOCUMENT_FRAGMENT_NODE:

{

NodeList children=node.getChildNodes();

if (children != null) {

int len=children.getLength();

for (int i=0; i < len; i++) {

print(children.item(i));

}

}

break;

}

}

if (type == Node.ELEMENT_NODE) {

sb.append("</");

sb.append(node.getNodeName());

sb.append('>');

}

return sb.toString();

}

Location: Test.java

Content: 

private boolean processTestResults(boolean passed,boolean expectedPass,String outputFilename,String expectedOutputFile){

  if (fGenerate) {

    try {

      fLogStream.println("Generated: " + outputFilename);

      PrintWriter outputFile=new PrintWriter(new FileWriter(outputFilename));

      outputFile.print(fResults);

      outputFile.close();

    }

 catch (    IOException e) {

      fLogStream.println("IOException generating results: " + e.getMessage());

      return false;

    }

    return true;

  }

  try {

    if (passed == expectedPass) {

      if (compareOutput(new FileReader(expectedOutputFile),new StringReader(fResults))) {

        fLogStream.println("Result: PASS");

        return true;

      }

 else {

        fLogStream.println("Result: FAIL");

        return false;

      }

    }

 else {

      compareOutput(new FileReader(expectedOutputFile),new StringReader(fResults));

      fLogStream.println(fResults);

      fLogStream.println("Result: FAIL");

      return false;

    }

  }

 catch (  IOException e) {

    fLogStream.println("Unexpected IO problem attempting to verify results: " + e);

    fLogStream.println("Result: FAIL");

    return false;

  }

}

Location: Test.java

Content: 

void ReadFilesIntoMemory(){

  int fileNum;

  InputStreamReader fileF;

  char chars[]=new char[1024];

  StringBuffer buf=new StringBuffer();

  if (gRunInfo.inMemory) {

    for (fileNum=0; fileNum < gRunInfo.numInputFiles; fileNum++) {

      InFileInfo fInfo=gRunInfo.files[fileNum];

      buf.setLength(0);

      try {

        FileInputStream in=new FileInputStream(fInfo.fileName);

        fileF=new InputStreamReader(in);

        int len=0;

        while ((len=fileF.read(chars,0,chars.length)) > 0) {

          buf.append(chars,0,len);

        }

        fInfo.fileContent=buf.toString();

        fileF.close();

      }

 catch (      FileNotFoundException e) {

        System.err.print("File not found: \"" + fInfo.fileName + "\".");

        System.exit(-1);

      }

catch (      IOException e) {

        System.err.println("Error reading file \"" + fInfo.fileName + "\".");

        System.exit(-1);

      }

    }

  }

}

Location: Test.java

Content: 

void reportAllMutations(Node n){

  String[] evtNames={"DOMSubtreeModified","DOMAttrModified","DOMCharacterDataModified","DOMNodeInserted","DOMNodeRemoved","DOMNodeInsertedIntoDocument","DOMNodeRemovedFromDocument"};

  EventTarget t=(EventTarget)n;

  for (int i=evtNames.length - 1; i >= 0; --i) {

    t.addEventListener(evtNames[i],sharedReporter,true);

    t.addEventListener(evtNames[i],sharedReporter,false);

  }

}

Location: Test.java

Content: 

void resetHandlerData(){

  lastOperation=-1;

  lastKey=null;

  lastData=null;

  lastSource=null;

  lastDestination=null;

}

Location: Test.java

Content: 

/** 

 * @see org.w3c.dom.ls.DOMEntityResolver#resolveEntity(String,String,String,String,String)

 */

public LSInput resolveResource(String type,String namespace,String publicId,String systemId,String baseURI){

  try {

    DOMImplementationLS impl=(DOMImplementationLS)DOMImplementationRegistry.newInstance().getDOMImplementation("LS");

    LSInput source=impl.createLSInput();

    if (systemId.equals("personal.xsd")) {

      source.setSystemId("data/personal.xsd");

    }

 else {

      source.setSystemId("data/personal.dtd");

    }

    return source;

  }

 catch (  Exception e) {

    return null;

  }

}

Location: Test.java

Content: 

void runTest(){

  Document doc=new org.apache.xerces.dom.DocumentImpl();

  reportAllMutations(doc);

  Element root=addNoisyElement(doc,doc,0);

  Element e=null;

  int i;

  e=addNoisyElement(doc,root,0);

  Attr a=addNoisyAttr(doc,e,0);

  a.setNodeValue("Updated A0 of E0, prepare to be acidulated.");

  NamedNodeMap nnm=e.getAttributes();

  nnm.removeNamedItem(a.getName());

  nnm.setNamedItem(a);

  System.out.println();

  System.out.println("Add/remove a preconstructed tree; tests AddedToDocument");

  System.out.println();

  sharedReporter.off();

  Element lateAdd=doc.createElement("lateAdd");

  reportAllMutations(lateAdd);

  e=lateAdd;

  for (i=0; i < 2; ++i) {

    e=addNoisyElement(doc,e,i);

    addNoisyAttr(doc,e,i);

  }

  sharedReporter.on();

  root.appendChild(lateAdd);

  root.removeChild(lateAdd);

  System.out.println();

  System.out.println("Replace a preconstructed tree; tests AddedToDocument");

  System.out.println();

  sharedReporter.off();

  Node e0=root.replaceChild(lateAdd,root.getFirstChild());

  sharedReporter.on();

  root.replaceChild(e0,lateAdd);

  sharedReporter.off();

  Text t=addNoisyText(doc,root.getFirstChild(),"fo");

  sharedReporter.on();

  t.insertData(1,"o");

  root.setAttribute("foo","bar");

  System.out.println("Done");

}

Location: Test.java

Content: 

public void runTests(){

  int totalFailures=0;

  for (int i=0; i < fNumTests; i++) {

    if (!runTest(fTests[i])) {

      totalFailures++;

    }

  }

  if (fLogStream != null && fLogStream != System.err) {

    fLogStream.close();

  }

  if (totalFailures == 0) {

    System.out.println("All XInclude Tests Passed");

  }

 else {

    System.err.println("Total failures for XInclude: " + totalFailures + "/"+ fNumTests);

    printDetailsMessage();

    System.exit(1);

  }

}

Location: Test.java

Content: 

private boolean runTest(int testnum){

  String testname="tests/xinclude/tests/test";

  String outputFilename=fOutputDirectory + "/test";

  String expectedOutputFilename="tests/xinclude/output/test";

  if (testnum < 10) {

    testname+="0" + testnum;

    outputFilename+="0" + testnum;

    expectedOutputFilename+="0" + testnum;

  }

 else {

    testname+=testnum;

    outputFilename+=testnum;

    expectedOutputFilename+=testnum;

  }

  testname+=XML_EXTENSION;

  if (TEST_RESULTS[testnum - 1]) {

    outputFilename+=XML_EXTENSION;

    expectedOutputFilename+=XML_EXTENSION;

  }

 else {

    outputFilename+=TXT_EXTENSION;

    expectedOutputFilename+=TXT_EXTENSION;

  }

  boolean passed=true;

  StringBuffer buffer=null;

  try {

    fLogStream.println("TEST: " + testname);

    java.io.Writer myWriter=new StringWriter();

    buffer=((StringWriter)myWriter).getBuffer();

    fOutputWriter=new PrintWriter(myWriter);

    fWriter.setOutput(myWriter);

    fWriter.parse(new XMLInputSource(null,testname,null));

  }

 catch (  XNIException e) {

    passed=false;

  }

catch (  IOException e) {

    fLogStream.println("Unexpected IO problem: " + e);

    fLogStream.println("Result: FAIL");

    return false;

  }

  fResults=stripUserDir(buffer);

  return processTestResults(passed,TEST_RESULTS[testnum - 1],outputFilename,expectedOutputFilename);

}

Location: Test.java

Content: 

void run(String argv[]){

  parseCommandLine(argv);

  ReadFilesIntoMemory();

  ThreadParser mainParser=new ThreadParser();

  int n;

  boolean errors=false;

  int cksum;

  for (n=0; n < gRunInfo.numInputFiles; n++) {

    String fileName=gRunInfo.files[n].fileName;

    if (gRunInfo.verbose)     System.out.print(fileName + " checksum is ");

    cksum=mainParser.parse(n);

    if (cksum == 0) {

      System.err.println("An error occured while initially parsing" + fileName);

      errors=true;

    }

    gRunInfo.files[n].checkSum=cksum;

    if (gRunInfo.verbose)     System.out.println(cksum);

    if (gRunInfo.dumpOnErr && errors)     mainParser.domPrint();

  }

  if (errors)   System.exit(1);

  if (gRunInfo.numThreads == 0)   return;

  gThreadInfo=new ThreadInfo[gRunInfo.numThreads];

  int threadNum;

  for (threadNum=0; threadNum < gRunInfo.numThreads; threadNum++) {

    gThreadInfo[threadNum]=new ThreadInfo();

    gThreadInfo[threadNum].fThreadNum=threadNum;

    thread t=new thread(gThreadInfo[threadNum]);

    t.start();

  }

  long startTime=System.currentTimeMillis();

  long elapsedSeconds=0;

  while (gRunInfo.totalTime == 0 || gRunInfo.totalTime > elapsedSeconds) {

    try {

      Thread.sleep(1000);

    }

 catch (    InterruptedException e) {

    }

    if (gRunInfo.quiet == false && gRunInfo.verbose == false) {

      char c='+';

      for (threadNum=0; threadNum < gRunInfo.numThreads; threadNum++) {

        if (gThreadInfo[threadNum].fHeartBeat == false) {

          c='.';

          break;

        }

      }

      System.out.print(c);

      System.out.flush();

      if (c == '+')       for (threadNum=0; threadNum < gRunInfo.numThreads; threadNum++)       gThreadInfo[threadNum].fHeartBeat=false;

    }

    elapsedSeconds=(System.currentTimeMillis() - startTime) / 1000;

  }

  ;

  double totalParsesCompleted=0;

  for (threadNum=0; threadNum < gRunInfo.numThreads; threadNum++) {

    totalParsesCompleted+=gThreadInfo[threadNum].fParses;

  }

  double parsesPerMinute=totalParsesCompleted / (((double)gRunInfo.totalTime) / ((double)60));

  System.out.println("\n" + parsesPerMinute + " parses per minute.");

  System.exit(0);

}

Location: Test.java

Content: 

public static void serialize(Document document,String filename) throws Exception {

  System.out.println("Serializing parsed document");

  ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(filename));

  out.writeObject(document);

  out.close();

}

Location: Test.java

Content: 

public void setLogFile(PrintStream stream){

  fLogStream=stream;

}

Location: Test.java

Content: 

/** 

 * Returns a sorted list of attributes. 

 */

protected Attr[] sortAttributes(NamedNodeMap attrs){

  int len=(attrs != null) ? attrs.getLength() : 0;

  Attr array[]=new Attr[len];

  for (int i=0; i < len; i++) {

    array[i]=(Attr)attrs.item(i);

  }

  for (int i=0; i < len - 1; i++) {

    String name=array[i].getNodeName();

    int index=i;

    for (int j=i + 1; j < len; j++) {

      String curName=array[j].getNodeName();

      if (curName.compareTo(name) < 0) {

        name=curName;

        index=j;

      }

    }

    if (index != i) {

      Attr temp=array[i];

      array[i]=array[index];

      array[index]=temp;

    }

  }

  return (array);

}

Location: Test.java

Content: 

private String stripUserDir(StringBuffer buf){

  String userDir=System.getProperty("user.dir");

  String userURI="file://";

  if (userDir.charAt(0) != '/') {

    userURI+="/";

  }

  userURI+=userDir.replace('\\','/');

  String str=getPathWithoutEscapes(buf.toString());

  int start=0, end=0;

  while ((start=str.indexOf(userURI,start)) != -1) {

    end=start + userURI.length();

    str=str.substring(0,start) + str.substring(end + 1);

  }

  while ((start=str.indexOf(userDir,start)) != -1) {

    end=start + userDir.length();

    str=str.substring(0,start) + str.substring(end + 1);

  }

  return str;

}

Location: Test.java

Content: 

public Test() throws XNIException {

  XMLParserConfiguration parserConfig=new XIncludeParserConfiguration();

  parserConfig.setFeature(NAMESPACES_FEATURE_ID,true);

  parserConfig.setFeature(SCHEMA_VALIDATION_FEATURE_ID,true);

  parserConfig.setFeature(SCHEMA_FULL_CHECKING_FEATURE_ID,true);

  fWriter=new Writer(parserConfig);

  parserConfig.setProperty(ERROR_HANDLER,this);

  fGenerate=false;

  fLogStream=DEFAULT_LOG_STREAM;

}

Location: Test.java

Content: 

public void testSettingNoNamespaceSchemaLocation() throws Exception {

  System.err.println("#");

  System.err.println("# Testing Setting noNamespaceSchemaLocation property");

  System.err.println("#");

  try {

    SAXParser parser=new org.apache.xerces.parsers.SAXParser();

    parser.setFeature(NAMESPACES_FEATURE_ID,true);

    parser.setFeature(NAMESPACE_PREFIXES_FEATURE_ID,false);

    parser.setFeature(VALIDATION_FEATURE_ID,true);

    parser.setFeature(SCHEMA_VALIDATION_FEATURE_ID,true);

    parser.setFeature(SCHEMA_FULL_CHECKING_FEATURE_ID,false);

    parser.setFeature(DYNAMIC_VALIDATION_FEATURE_ID,false);

    parser.setProperty(SCHEMA_NONS_LOCATION_ID,"personal.xsd");

    parser.setContentHandler(this);

    parser.setErrorHandler(this);

    parser.parse(SOURCE_LOC_ID + "personal-schema.xml");

    System.err.println("Pass: " + SOURCE_LOC_ID + "personal-schema.xml");

    System.err.println();

  }

 catch (  SAXException e) {

    System.err.println("Fail:" + e.getMessage());

  }

}

Location: Test.java

Content: 

/** 

 * Performs the actual test. 

 */

public void test(Document doc){

  System.out.println("DOM rename Test...");

  NodeList elements=doc.getElementsByTagName("email");

  Element child=(Element)elements.item(0);

  Assertion.verify(child != null);

  Assertion.equals(child.getNodeName(),"email");

  Attr at=child.getAttributeNode("defaultEmailAttr");

  Assertion.verify(at != null);

  Assertion.equals(at.getValue(),"defaultEmailValue");

  Assertion.verify(at.getSpecified() == false);

  child.setUserData("mydata","yo",this);

  Assertion.equals((String)child.getUserData("mydata"),"yo");

  Element newChild=(Element)doc.renameNode(child,null,"url");

  Assertion.equals(newChild.getNodeName(),"url");

  Assertion.verify(newChild.getNamespaceURI() == null);

  Assertion.verify(newChild.hasAttribute("defaultEmailAttr") == false);

  Assertion.verify(at.getSpecified() == true);

  at=newChild.getAttributeNode("defaultUrlAttr");

  Assertion.verify(at != null);

  Assertion.equals(at.getValue(),"defaultUrlValue");

  Assertion.verify(at.getSpecified() == false);

  Assertion.equals((String)newChild.getUserData("mydata"),"yo");

  if (newChild != child) {

    Assertion.verify(lastOperation == UserDataHandler.NODE_RENAMED);

    Assertion.verify(lastKey == "mydata");

    Assertion.equals((String)lastData,"yo");

    Assertion.verify(lastSource == child);

    Assertion.verify(lastDestination == newChild);

    resetHandlerData();

  }

  Element newChild2=(Element)doc.renameNode(newChild,"ns1","foo");

  Assertion.equals(newChild2.getNodeName(),"foo");

  Assertion.equals(newChild2.getNamespaceURI(),"ns1");

  Assertion.verify(newChild2.hasAttribute("defaultUrlAttr") == false);

  Assertion.equals((String)newChild2.getUserData("mydata"),"yo");

  if (newChild2 != newChild) {

    Assertion.verify(lastOperation == UserDataHandler.NODE_RENAMED);

    Assertion.verify(lastKey == "mydata");

    Assertion.equals((String)lastData,"yo");

    Assertion.verify(lastSource == newChild);

    Assertion.verify(lastDestination == newChild2);

    resetHandlerData();

  }

  child=(Element)elements.item(1);

  Assertion.verify(child != null);

  Assertion.equals(child.getNodeName(),"email");

  at=child.getAttributeNode("defaultEmailAttr");

  Assertion.verify(at != null);

  Assertion.equals(at.getValue(),"defaultEmailValue");

  Assertion.verify(at.getSpecified() == false);

  at.setUserData("mydata","yo",this);

  Assertion.equals((String)at.getUserData("mydata"),"yo");

  Attr newAt=(Attr)doc.renameNode(at,null,"foo");

  Assertion.verify(newAt != null);

  Assertion.equals(newAt.getNodeName(),"foo");

  Assertion.equals(newAt.getNamespaceURI(),null);

  Assertion.equals(newAt.getValue(),"defaultEmailValue");

  Assertion.verify(newAt.getSpecified() == true);

  Assertion.verify(child.hasAttribute("foo") == true);

  Assertion.verify(child.hasAttribute("defaultEmailAttr") == true);

  Assertion.equals((String)newAt.getUserData("mydata"),"yo");

  if (newAt != at) {

    Assertion.verify(lastOperation == UserDataHandler.NODE_RENAMED);

    Assertion.verify(lastKey == "mydata");

    Assertion.equals((String)lastData,"yo");

    Assertion.verify(lastSource == at);

    Assertion.verify(lastDestination == newAt);

    resetHandlerData();

  }

  Attr newAt2=(Attr)doc.renameNode(newAt,"ns1","bar");

  Assertion.verify(newAt2 != null);

  Assertion.equals(newAt2.getNodeName(),"bar");

  Assertion.equals(newAt2.getNamespaceURI(),"ns1");

  Assertion.equals(newAt2.getValue(),"defaultEmailValue");

  Assertion.verify(newAt2.getSpecified() == true);

  Assertion.verify(child.hasAttributeNS("ns1","bar") == true);

  Assertion.equals((String)newAt2.getUserData("mydata"),"yo");

  if (newAt2 != newAt) {

    Assertion.verify(lastOperation == UserDataHandler.NODE_RENAMED);

    Assertion.verify(lastKey == "mydata");

    Assertion.equals((String)lastData,"yo");

    Assertion.verify(lastSource == newAt);

    Assertion.verify(lastDestination == newAt2);

    resetHandlerData();

  }

  System.out.println("done.");

}

Location: Test.java

Content: 

public Test(String arg){

  if (arg.equals("all")) {

    boolean all=false;

    all=performTest("delete");

    all=performTest("extract") && all;

    all=performTest("clone") && all;

    all=performTest("insert") && all;

    all=performTest("surround") && all;

    all=performTest("insert2") && all;

    all=performTest("delete2") && all;

    if (all) {

      System.out.println("Done.");

    }

 else {

      System.out.println("*** ONE OR MORE TESTS FAILED! ***");

      System.exit(1);

    }

  }

 else {

    performTest(arg);

  }

}

Location: Test.java

Content: 

String toString(Node node){

  sb=new StringBuffer();

  return print(node);

}

Location: Test.java

Content: 

public void warning(String domain,String key,XMLParseException exception) throws XNIException {

  printError("Warning",exception);

}

