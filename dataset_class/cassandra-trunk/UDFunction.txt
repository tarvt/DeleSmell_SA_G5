Location: UDFunction.java

Content: 

public List<ColumnIdentifier> argNames(){

  return argNames;

}

Location: UDFunction.java

Content: 

public static void assertUdfsEnabled(String language){

  if (!DatabaseDescriptor.enableUserDefinedFunctions())   throw new InvalidRequestException("User-defined functions are disabled in cassandra.yaml - set enable_user_defined_functions=true to enable");

  if (!"java".equalsIgnoreCase(language) && !DatabaseDescriptor.enableScriptedUserDefinedFunctions())   throw new InvalidRequestException("Scripted user-defined functions are disabled in cassandra.yaml - set enable_scripted_user_defined_functions=true to enable if you are aware of the security risks");

}

Location: UDFunction.java

Content: 

private <T>T async(ThreadIdAndCpuTime threadIdAndCpuTime,Callable<T> callable){

  Future<T> future=executor().submit(callable);

  try {

    if (DatabaseDescriptor.getUserDefinedFunctionWarnTimeout() > 0)     try {

      return future.get(DatabaseDescriptor.getUserDefinedFunctionWarnTimeout(),TimeUnit.MILLISECONDS);

    }

 catch (    TimeoutException e) {

      String warn=String.format("User defined function %s ran longer than %dms",this,DatabaseDescriptor.getUserDefinedFunctionWarnTimeout());

      logger.warn(warn);

      ClientWarn.instance.warn(warn);

    }

    return future.get(DatabaseDescriptor.getUserDefinedFunctionFailTimeout() - DatabaseDescriptor.getUserDefinedFunctionWarnTimeout(),TimeUnit.MILLISECONDS);

  }

 catch (  InterruptedException e) {

    Thread.currentThread().interrupt();

    throw new RuntimeException(e);

  }

catch (  ExecutionException e) {

    Throwable c=e.getCause();

    if (c instanceof RuntimeException)     throw (RuntimeException)c;

    throw new RuntimeException(c);

  }

catch (  TimeoutException e) {

    try {

      threadIdAndCpuTime.get(1,TimeUnit.SECONDS);

      long cpuTimeMillis=threadMXBean.getThreadCpuTime(threadIdAndCpuTime.threadId) - threadIdAndCpuTime.cpuTime;

      cpuTimeMillis/=1000000L;

      return future.get(Math.max(DatabaseDescriptor.getUserDefinedFunctionFailTimeout() - cpuTimeMillis,0L),TimeUnit.MILLISECONDS);

    }

 catch (    InterruptedException e1) {

      Thread.currentThread().interrupt();

      throw new RuntimeException(e);

    }

catch (    ExecutionException e1) {

      Throwable c=e.getCause();

      if (c instanceof RuntimeException)       throw (RuntimeException)c;

      throw new RuntimeException(c);

    }

catch (    TimeoutException e1) {

      TimeoutException cause=new TimeoutException(String.format("User defined function %s ran longer than %dms%s",this,DatabaseDescriptor.getUserDefinedFunctionFailTimeout(),DatabaseDescriptor.getUserFunctionTimeoutPolicy() == Config.UserFunctionTimeoutPolicy.ignore ? "" : " - will stop Cassandra VM"));

      FunctionExecutionException fe=FunctionExecutionException.create(this,cause);

      JVMStabilityInspector.userFunctionTimeout(cause);

      throw fe;

    }

  }

}

Location: UDFunction.java

Content: 

public String body(){

  return body;

}

Location: UDFunction.java

Content: 

@Override public Optional<Difference> compare(Function function){

  if (!(function instanceof UDFunction))   throw new IllegalArgumentException();

  UDFunction other=(UDFunction)function;

  if (!equalsWithoutTypes(other))   return Optional.of(Difference.SHALLOW);

  boolean typesDifferDeeply=false;

  if (!returnType.equals(other.returnType)) {

    if (returnType.asCQL3Type().toString().equals(other.returnType.asCQL3Type().toString()))     typesDifferDeeply=true;

 else     return Optional.of(Difference.SHALLOW);

  }

  for (int i=0; i < argTypes().size(); i++) {

    AbstractType<?> thisType=argTypes.get(i);

    AbstractType<?> thatType=other.argTypes.get(i);

    if (!thisType.equals(thatType)) {

      if (thisType.asCQL3Type().toString().equals(thatType.asCQL3Type().toString()))       typesDifferDeeply=true;

 else       return Optional.of(Difference.SHALLOW);

    }

  }

  return typesDifferDeeply ? Optional.of(Difference.DEEP) : Optional.empty();

}

Location: UDFunction.java

Content: 

/** 

 * Used by UDF implementations (both Java code generated by  {@link JavaBasedUDFunction}and script executor  {@link ScriptBasedUDFunction}) to convert the C serialized representation to the Java object representation.

 * @param protocolVersion the native protocol version used for serialization

 * @param argIndex        index of the UDF input argument

 */

protected Object compose(ProtocolVersion protocolVersion,int argIndex,ByteBuffer value){

  return compose(argCodecs,protocolVersion,argIndex,value);

}

Location: UDFunction.java

Content: 

protected static Object compose(TypeCodec<Object>[] codecs,ProtocolVersion protocolVersion,int argIndex,ByteBuffer value){

  return value == null ? null : UDHelper.deserialize(codecs[argIndex],protocolVersion,value);

}

Location: UDFunction.java

Content: 

/** 

 * It can happen that a function has been declared (is listed in the scheam) but cannot be loaded (maybe only on some nodes). This is the case for instance if the class defining the class is not on the classpath for some of the node, or after a restart. In that case, we create a "fake" function so that: 1) the broken function can be dropped easily if that is what people want to do. 2) we return a meaningful error message if the function is executed (something more precise than saying that the function doesn't exist)

 */

public static UDFunction createBrokenFunction(FunctionName name,List<ColumnIdentifier> argNames,List<AbstractType<?>> argTypes,AbstractType<?> returnType,boolean calledOnNullInput,String language,String body,InvalidRequestException reason){

  return new UDFunction(name,argNames,argTypes,returnType,calledOnNullInput,language,body){

    protected ExecutorService executor(){

      return Executors.newSingleThreadExecutor();

    }

    protected Object executeAggregateUserDefined(    ProtocolVersion protocolVersion,    Object firstParam,    List<ByteBuffer> parameters){

      throw broken();

    }

    public ByteBuffer executeUserDefined(    ProtocolVersion protocolVersion,    List<ByteBuffer> parameters){

      throw broken();

    }

    private InvalidRequestException broken(){

      return new InvalidRequestException(String.format("Function '%s' exists but hasn't been loaded successfully " + "for the following reason: %s. Please see the server log for details",this,reason.getMessage()));

    }

  }

;

}

Location: UDFunction.java

Content: 

public static UDFunction create(FunctionName name,List<ColumnIdentifier> argNames,List<AbstractType<?>> argTypes,AbstractType<?> returnType,boolean calledOnNullInput,String language,String body){

  assertUdfsEnabled(language);

switch (language) {

case "java":

    return new JavaBasedUDFunction(name,argNames,argTypes,returnType,calledOnNullInput,body);

default :

  return new ScriptBasedUDFunction(name,argNames,argTypes,returnType,calledOnNullInput,language,body);

}

}

Location: UDFunction.java

Content: 

/** 

 * Used by UDF implementations (both Java code generated by  {@link JavaBasedUDFunction}and script executor  {@link ScriptBasedUDFunction}) to convert the Java object representation for the return value to the C* serialized representation.

 * @param protocolVersion the native protocol version used for serialization

 */

protected ByteBuffer decompose(ProtocolVersion protocolVersion,Object value){

  return decompose(returnCodec,protocolVersion,value);

}

Location: UDFunction.java

Content: 

protected static ByteBuffer decompose(TypeCodec<Object> codec,ProtocolVersion protocolVersion,Object value){

  return value == null ? null : UDHelper.serialize(codec,protocolVersion,value);

}

Location: UDFunction.java

Content: 

private boolean equalsWithoutTypes(UDFunction other){

  return name.equals(other.name) && argTypes.size() == other.argTypes.size() && argNames.equals(other.argNames) && body.equals(other.body) && language.equals(other.language) && calledOnNullInput == other.calledOnNullInput;

}

Location: UDFunction.java

Content: 

/** 

 * Like  {@link #executeAsync(ProtocolVersion,List)} but the first parameter is already in non-serialized form.Remaining parameters (2nd paramters and all others) are in  {@code parameters}. This is used to prevent superfluous (de)serialization of the state of aggregates. Means: scalar functions of aggregates are called using this variant.

 */

private Object executeAggregateAsync(ProtocolVersion protocolVersion,Object firstParam,List<ByteBuffer> parameters){

  ThreadIdAndCpuTime threadIdAndCpuTime=new ThreadIdAndCpuTime();

  return async(threadIdAndCpuTime,() -> {

    threadIdAndCpuTime.setup();

    return executeAggregateUserDefined(protocolVersion,firstParam,parameters);

  }

);

}

Location: UDFunction.java

Content: 

protected abstract Object executeAggregateUserDefined(ProtocolVersion protocolVersion,Object firstParam,List<ByteBuffer> parameters);

Location: UDFunction.java

Content: 

private ByteBuffer executeAsync(ProtocolVersion protocolVersion,List<ByteBuffer> parameters){

  ThreadIdAndCpuTime threadIdAndCpuTime=new ThreadIdAndCpuTime();

  return async(threadIdAndCpuTime,() -> {

    threadIdAndCpuTime.setup();

    return executeUserDefined(protocolVersion,parameters);

  }

);

}

Location: UDFunction.java

Content: 

/** 

 * Like  {@link ScalarFunction#execute(ProtocolVersion,List)} but the first parameter is already in non-serialized form.Remaining parameters (2nd paramters and all others) are in  {@code parameters}. This is used to prevent superfluous (de)serialization of the state of aggregates. Means: scalar functions of aggregates are called using this variant.

 */

public final Object executeForAggregate(ProtocolVersion protocolVersion,Object firstParam,List<ByteBuffer> parameters){

  assertUdfsEnabled(language);

  if (!calledOnNullInput && firstParam == null || !isCallableWrtNullable(parameters))   return null;

  long tStart=System.nanoTime();

  parameters=makeEmptyParametersNull(parameters);

  try {

    Object result=DatabaseDescriptor.enableUserDefinedFunctionsThreads() ? executeAggregateAsync(protocolVersion,firstParam,parameters) : executeAggregateUserDefined(protocolVersion,firstParam,parameters);

    Tracing.trace("Executed UDF {} in {}\u03bcs",name(),(System.nanoTime() - tStart) / 1000);

    return result;

  }

 catch (  InvalidRequestException e) {

    throw e;

  }

catch (  Throwable t) {

    logger.debug("Invocation of user-defined function '{}' failed",this,t);

    if (t instanceof VirtualMachineError)     throw (VirtualMachineError)t;

    throw FunctionExecutionException.create(this,t);

  }

}

Location: UDFunction.java

Content: 

protected abstract ByteBuffer executeUserDefined(ProtocolVersion protocolVersion,List<ByteBuffer> parameters);

Location: UDFunction.java

Content: 

public final ByteBuffer execute(ProtocolVersion protocolVersion,List<ByteBuffer> parameters){

  assertUdfsEnabled(language);

  if (!isCallableWrtNullable(parameters))   return null;

  long tStart=System.nanoTime();

  parameters=makeEmptyParametersNull(parameters);

  try {

    ByteBuffer result=DatabaseDescriptor.enableUserDefinedFunctionsThreads() ? executeAsync(protocolVersion,parameters) : executeUserDefined(protocolVersion,parameters);

    Tracing.trace("Executed UDF {} in {}\u03bcs",name(),(System.nanoTime() - tStart) / 1000);

    return result;

  }

 catch (  InvalidRequestException e) {

    throw e;

  }

catch (  Throwable t) {

    logger.trace("Invocation of user-defined function '{}' failed",this,t);

    if (t instanceof VirtualMachineError)     throw (VirtualMachineError)t;

    throw FunctionExecutionException.create(this,t);

  }

}

Location: UDFunction.java

Content: 

protected abstract ExecutorService executor();

Location: UDFunction.java

Content: 

static void initializeThread(){

  TypeCodec.inet().format(InetAddress.getLoopbackAddress());

  TypeCodec.ascii().format("");

}

Location: UDFunction.java

Content: 

public boolean isCallableWrtNullable(List<ByteBuffer> parameters){

  if (!calledOnNullInput)   for (int i=0; i < parameters.size(); i++)   if (UDHelper.isNullOrEmpty(argTypes.get(i),parameters.get(i)))   return false;

  return true;

}

Location: UDFunction.java

Content: 

public boolean isCalledOnNullInput(){

  return calledOnNullInput;

}

Location: UDFunction.java

Content: 

public boolean isNative(){

  return false;

}

Location: UDFunction.java

Content: 

public String language(){

  return language;

}

Location: UDFunction.java

Content: 

private List<ByteBuffer> makeEmptyParametersNull(List<ByteBuffer> parameters){

  List<ByteBuffer> r=new ArrayList<>(parameters.size());

  for (int i=0; i < parameters.size(); i++) {

    ByteBuffer param=parameters.get(i);

    r.add(UDHelper.isNullOrEmpty(argTypes.get(i),param) ? null : param);

  }

  return r;

}

Location: UDFunction.java

Content: 

static boolean secureResource(String resource){

  while (resource.startsWith("/"))   resource=resource.substring(1);

  for (  String allowed : allowedPatterns)   if (resource.startsWith(allowed)) {

    for (    String disallowed : disallowedPatterns)     if (resource.startsWith(disallowed)) {

      logger.trace("access denied: resource {}",resource);

      return false;

    }

    return true;

  }

  logger.trace("access denied: resource {}",resource);

  return false;

}

Location: UDFunction.java

Content: 

public static UDFunction tryCreate(FunctionName name,List<ColumnIdentifier> argNames,List<AbstractType<?>> argTypes,AbstractType<?> returnType,boolean calledOnNullInput,String language,String body){

  try {

    return create(name,argNames,argTypes,returnType,calledOnNullInput,language,body);

  }

 catch (  InvalidRequestException e) {

    return createBrokenFunction(name,argNames,argTypes,returnType,calledOnNullInput,language,body,e);

  }

}

Location: UDFunction.java

Content: 

protected UDFunction(FunctionName name,List<ColumnIdentifier> argNames,List<AbstractType<?>> argTypes,AbstractType<?> returnType,boolean calledOnNullInput,String language,String body){

  this(name,argNames,argTypes,UDHelper.driverTypes(argTypes),returnType,UDHelper.driverType(returnType),calledOnNullInput,language,body);

}

Location: UDFunction.java

Content: 

protected UDFunction(FunctionName name,List<ColumnIdentifier> argNames,List<AbstractType<?>> argTypes,DataType[] argDataTypes,AbstractType<?> returnType,DataType returnDataType,boolean calledOnNullInput,String language,String body){

  super(name,argTypes,returnType);

  assert new HashSet<>(argNames).size() == argNames.size() : "duplicate argument names";

  this.argNames=argNames;

  this.language=language;

  this.body=body;

  this.argCodecs=UDHelper.codecsFor(argDataTypes);

  this.returnCodec=UDHelper.codecFor(returnDataType);

  this.calledOnNullInput=calledOnNullInput;

  KeyspaceMetadata keyspaceMetadata=Schema.instance.getKeyspaceMetadata(name.keyspace);

  this.udfContext=new UDFContextImpl(argNames,argCodecs,returnCodec,keyspaceMetadata);

}

