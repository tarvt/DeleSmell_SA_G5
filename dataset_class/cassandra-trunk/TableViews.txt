Location: TableViews.java

Content: 

/** 

 * Given an existing base row and the update that we're going to apply to this row, generate the modifications to apply to MVs using the provided  {@code ViewUpdateGenerator}s.

 * @param existingBaseRow the base table row as it is before an update.

 * @param updateBaseRow the newly updates made to {@code existingBaseRow}.

 * @param generators the view update generators to add the new changes to.

 */

private static void addToViewUpdateGenerators(Row existingBaseRow,Row updateBaseRow,Collection<ViewUpdateGenerator> generators){

  assert !updateBaseRow.isEmpty();

  Row mergedBaseRow=existingBaseRow == null ? updateBaseRow : Rows.merge(existingBaseRow,updateBaseRow);

  for (  ViewUpdateGenerator generator : generators)   generator.addBaseTableUpdate(existingBaseRow,mergedBaseRow);

}

Location: TableViews.java

Content: 

public boolean add(View view){

  assert !contains(view.name);

  return views.add(view);

}

Location: TableViews.java

Content: 

private boolean affectsAnyViews(DecoratedKey partitionKey,Row update,Collection<View> views){

  for (  View view : views) {

    if (view.mayBeAffectedBy(partitionKey,update))     return true;

  }

  return false;

}

Location: TableViews.java

Content: 

public Iterable<ColumnFamilyStore> allViewsCfs(){

  Keyspace keyspace=Keyspace.open(baseTableMetadata.keyspace);

  return Iterables.transform(views,view -> keyspace.getColumnFamilyStore(view.getDefinition().name()));

}

Location: TableViews.java

Content: 

/** 

 * Extracts (and potentially groups) the mutations generated by the provided view update generator. Returns the mutation that needs to be done to the views given the base table updates passed to  {@link #addBaseTableUpdate}.

 * @param baseTableMetadata the metadata for the base table being updated.

 * @param generators the generators from which to extract the view mutations from.

 * @return the mutations created by all the generators in {@code generators}.

 */

private Collection<Mutation> buildMutations(TableMetadata baseTableMetadata,List<ViewUpdateGenerator> generators){

  if (generators.size() == 1) {

    ViewUpdateGenerator generator=generators.get(0);

    Collection<PartitionUpdate> updates=generator.generateViewUpdates();

    List<Mutation> mutations=new ArrayList<>(updates.size());

    for (    PartitionUpdate update : updates)     mutations.add(new Mutation(update));

    generator.clear();

    return mutations;

  }

  Map<DecoratedKey,Mutation.PartitionUpdateCollector> mutations=new HashMap<>();

  for (  ViewUpdateGenerator generator : generators) {

    for (    PartitionUpdate update : generator.generateViewUpdates()) {

      DecoratedKey key=update.partitionKey();

      Mutation.PartitionUpdateCollector collector=mutations.get(key);

      if (collector == null) {

        collector=new Mutation.PartitionUpdateCollector(baseTableMetadata.keyspace,key);

        mutations.put(key,collector);

      }

      collector.add(update);

    }

    generator.clear();

  }

  return mutations.values().stream().map(Mutation.PartitionUpdateCollector::build).collect(Collectors.toList());

}

Location: TableViews.java

Content: 

public void dumpMemtables(){

  for (  ColumnFamilyStore viewCfs : allViewsCfs())   viewCfs.dumpMemtable();

}

Location: TableViews.java

Content: 

private static Row emptyRow(Clustering<?> clustering,DeletionTime deletion){

  return deletion.isLive() ? null : BTreeRow.emptyDeletedRow(clustering,Row.Deletion.regular(deletion));

}

Location: TableViews.java

Content: 

public void forceBlockingFlush(){

  for (  ColumnFamilyStore viewCfs : allViewsCfs())   viewCfs.forceBlockingFlush();

}

Location: TableViews.java

Content: 

/** 

 * Given some updates on the base table of this object and the existing values for the rows affected by that update, generates the mutation to be applied to the provided views.

 * @param views the views potentially affected by {@code updates}.

 * @param updates the base table updates being applied.

 * @param existings the existing values for the rows affected by {@code updates}. This is used to decide if a view is obsoleted by the update and should be removed, gather the values for columns that may not be part of the update if a new view entry needs to be created, and compute the minimal updates to be applied if the view entry isn't changed but has simply some updated values. This will be empty for view building as we want to assume anything we'll pass to  {@code updates} is new.

 * @param nowInSec the current time in seconds.

 * @param separateUpdates, if false, mutation is per partition.

 * @return the mutations to apply to the {@code views}. This can be empty.

 */

public Iterator<Collection<Mutation>> generateViewUpdates(Collection<View> views,UnfilteredRowIterator updates,UnfilteredRowIterator existings,int nowInSec,boolean separateUpdates){

  assert updates.metadata().id.equals(baseTableMetadata.id);

  List<ViewUpdateGenerator> generators=new ArrayList<>(views.size());

  for (  View view : views)   generators.add(new ViewUpdateGenerator(view,updates.partitionKey(),nowInSec));

  DeletionTracker existingsDeletion=new DeletionTracker(existings.partitionLevelDeletion());

  DeletionTracker updatesDeletion=new DeletionTracker(updates.partitionLevelDeletion());

  PeekingIterator<Unfiltered> existingsIter=Iterators.peekingIterator(existings);

  PeekingIterator<Unfiltered> updatesIter=Iterators.peekingIterator(updates);

  while (existingsIter.hasNext() && updatesIter.hasNext()) {

    Unfiltered existing=existingsIter.peek();

    Unfiltered update=updatesIter.peek();

    Row existingRow;

    Row updateRow;

    int cmp=baseTableMetadata.get().comparator.compare(update,existing);

    if (cmp < 0) {

      if (update.isRangeTombstoneMarker()) {

        updatesDeletion.update(updatesIter.next());

        continue;

      }

      updateRow=((Row)updatesIter.next()).withRowDeletion(updatesDeletion.currentDeletion());

      existingRow=emptyRow(updateRow.clustering(),existingsDeletion.currentDeletion());

    }

 else     if (cmp > 0) {

      if (existing.isRangeTombstoneMarker()) {

        existingsDeletion.update(existingsIter.next());

        continue;

      }

      existingRow=((Row)existingsIter.next()).withRowDeletion(existingsDeletion.currentDeletion());

      updateRow=emptyRow(existingRow.clustering(),updatesDeletion.currentDeletion());

      if (updateRow == null)       continue;

    }

 else {

      if (update.isRangeTombstoneMarker()) {

        assert existing.isRangeTombstoneMarker();

        updatesDeletion.update(updatesIter.next());

        existingsDeletion.update(existingsIter.next());

        continue;

      }

      assert !existing.isRangeTombstoneMarker();

      existingRow=((Row)existingsIter.next()).withRowDeletion(existingsDeletion.currentDeletion());

      updateRow=((Row)updatesIter.next()).withRowDeletion(updatesDeletion.currentDeletion());

    }

    addToViewUpdateGenerators(existingRow,updateRow,generators);

  }

  if (!updatesDeletion.currentDeletion().isLive()) {

    while (existingsIter.hasNext()) {

      Unfiltered existing=existingsIter.next();

      if (existing.isRangeTombstoneMarker())       continue;

      Row existingRow=(Row)existing;

      addToViewUpdateGenerators(existingRow,emptyRow(existingRow.clustering(),updatesDeletion.currentDeletion()),generators);

    }

  }

  if (separateUpdates) {

    final Collection<Mutation> firstBuild=buildMutations(baseTableMetadata.get(),generators);

    return new Iterator<Collection<Mutation>>(){

      Collection<Mutation> next=firstBuild.isEmpty() ? buildNext() : firstBuild;

      private Collection<Mutation> buildNext(){

        while (updatesIter.hasNext()) {

          Unfiltered update=updatesIter.next();

          if (update.isRangeTombstoneMarker())           continue;

          Row updateRow=(Row)update;

          addToViewUpdateGenerators(emptyRow(updateRow.clustering(),existingsDeletion.currentDeletion()),updateRow,generators);

          Collection<Mutation> mutations=buildMutations(baseTableMetadata.get(),generators);

          if (!mutations.isEmpty())           return mutations;

        }

        return null;

      }

      public boolean hasNext(){

        return next != null;

      }

      public Collection<Mutation> next(){

        Collection<Mutation> mutations=next;

        next=buildNext();

        assert !mutations.isEmpty() : "Expected mutations to be non-empty";

        return mutations;

      }

    }

;

  }

 else {

    while (updatesIter.hasNext()) {

      Unfiltered update=updatesIter.next();

      if (update.isRangeTombstoneMarker())       continue;

      Row updateRow=(Row)update;

      addToViewUpdateGenerators(emptyRow(updateRow.clustering(),existingsDeletion.currentDeletion()),updateRow,generators);

    }

    return Iterators.singletonIterator(buildMutations(baseTableMetadata.get(),generators));

  }

}

Location: TableViews.java

Content: 

public boolean hasViews(){

  return !views.isEmpty();

}

Location: TableViews.java

Content: 

/** 

 * Calculates and pushes updates to the views replicas. The replicas are determined by {@link ViewUtils#getViewNaturalEndpoint(String,Token,Token)}.

 * @param update an update on the base table represented by this object.

 * @param writeCommitLog whether we should write the commit log for the view updates.

 * @param baseComplete time from epoch in ms that the local base mutation was (or will be) completed

 */

public void pushViewReplicaUpdates(PartitionUpdate update,boolean writeCommitLog,AtomicLong baseComplete){

  assert update.metadata().id.equals(baseTableMetadata.id);

  Collection<View> views=updatedViews(update);

  if (views.isEmpty())   return;

  int nowInSec=FBUtilities.nowInSeconds();

  long queryStartNanoTime=System.nanoTime();

  SinglePartitionReadCommand command=readExistingRowsCommand(update,views,nowInSec);

  if (command == null)   return;

  ColumnFamilyStore cfs=Keyspace.openAndGetStore(update.metadata());

  long start=System.nanoTime();

  Collection<Mutation> mutations;

  try (ReadExecutionController orderGroup=command.executionController();UnfilteredRowIterator existings=UnfilteredPartitionIterators.getOnlyElement(command.executeLocally(orderGroup),command);UnfilteredRowIterator updates=update.unfilteredIterator()){

    mutations=Iterators.getOnlyElement(generateViewUpdates(views,updates,existings,nowInSec,false));

  }

   Keyspace.openAndGetStore(update.metadata()).metric.viewReadTime.update(System.nanoTime() - start,TimeUnit.NANOSECONDS);

  if (!mutations.isEmpty())   StorageProxy.mutateMV(update.partitionKey().getKey(),mutations,writeCommitLog,baseComplete,queryStartNanoTime);

}

Location: TableViews.java

Content: 

/** 

 * Returns the command to use to read the existing rows required to generate view updates for the provided base base updates.

 * @param updates the base table updates being applied.

 * @param views the views potentially affected by {@code updates}.

 * @param nowInSec the current time in seconds.

 * @return the command to use to read the base table rows required to generate view updates for {@code updates}.

 */

private SinglePartitionReadCommand readExistingRowsCommand(PartitionUpdate updates,Collection<View> views,int nowInSec){

  Slices.Builder sliceBuilder=null;

  DeletionInfo deletionInfo=updates.deletionInfo();

  TableMetadata metadata=updates.metadata();

  DecoratedKey key=updates.partitionKey();

  if (!deletionInfo.isLive()) {

    sliceBuilder=new Slices.Builder(metadata.comparator);

    if (!deletionInfo.getPartitionDeletion().isLive()) {

      for (      View view : views)       sliceBuilder.addAll(view.getSelectStatement().clusteringIndexFilterAsSlices());

    }

 else {

      assert deletionInfo.hasRanges();

      Iterator<RangeTombstone> iter=deletionInfo.rangeIterator(false);

      while (iter.hasNext())       sliceBuilder.add(iter.next().deletedSlice());

    }

  }

  BTreeSet.Builder<Clustering<?>> namesBuilder=sliceBuilder == null ? BTreeSet.builder(metadata.comparator) : null;

  for (  Row row : updates) {

    if (!affectsAnyViews(key,row,views))     continue;

    if (namesBuilder == null)     sliceBuilder.add(Slice.make(row.clustering()));

 else     namesBuilder.add(row.clustering());

  }

  NavigableSet<Clustering<?>> names=namesBuilder == null ? null : namesBuilder.build();

  if (names != null && names.isEmpty())   return null;

  ClusteringIndexFilter clusteringFilter=names == null ? new ClusteringIndexSliceFilter(sliceBuilder.build(),false) : new ClusteringIndexNamesFilter(names,false);

  ColumnFilter queriedColumns=views.size() == 1 && metadata.enforceStrictLiveness() ? Iterables.getOnlyElement(views).getSelectStatement().queriedColumns() : ColumnFilter.all(metadata);

  RowFilter rowFilter=RowFilter.NONE;

  return SinglePartitionReadCommand.create(metadata,nowInSec,queriedColumns,rowFilter,DataLimits.NONE,key,clusteringFilter);

}

Location: TableViews.java

Content: 

public void removeByName(String viewName){

  views.removeIf(v -> v.name.equals(viewName));

}

Location: TableViews.java

Content: 

public TableViews(TableId id){

  baseTableMetadata=Schema.instance.getTableMetadataRef(id);

}

Location: TableViews.java

Content: 

public void truncateBlocking(CommitLogPosition replayAfter,long truncatedAt){

  for (  ColumnFamilyStore viewCfs : allViewsCfs()) {

    viewCfs.discardSSTables(truncatedAt);

    SystemKeyspace.saveTruncationRecord(viewCfs,truncatedAt,replayAfter);

  }

}

Location: TableViews.java

Content: 

/** 

 * Return the views that are potentially updated by the provided updates.

 * @param updates the updates applied to the base table.

 * @return the views affected by {@code updates}.

 */

public Collection<View> updatedViews(PartitionUpdate updates){

  List<View> matchingViews=new ArrayList<>(views.size());

  for (  View view : views) {

    ReadQuery selectQuery=view.getReadQuery();

    if (!selectQuery.selectsKey(updates.partitionKey()))     continue;

    matchingViews.add(view);

  }

  return matchingViews;

}

