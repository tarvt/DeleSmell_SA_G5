Location: ColumnFamilyStore.java

Content: 

public void addSSTables(Collection<SSTableReader> sstables){

  data.addSSTables(sstables);

  CompactionManager.instance.submitBackground(this);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Insert/Update the column family for this key. Caller is responsible for acquiring Keyspace.switchLock param @ lock - lock that needs to be used. param @ key - key for update/insert param @ columnFamily - columnFamily changes

 */

public void apply(PartitionUpdate update,UpdateTransaction indexer,OpOrder.Group opGroup,CommitLogPosition commitLogPosition){

  long start=System.nanoTime();

  try {

    Memtable mt=data.getMemtableFor(opGroup,commitLogPosition);

    long timeDelta=mt.put(update,indexer,opGroup);

    DecoratedKey key=update.partitionKey();

    invalidateCachedPartition(key);

    metric.topWritePartitionFrequency.addSample(key.getKey(),1);

    if (metric.topWritePartitionSize.isEnabled())     metric.topWritePartitionSize.addSample(key.getKey(),update.dataSize());

    StorageHook.instance.reportWrite(metadata.id,update);

    metric.writeLatency.addNano(System.nanoTime() - start);

    if (timeDelta < Long.MAX_VALUE)     metric.colUpdateTimeDeltaHistogram.update(Math.min(18165375903306L,timeDelta));

  }

 catch (  RuntimeException e) {

    throw new RuntimeException(e.getMessage() + " for ks: " + keyspace.getName()+ ", table: "+ name,e);

  }

}

Location: ColumnFamilyStore.java

Content: 

public void cleanupCache(){

  Collection<Range<Token>> ranges=StorageService.instance.getLocalReplicas(keyspace.getName()).ranges();

  for (Iterator<RowCacheKey> keyIter=CacheService.instance.rowCache.keyIterator(); keyIter.hasNext(); ) {

    RowCacheKey key=keyIter.next();

    DecoratedKey dk=decorateKey(ByteBuffer.wrap(key.key));

    if (key.sameTable(metadata()) && !Range.isInRanges(dk.getToken(),ranges))     invalidateCachedPartition(dk);

  }

  if (metadata().isCounter()) {

    for (Iterator<CounterCacheKey> keyIter=CacheService.instance.counterCache.keyIterator(); keyIter.hasNext(); ) {

      CounterCacheKey key=keyIter.next();

      DecoratedKey dk=decorateKey(key.partitionKey());

      if (key.sameTable(metadata()) && !Range.isInRanges(dk.getToken(),ranges))       CacheService.instance.counterCache.remove(key);

    }

  }

}

Location: ColumnFamilyStore.java

Content: 

protected static void clearEphemeralSnapshots(Directories directories){

  RateLimiter clearSnapshotRateLimiter=DatabaseDescriptor.getSnapshotRateLimiter();

  for (  String ephemeralSnapshot : directories.listEphemeralSnapshots()) {

    logger.trace("Clearing ephemeral snapshot {} leftover from previous session.",ephemeralSnapshot);

    Directories.clearSnapshot(ephemeralSnapshot,directories.getCFDirectories(),clearSnapshotRateLimiter);

  }

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Clear all the snapshots for a given column family.

 * @param snapshotName the user supplied snapshot name. If left empty,all the snapshots will be cleaned.

 */

public void clearSnapshot(String snapshotName){

  RateLimiter clearSnapshotRateLimiter=DatabaseDescriptor.getSnapshotRateLimiter();

  List<File> snapshotDirs=getDirectories().getCFDirectories();

  Directories.clearSnapshot(snapshotName,snapshotDirs,clearSnapshotRateLimiter);

}

Location: ColumnFamilyStore.java

Content: 

@VisibleForTesting public ColumnFamilyStore(Keyspace keyspace,String columnFamilyName,int generation,TableMetadataRef metadata,Directories directories,boolean loadSSTables,boolean registerBookeeping,boolean offline){

  assert directories != null;

  assert metadata != null : "null metadata for " + keyspace + ":"+ columnFamilyName;

  this.keyspace=keyspace;

  this.metadata=metadata;

  this.directories=directories;

  name=columnFamilyName;

  minCompactionThreshold=new DefaultValue<>(metadata.get().params.compaction.minCompactionThreshold());

  maxCompactionThreshold=new DefaultValue<>(metadata.get().params.compaction.maxCompactionThreshold());

  crcCheckChance=new DefaultValue<>(metadata.get().params.crcCheckChance);

  viewManager=keyspace.viewManager.forTable(metadata.id);

  fileIndexGenerator.set(generation);

  sampleReadLatencyNanos=DatabaseDescriptor.getReadRpcTimeout(NANOSECONDS) / 2;

  additionalWriteLatencyNanos=DatabaseDescriptor.getWriteRpcTimeout(NANOSECONDS) / 2;

  logger.info("Initializing {}.{}",keyspace.getName(),name);

  Memtable initialMemtable=null;

  if (DatabaseDescriptor.isDaemonInitialized())   initialMemtable=new Memtable(new AtomicReference<>(CommitLog.instance.getCurrentPosition()),this);

  data=new Tracker(initialMemtable,loadSSTables);

  Collection<SSTableReader> sstables=null;

  if (data.loadsstables) {

    Directories.SSTableLister sstableFiles=directories.sstableLister(Directories.OnTxnErr.IGNORE).skipTemporary(true);

    sstables=SSTableReader.openAll(sstableFiles.list().entrySet(),metadata);

    data.addInitialSSTablesWithoutUpdatingSize(sstables);

  }

  compactionStrategyManager=new CompactionStrategyManager(this);

  if (maxCompactionThreshold.value() <= 0 || minCompactionThreshold.value() <= 0) {

    logger.warn("Disabling compaction strategy by setting compaction thresholds to 0 is deprecated, set the compaction option 'enabled' to 'false' instead.");

    this.compactionStrategyManager.disable();

  }

  indexManager=new SecondaryIndexManager(this);

  for (  IndexMetadata info : metadata.get().indexes) {

    indexManager.addIndex(info,true);

  }

  metric=new TableMetrics(this);

  if (data.loadsstables) {

    data.updateInitialSSTableSize(sstables);

  }

  if (registerBookeeping) {

    mbeanName=getTableMBeanName(keyspace.getName(),name,isIndex());

    oldMBeanName=getColumnFamilieMBeanName(keyspace.getName(),name,isIndex());

    String[] objectNames={mbeanName,oldMBeanName};

    for (    String objectName : objectNames)     MBeanWrapper.instance.registerMBean(this,objectName);

  }

 else {

    mbeanName=null;

    oldMBeanName=null;

  }

  writeHandler=new CassandraTableWriteHandler(this);

  streamManager=new CassandraStreamManager(this);

  repairManager=new CassandraTableRepairManager(this);

  sstableImporter=new SSTableImporter(this);

}

Location: ColumnFamilyStore.java

Content: 

public Iterable<ColumnFamilyStore> concatWithIndexes(){

  return Iterables.concat(Collections.singleton(this),indexManager.getAllIndexColumnFamilyStores());

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * @return true if @param key is contained in the row cache

 */

public boolean containsCachedParition(DecoratedKey key){

  return CacheService.instance.rowCache.getCapacity() != 0 && CacheService.instance.rowCache.containsKey(new RowCacheKey(metadata(),key));

}

Location: ColumnFamilyStore.java

Content: 

public static synchronized ColumnFamilyStore createColumnFamilyStore(Keyspace keyspace,String columnFamily,TableMetadataRef metadata,boolean loadSSTables){

  Directories directories=new Directories(metadata.get());

  return createColumnFamilyStore(keyspace,columnFamily,metadata,directories,loadSSTables,true,false);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * This is only directly used by offline tools 

 */

public static synchronized ColumnFamilyStore createColumnFamilyStore(Keyspace keyspace,String columnFamily,TableMetadataRef metadata,Directories directories,boolean loadSSTables,boolean registerBookkeeping,boolean offline){

  Directories.SSTableLister lister=directories.sstableLister(Directories.OnTxnErr.IGNORE).includeBackups(true);

  List<Integer> generations=new ArrayList<Integer>();

  for (  Map.Entry<Descriptor,Set<Component>> entry : lister.list().entrySet()) {

    Descriptor desc=entry.getKey();

    generations.add(desc.generation);

    if (!desc.isCompatible())     throw new RuntimeException(String.format("Incompatible SSTable found. Current version %s is unable to read file: %s. Please run upgradesstables.",desc.getFormat().getLatestVersion(),desc));

  }

  Collections.sort(generations);

  int value=(generations.size() > 0) ? (generations.get(generations.size() - 1)) : 0;

  return new ColumnFamilyStore(keyspace,columnFamily,value,metadata,directories,loadSSTables,registerBookkeeping,offline);

}

Location: ColumnFamilyStore.java

Content: 

public static ColumnFamilyStore createColumnFamilyStore(Keyspace keyspace,TableMetadataRef metadata,boolean loadSSTables){

  return createColumnFamilyStore(keyspace,metadata.name,metadata,loadSSTables);

}

Location: ColumnFamilyStore.java

Content: 

public AbstractCompactionStrategy createCompactionStrategyInstance(CompactionParams compactionParams){

  try {

    Constructor<? extends AbstractCompactionStrategy> constructor=compactionParams.klass().getConstructor(ColumnFamilyStore.class,Map.class);

    return constructor.newInstance(this,compactionParams.options());

  }

 catch (  NoSuchMethodException|IllegalAccessException|InvocationTargetException|InstantiationException e) {

    throw new RuntimeException(e);

  }

}

Location: ColumnFamilyStore.java

Content: 

private void createEphemeralSnapshotMarkerFile(final String snapshot){

  final File ephemeralSnapshotMarker=getDirectories().getNewEphemeralSnapshotMarkerFile(snapshot);

  try {

    if (!ephemeralSnapshotMarker.getParentFile().exists())     ephemeralSnapshotMarker.getParentFile().mkdirs();

    Files.createFile(ephemeralSnapshotMarker.toPath());

    if (logger.isTraceEnabled())     logger.trace("Created ephemeral snapshot marker file on {}.",ephemeralSnapshotMarker.getAbsolutePath());

  }

 catch (  IOException e) {

    logger.warn(String.format("Could not create marker file %s for ephemeral snapshot %s. " + "In case there is a failure in the operation that created " + "this snapshot, you may need to clean it manually afterwards.",ephemeralSnapshotMarker.getAbsolutePath(),snapshot),e);

  }

}

Location: ColumnFamilyStore.java

Content: 

public SSTableMultiWriter createSSTableMultiWriter(Descriptor descriptor,long keyCount,long repairedAt,UUID pendingRepair,boolean isTransient,int sstableLevel,SerializationHeader header,LifecycleNewTracker lifecycleNewTracker){

  MetadataCollector collector=new MetadataCollector(metadata().comparator).sstableLevel(sstableLevel);

  return createSSTableMultiWriter(descriptor,keyCount,repairedAt,pendingRepair,isTransient,collector,header,lifecycleNewTracker);

}

Location: ColumnFamilyStore.java

Content: 

public SSTableMultiWriter createSSTableMultiWriter(Descriptor descriptor,long keyCount,long repairedAt,UUID pendingRepair,boolean isTransient,MetadataCollector metadataCollector,SerializationHeader header,LifecycleNewTracker lifecycleNewTracker){

  return getCompactionStrategyManager().createSSTableMultiWriter(descriptor,keyCount,repairedAt,pendingRepair,isTransient,metadataCollector,header,indexManager.listIndexes(),lifecycleNewTracker);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Discard all SSTables that were created before given timestamp. Caller should first ensure that comapctions have quiesced.

 * @param truncatedAt The timestamp of the truncation(all SSTables before that timestamp are going be marked as compacted)

 */

public void discardSSTables(long truncatedAt){

  assert data.getCompacting().isEmpty() : data.getCompacting();

  List<SSTableReader> truncatedSSTables=new ArrayList<>();

  int keptSSTables=0;

  for (  SSTableReader sstable : getSSTables(SSTableSet.LIVE)) {

    if (!sstable.newSince(truncatedAt)) {

      truncatedSSTables.add(sstable);

    }

 else {

      keptSSTables++;

      logger.info("Truncation is keeping {} maxDataAge={} truncatedAt={}",sstable,sstable.maxDataAge,truncatedAt);

    }

  }

  if (!truncatedSSTables.isEmpty()) {

    logger.info("Truncation is dropping {} sstables and keeping {} due to sstable.maxDataAge > truncatedAt",truncatedSSTables.size(),keptSSTables);

    markObsolete(truncatedSSTables,OperationType.UNKNOWN);

  }

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Drops current memtable without flushing to disk. This should only be called when truncating a column family which is not durable.

 */

public Future<CommitLogPosition> dumpMemtable(){

synchronized (data) {

    final Flush flush=new Flush(true);

    flushExecutor.execute(flush);

    postFlushExecutor.execute(flush.postFlushTask);

    return flush.postFlushTask;

  }

}

Location: ColumnFamilyStore.java

Content: 

public void enableAutoCompaction(){

  enableAutoCompaction(false);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * used for tests - to be able to check things after a minor compaction

 * @param waitForFutures if we should block until autocompaction is done

 */

@VisibleForTesting public void enableAutoCompaction(boolean waitForFutures){

  compactionStrategyManager.enable();

  List<Future<?>> futures=CompactionManager.instance.submitBackground(this);

  if (waitForFutures)   FBUtilities.waitOnFutures(futures);

}

Location: ColumnFamilyStore.java

Content: 

public long estimatedKeysForRange(Range<Token> range){

  try (RefViewFragment view=selectAndReference(View.selectFunction(SSTableSet.CANONICAL))){

    long count=0;

    for (    SSTableReader sstable : view.sstables)     count+=sstable.estimatedKeysForRanges(Collections.singleton(range));

    return count;

  }

 }

Location: ColumnFamilyStore.java

Content: 

public CompactionManager.AllSSTableOpStatus forceCleanup(int jobs) throws ExecutionException, InterruptedException {

  return CompactionManager.instance.performCleanup(ColumnFamilyStore.this,jobs);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Flush if there is unflushed data in the memtables

 * @return a Future yielding the commit log position that can be guaranteed to have been successfully writtento sstables for this table once the future completes

 */

public ListenableFuture<CommitLogPosition> forceFlush(){

synchronized (data) {

    Memtable current=data.getView().getCurrentMemtable();

    for (    ColumnFamilyStore cfs : concatWithIndexes())     if (!cfs.data.getView().getCurrentMemtable().isClean())     return switchMemtableIfCurrent(current);

    return waitForFlushes();

  }

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Flush if there is unflushed data that was written to the CommitLog before @param flushIfDirtyBefore (inclusive).

 * @return a Future yielding the commit log position that can be guaranteed to have been successfully writtento sstables for this table once the future completes

 */

public ListenableFuture<?> forceFlush(CommitLogPosition flushIfDirtyBefore){

  Memtable current=data.getView().getCurrentMemtable();

  if (current.mayContainDataBefore(flushIfDirtyBefore))   return switchMemtableIfCurrent(current);

  return waitForFlushes();

}

Location: ColumnFamilyStore.java

Content: 

public void forceMajorCompaction() throws InterruptedException, ExecutionException {

  forceMajorCompaction(false);

}

Location: ColumnFamilyStore.java

Content: 

public CompactionManager.AllSSTableOpStatus garbageCollect(TombstoneOption tombstoneOption,int jobs) throws ExecutionException, InterruptedException {

  return CompactionManager.instance.performGarbageCollection(this,tombstoneOption,jobs);

}

Location: ColumnFamilyStore.java

Content: 

public int gcBefore(int nowInSec){

  return nowInSec - metadata().params.gcGraceSeconds;

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * like getOverlappingSSTables, but acquires references before returning

 */

public Refs<SSTableReader> getAndReferenceOverlappingLiveSSTables(Iterable<SSTableReader> sstables){

  while (true) {

    Iterable<SSTableReader> overlapped=getOverlappingLiveSSTables(sstables);

    Refs<SSTableReader> refs=Refs.tryRef(overlapped);

    if (refs != null)     return refs;

  }

}

Location: ColumnFamilyStore.java

Content: 

public static Runnable getBackgroundCompactionTaskSubmitter(){

  return new Runnable(){

    public void run(){

      for (      Keyspace keyspace : Keyspace.all())       for (      ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())       CompactionManager.instance.submitBackground(cfs);

    }

  }

;

}

Location: ColumnFamilyStore.java

Content: 

public ClockAndCount getCachedCounter(ByteBuffer partitionKey,Clustering<?> clustering,ColumnMetadata column,CellPath path){

  if (CacheService.instance.counterCache.getCapacity() == 0L)   return null;

  return CacheService.instance.counterCache.get(CounterCacheKey.create(metadata(),partitionKey,clustering,column,path));

}

Location: ColumnFamilyStore.java

Content: 

public static String getColumnFamilieMBeanName(String ks,String name,boolean isIndex){

  return String.format("org.apache.cassandra.db:type=%s,keyspace=%s,columnfamily=%s",isIndex ? "IndexColumnFamilies" : "ColumnFamilies",ks,name);

}

Location: ColumnFamilyStore.java

Content: 

public CompactionStrategyManager getCompactionStrategyManager(){

  return compactionStrategyManager;

}

Location: ColumnFamilyStore.java

Content: 

public DiskBoundaries getDiskBoundaries(){

  return diskBoundaryManager.getDiskBoundaries(this);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Calculate expected file size of SSTable after compaction. If operation type is  {@code CLEANUP} and we're not dealing with an index sstable,then we calculate expected file size with checking token range to be eliminated. Otherwise, we just add up all the files' size, which is the worst case file size for compaction of all the list of files given.

 * @param sstables SSTables to calculate expected compacted file size

 * @param operation Operation type

 * @return Expected file size of SSTable after compaction

 */

public long getExpectedCompactedFileSize(Iterable<SSTableReader> sstables,OperationType operation){

  if (operation != OperationType.CLEANUP || isIndex()) {

    return SSTableReader.getTotalBytes(sstables);

  }

  long expectedFileSize=0;

  Collection<Range<Token>> ranges=StorageService.instance.getLocalReplicas(keyspace.getName()).ranges();

  for (  SSTableReader sstable : sstables) {

    List<SSTableReader.PartitionPositionBounds> positions=sstable.getPositionsForRanges(ranges);

    for (    SSTableReader.PartitionPositionBounds position : positions)     expectedFileSize+=position.upperPosition - position.lowerPosition;

  }

  double compressionRatio=metric.compressionRatio.getValue();

  if (compressionRatio > 0d)   expectedFileSize*=compressionRatio;

  return expectedFileSize;

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Returns a ColumnFamilyStore by ksname and cfname if it exists, null otherwise Differently from others, this method does not throw exception if the keyspace or table does not exist.

 */

public static ColumnFamilyStore getIfExists(String ksName,String cfName){

  if (ksName == null || cfName == null)   return null;

  Keyspace keyspace=Keyspace.open(ksName);

  if (keyspace == null)   return null;

  TableMetadata table=Schema.instance.getTableMetadata(ksName,cfName);

  if (table == null)   return null;

  return keyspace.getColumnFamilyStore(table.id);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Returns a ColumnFamilyStore by id if it exists, null otherwise Differently from others, this method does not throw exception if the table does not exist.

 */

public static ColumnFamilyStore getIfExists(TableId id){

  TableMetadata metadata=Schema.instance.getTableMetadata(id);

  if (metadata == null)   return null;

  Keyspace keyspace=Keyspace.open(metadata.keyspace);

  if (keyspace == null)   return null;

  return keyspace.hasColumnFamilyStore(id) ? keyspace.getColumnFamilyStore(id) : null;

}

Location: ColumnFamilyStore.java

Content: 

public Set<SSTableReader> getLiveSSTables(){

  return data.getView().liveSSTables();

}

Location: ColumnFamilyStore.java

Content: 

public SSTableReader getMaxSizeFile(Iterable<SSTableReader> sstables){

  long maxSize=0L;

  SSTableReader maxFile=null;

  for (  SSTableReader sstable : sstables) {

    if (sstable.onDiskLength() > maxSize) {

      maxSize=sstable.onDiskLength();

      maxFile=sstable;

    }

  }

  return maxFile;

}

Location: ColumnFamilyStore.java

Content: 

public int getMeanEstimatedCellPerPartitionCount(){

  long sum=0;

  long count=0;

  for (  SSTableReader sstable : getSSTables(SSTableSet.CANONICAL)) {

    long n=sstable.getEstimatedCellPerPartitionCount().count();

    sum+=sstable.getEstimatedCellPerPartitionCount().mean() * n;

    count+=n;

  }

  return count > 0 ? (int)(sum / count) : 0;

}

Location: ColumnFamilyStore.java

Content: 

public double getMeanPartitionSize(){

  long sum=0;

  long count=0;

  for (  SSTableReader sstable : getSSTables(SSTableSet.CANONICAL)) {

    long n=sstable.getEstimatedPartitionSize().count();

    sum+=sstable.getEstimatedPartitionSize().mean() * n;

    count+=n;

  }

  return count > 0 ? sum * 1.0 / count : 0;

}

Location: ColumnFamilyStore.java

Content: 

public int getMeanRowCount(){

  long totalRows=0;

  long totalPartitions=0;

  for (  SSTableReader sstable : getSSTables(SSTableSet.CANONICAL)) {

    totalPartitions+=sstable.getEstimatedPartitionSize().count();

    totalRows+=sstable.getTotalRows();

  }

  return totalPartitions > 0 ? (int)(totalRows / totalPartitions) : 0;

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * @param sstables

 * @return sstables whose key range overlaps with that of the given sstables, not including itself.(The given sstables may or may not overlap with each other.)

 */

public Collection<SSTableReader> getOverlappingLiveSSTables(Iterable<SSTableReader> sstables){

  logger.trace("Checking for sstables overlapping {}",sstables);

  if (!sstables.iterator().hasNext())   return ImmutableSet.of();

  View view=data.getView();

  List<SSTableReader> sortedByFirst=Lists.newArrayList(sstables);

  Collections.sort(sortedByFirst,(o1,o2) -> o1.first.compareTo(o2.first));

  List<AbstractBounds<PartitionPosition>> bounds=new ArrayList<>();

  DecoratedKey first=null, last=null;

  for (  SSTableReader sstable : sortedByFirst) {

    if (first == null) {

      first=sstable.first;

      last=sstable.last;

    }

 else {

      if (sstable.first.compareTo(last) <= 0) {

        if (sstable.last.compareTo(last) > 0)         last=sstable.last;

      }

 else {

        bounds.add(AbstractBounds.bounds(first,true,last,true));

        first=sstable.first;

        last=sstable.last;

      }

    }

  }

  bounds.add(AbstractBounds.bounds(first,true,last,true));

  Set<SSTableReader> results=new HashSet<>();

  for (  AbstractBounds<PartitionPosition> bound : bounds)   Iterables.addAll(results,view.liveSSTablesInBounds(bound.left,bound.right));

  return Sets.difference(results,ImmutableSet.copyOf(sstables));

}

Location: ColumnFamilyStore.java

Content: 

public Map<UUID,PendingStat> getPendingRepairStats(){

  Map<UUID,PendingStat.Builder> builders=new HashMap<>();

  for (  SSTableReader sstable : getLiveSSTables()) {

    UUID session=sstable.getPendingRepair();

    if (session == null)     continue;

    if (!builders.containsKey(session))     builders.put(session,new PendingStat.Builder());

    builders.get(session).addSSTable(sstable);

  }

  Map<UUID,PendingStat> stats=new HashMap<>();

  for (  Map.Entry<UUID,PendingStat.Builder> entry : builders.entrySet()) {

    stats.put(entry.getKey(),entry.getValue().build());

  }

  return stats;

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * @return the cached partition for @param key if it is already present in the cache.Not that this will not readAndCache the parition if it is not present, nor are these calls counted in cache statistics. Note that this WILL cause deserialization of a SerializingCache partition, so if all you need to know is whether a partition is present or not, use containsCachedParition instead.

 */

public CachedPartition getRawCachedPartition(DecoratedKey key){

  if (!isRowCacheEnabled())   return null;

  IRowCacheEntry cached=CacheService.instance.rowCache.getInternal(new RowCacheKey(metadata(),key));

  return cached == null || cached instanceof RowCacheSentinel ? null : (CachedPartition)cached;

}

Location: ColumnFamilyStore.java

Content: 

public long getSnapshotCreationTime(String snapshotName){

  return getDirectories().snapshotCreationTime(snapshotName);

}

Location: ColumnFamilyStore.java

Content: 

public Refs<SSTableReader> getSnapshotSSTableReaders(String tag) throws IOException {

  Map<Integer,SSTableReader> active=new HashMap<>();

  for (  SSTableReader sstable : getSSTables(SSTableSet.CANONICAL))   active.put(sstable.descriptor.generation,sstable);

  Map<Descriptor,Set<Component>> snapshots=getDirectories().sstableLister(Directories.OnTxnErr.IGNORE).snapshots(tag).list();

  Refs<SSTableReader> refs=new Refs<>();

  try {

    for (    Map.Entry<Descriptor,Set<Component>> entries : snapshots.entrySet()) {

      SSTableReader sstable=active.get(entries.getKey().generation);

      if (sstable == null || !refs.tryRef(sstable)) {

        if (logger.isTraceEnabled())         logger.trace("using snapshot sstable {}",entries.getKey());

        sstable=SSTableReader.open(entries.getKey(),entries.getValue(),metadata,true,true);

        refs.tryRef(sstable);

        sstable.selfRef().release();

      }

 else       if (logger.isTraceEnabled()) {

        logger.trace("using active sstable {}",entries.getKey());

      }

    }

  }

 catch (  FSReadError|RuntimeException e) {

    refs.release();

    throw e;

  }

  return refs;

}

Location: ColumnFamilyStore.java

Content: 

public Iterable<SSTableReader> getSSTables(SSTableSet sstableSet){

  return data.getView().select(sstableSet);

}

Location: ColumnFamilyStore.java

Content: 

public TableStreamManager getStreamManager(){

  return streamManager;

}

Location: ColumnFamilyStore.java

Content: 

public static String getTableMBeanName(String ks,String name,boolean isIndex){

  return String.format("org.apache.cassandra.db:type=%s,keyspace=%s,table=%s",isIndex ? "IndexTables" : "Tables",ks,name);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Package protected for access from the CompactionManager.

 */

public Tracker getTracker(){

  return data;

}

Location: ColumnFamilyStore.java

Content: 

public Iterable<SSTableReader> getUncompactingSSTables(){

  return data.getUncompacting();

}

Location: ColumnFamilyStore.java

Content: 

Descriptor getUniqueDescriptorFor(Descriptor descriptor,File targetDirectory){

  Descriptor newDescriptor;

  do {

    newDescriptor=new Descriptor(descriptor.version,targetDirectory,descriptor.ksname,descriptor.cfname,fileIndexGenerator.incrementAndGet(),descriptor.formatType);

  }

 while (new File(newDescriptor.filenameFor(Component.DATA)).exists());

  return newDescriptor;

}

Location: ColumnFamilyStore.java

Content: 

public void invalidateCachedPartition(DecoratedKey key){

  if (!isRowCacheEnabled())   return;

  invalidateCachedPartition(new RowCacheKey(metadata(),key));

}

Location: ColumnFamilyStore.java

Content: 

public void invalidateCachedPartition(RowCacheKey key){

  CacheService.instance.rowCache.remove(key);

}

Location: ColumnFamilyStore.java

Content: 

private void invalidateCaches(){

  CacheService.instance.invalidateKeyCacheForCf(metadata());

  CacheService.instance.invalidateRowCacheForCf(metadata());

  if (metadata().isCounter())   CacheService.instance.invalidateCounterCacheForCf(metadata());

}

Location: ColumnFamilyStore.java

Content: 

public int invalidateCounterCache(Collection<Bounds<Token>> boundsToInvalidate){

  int invalidatedKeys=0;

  for (Iterator<CounterCacheKey> keyIter=CacheService.instance.counterCache.keyIterator(); keyIter.hasNext(); ) {

    CounterCacheKey key=keyIter.next();

    DecoratedKey dk=decorateKey(key.partitionKey());

    if (key.sameTable(metadata()) && Bounds.isInBounds(dk.getToken(),boundsToInvalidate)) {

      CacheService.instance.counterCache.remove(key);

      invalidatedKeys++;

    }

  }

  return invalidatedKeys;

}

Location: ColumnFamilyStore.java

Content: 

public void invalidateDiskBoundaries(){

  diskBoundaryManager.invalidate();

}

Location: ColumnFamilyStore.java

Content: 

public int invalidateRowCache(Collection<Bounds<Token>> boundsToInvalidate){

  int invalidatedKeys=0;

  for (Iterator<RowCacheKey> keyIter=CacheService.instance.rowCache.keyIterator(); keyIter.hasNext(); ) {

    RowCacheKey key=keyIter.next();

    DecoratedKey dk=decorateKey(ByteBuffer.wrap(key.key));

    if (key.sameTable(metadata()) && Bounds.isInBounds(dk.getToken(),boundsToInvalidate)) {

      invalidateCachedPartition(dk);

      invalidatedKeys++;

    }

  }

  return invalidatedKeys;

}

Location: ColumnFamilyStore.java

Content: 

public void invalidate(boolean expectMBean){

  valid=false;

  try {

    unregisterMBean();

  }

 catch (  Exception e) {

    if (expectMBean) {

      JVMStabilityInspector.inspectThrowable(e);

      logger.warn("Failed unregistering mbean: {}",mbeanName,e);

    }

  }

  compactionStrategyManager.shutdown();

  SystemKeyspace.removeTruncationRecord(metadata.id);

  data.dropSSTables();

  LifecycleTransaction.waitForDeletions();

  indexManager.dropAllIndexes();

  invalidateCaches();

}

Location: ColumnFamilyStore.java

Content: 

public boolean isCounterCacheEnabled(){

  return metadata().isCounter() && CacheService.instance.counterCache.getCapacity() > 0;

}

Location: ColumnFamilyStore.java

Content: 

public boolean isFilterFullyCoveredBy(ClusteringIndexFilter filter,DataLimits limits,CachedPartition cached,int nowInSec,boolean enforceStrictLiveness){

  if (cached.cachedLiveRows() < metadata().params.caching.rowsPerPartitionToCache())   return true;

  return (filter.isHeadFilter() && limits.hasEnoughLiveData(cached,nowInSec,filter.selectsAllPartition(),enforceStrictLiveness)) || filter.isFullyCoveredBy(cached);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * true if this CFS contains secondary index data 

 */

public boolean isIndex(){

  return metadata().isIndex();

}

Location: ColumnFamilyStore.java

Content: 

public boolean isRowCacheEnabled(){

  boolean retval=metadata().params.caching.cacheRows() && CacheService.instance.rowCache.getCapacity() > 0;

  assert (!retval || !isIndex());

  return retval;

}

Location: ColumnFamilyStore.java

Content: 

public Iterable<DecoratedKey> keySamples(Range<Token> range){

  try (RefViewFragment view=selectAndReference(View.selectFunction(SSTableSet.CANONICAL))){

    Iterable<DecoratedKey>[] samples=new Iterable[view.sstables.size()];

    int i=0;

    for (    SSTableReader sstable : view.sstables) {

      samples[i++]=sstable.getKeySamples(range);

    }

    return Iterables.concat(samples);

  }

 }

Location: ColumnFamilyStore.java

Content: 

/** 

 * See # {@code StorageService.importNewSSTables} for more info

 * @param ksName The keyspace name

 * @param cfName The columnFamily name

 */

public static void loadNewSSTables(String ksName,String cfName){

  Keyspace keyspace=Keyspace.open(ksName);

  keyspace.getColumnFamilyStore(cfName).loadNewSSTables();

}

Location: ColumnFamilyStore.java

Content: 

public LifecycleTransaction markAllCompacting(final OperationType operationType){

  Callable<LifecycleTransaction> callable=new Callable<LifecycleTransaction>(){

    public LifecycleTransaction call(){

      assert data.getCompacting().isEmpty() : data.getCompacting();

      Iterable<SSTableReader> sstables=getLiveSSTables();

      sstables=AbstractCompactionStrategy.filterSuspectSSTables(sstables);

      LifecycleTransaction modifier=data.tryModify(sstables,operationType);

      assert modifier != null : "something marked things compacting while compactions are disabled";

      return modifier;

    }

  }

;

  return runWithCompactionsDisabled(callable,false,false);

}

Location: ColumnFamilyStore.java

Content: 

public void markObsolete(Collection<SSTableReader> sstables,OperationType compactionType){

  assert !sstables.isEmpty();

  maybeFail(data.dropSSTables(Predicates.in(sstables),compactionType,null));

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Removes every SSTable in the directory from the Tracker's view.

 * @param directory the unreadable directory, possibly with SSTables in it, but not necessarily.

 */

void maybeRemoveUnreadableSSTables(File directory){

  data.removeUnreadableSSTables(directory);

}

Location: ColumnFamilyStore.java

Content: 

public static TableMetrics metricsFor(TableId tableId){

  return getIfExists(tableId).metric;

}

Location: ColumnFamilyStore.java

Content: 

public Descriptor newSSTableDescriptor(File directory){

  return newSSTableDescriptor(directory,SSTableFormat.Type.current().info.getLatestVersion(),SSTableFormat.Type.current());

}

Location: ColumnFamilyStore.java

Content: 

public Descriptor newSSTableDescriptor(File directory,SSTableFormat.Type format){

  return newSSTableDescriptor(directory,format.info.getLatestVersion(),format);

}

Location: ColumnFamilyStore.java

Content: 

public Descriptor newSSTableDescriptor(File directory,Version version,SSTableFormat.Type format){

  return new Descriptor(version,directory,keyspace.getName(),name,fileIndexGenerator.incrementAndGet(),format);

}

Location: ColumnFamilyStore.java

Content: 

private static CompactionManager.CompactionPauser pauseCompactionStrategies(Iterable<ColumnFamilyStore> toPause){

  ArrayList<ColumnFamilyStore> successfullyPaused=new ArrayList<>();

  try {

    for (    ColumnFamilyStore cfs : toPause) {

      successfullyPaused.ensureCapacity(successfullyPaused.size() + 1);

      cfs.getCompactionStrategyManager().pause();

      successfullyPaused.add(cfs);

    }

    return () -> maybeFail(resumeAll(null,toPause));

  }

 catch (  Throwable t) {

    resumeAll(t,successfullyPaused);

    throw t;

  }

}

Location: ColumnFamilyStore.java

Content: 

public void putCachedCounter(ByteBuffer partitionKey,Clustering<?> clustering,ColumnMetadata column,CellPath path,ClockAndCount clockAndCount){

  if (CacheService.instance.counterCache.getCapacity() == 0L)   return;

  CacheService.instance.counterCache.put(CounterCacheKey.create(metadata(),partitionKey,clustering,column,path),clockAndCount);

}

Location: ColumnFamilyStore.java

Content: 

private static String ratio(float onHeap,float offHeap){

  return String.format("%.2f/%.2f",onHeap,offHeap);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * CASSANDRA-5174 : For an index cfs we may be able to discard everything and just rebuild the index when a scrub fails.

 * @return true if we are an index cfs and we successfully rebuilt the index

 */

public boolean rebuildOnFailedScrub(Throwable failure){

  if (!isIndex() || !SecondaryIndexManager.isIndexColumnFamilyStore(this))   return false;

  truncateBlocking();

  logger.warn("Rebuilding index for {} because of <{}>",name,failure.getMessage());

  ColumnFamilyStore parentCfs=SecondaryIndexManager.getParentCfs(this);

  assert parentCfs.indexManager.getAllIndexColumnFamilyStores().contains(this);

  String indexName=SecondaryIndexManager.getIndexName(this);

  parentCfs.rebuildSecondaryIndex(indexName);

  return true;

}

Location: ColumnFamilyStore.java

Content: 

public void rebuildSecondaryIndex(String idxName){

  rebuildSecondaryIndex(keyspace.getName(),metadata.name,idxName);

}

Location: ColumnFamilyStore.java

Content: 

public static void rebuildSecondaryIndex(String ksName,String cfName,String... idxNames){

  ColumnFamilyStore cfs=Keyspace.open(ksName).getColumnFamilyStore(cfName);

  logger.info("User Requested secondary index re-build for {}/{} indexes: {}",ksName,cfName,Joiner.on(',').join(idxNames));

  cfs.indexManager.rebuildIndexesBlocking(Sets.newHashSet(Arrays.asList(idxNames)));

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * promotes (or demotes) data attached to an incremental repair session that has either completed successfully, or failed

 * @return session ids whose data could not be released

 */

public CleanupSummary releaseRepairData(Collection<UUID> sessions,boolean force){

  if (force) {

    Predicate<SSTableReader> predicate=sst -> {

      UUID session=sst.getPendingRepair();

      return session != null && sessions.contains(session);

    }

;

    return runWithCompactionsDisabled(() -> compactionStrategyManager.releaseRepairData(sessions),predicate,false,true,true);

  }

 else {

    return compactionStrategyManager.releaseRepairData(sessions);

  }

}

Location: ColumnFamilyStore.java

Content: 

public CompactionManager.AllSSTableOpStatus relocateSSTables(int jobs) throws ExecutionException, InterruptedException {

  return CompactionManager.instance.relocateSSTables(this,jobs);

}

Location: ColumnFamilyStore.java

Content: 

void replaceFlushed(Memtable memtable,Collection<SSTableReader> sstables){

  data.replaceFlushed(memtable,sstables);

  if (sstables != null && !sstables.isEmpty())   CompactionManager.instance.submitBackground(this);

}

Location: ColumnFamilyStore.java

Content: 

private static Throwable resumeAll(Throwable accumulate,Iterable<ColumnFamilyStore> cfss){

  for (  ColumnFamilyStore cfs : cfss) {

    try {

      cfs.getCompactionStrategyManager().resume();

    }

 catch (    Throwable t) {

      accumulate=merge(accumulate,t);

    }

  }

  return accumulate;

}

Location: ColumnFamilyStore.java

Content: 

public <V>V runWithCompactionsDisabled(Callable<V> callable,boolean interruptValidation,boolean interruptViews){

  return runWithCompactionsDisabled(callable,(sstable) -> true,interruptValidation,interruptViews,true);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Runs callable with compactions paused and compactions including sstables matching sstablePredicate stopped

 * @param callable what to do when compactions are paused

 * @param sstablesPredicate which sstables should we cancel compactions for

 * @param interruptValidation if we should interrupt validation compactions

 * @param interruptViews if we should interrupt view compactions

 * @param interruptIndexes if we should interrupt compactions on indexes. NOTE: if you set this to true your sstablePredicatemust be able to handle LocalPartitioner sstables!

 */

public <V>V runWithCompactionsDisabled(Callable<V> callable,Predicate<SSTableReader> sstablesPredicate,boolean interruptValidation,boolean interruptViews,boolean interruptIndexes){

synchronized (this) {

    logger.trace("Cancelling in-progress compactions for {}",metadata.name);

    Iterable<ColumnFamilyStore> toInterruptFor=interruptIndexes ? concatWithIndexes() : Collections.singleton(this);

    toInterruptFor=interruptViews ? Iterables.concat(toInterruptFor,viewManager.allViewsCfs()) : toInterruptFor;

    try (CompactionManager.CompactionPauser pause=CompactionManager.instance.pauseGlobalCompaction();CompactionManager.CompactionPauser pausedStrategies=pauseCompactionStrategies(toInterruptFor)){

      CompactionManager.instance.interruptCompactionForCFs(toInterruptFor,sstablesPredicate,interruptValidation);

      CompactionManager.instance.waitForCessation(toInterruptFor,sstablesPredicate);

      for (      ColumnFamilyStore cfs : toInterruptFor) {

        if (cfs.getTracker().getCompacting().stream().anyMatch(sstablesPredicate)) {

          logger.warn("Unable to cancel in-progress compactions for {}.  Perhaps there is an unusually large row in progress somewhere, or the system is simply overloaded.",metadata.name);

          return null;

        }

      }

      logger.trace("Compactions successfully cancelled");

      try {

        return callable.call();

      }

 catch (      Exception e) {

        throw new RuntimeException(e);

      }

    }

   }

}

Location: ColumnFamilyStore.java

Content: 

void scheduleFlush(){

  int period=metadata().params.memtableFlushPeriodInMs;

  if (period > 0) {

    logger.trace("scheduling flush in {} ms",period);

    WrappedRunnable runnable=new WrappedRunnable(){

      protected void runMayThrow(){

synchronized (data) {

          Memtable current=data.getView().getCurrentMemtable();

          if (current.isExpired()) {

            if (current.isClean()) {

              scheduleFlush();

            }

 else {

              forceFlush();

            }

          }

        }

      }

    }

;

    ScheduledExecutors.scheduledTasks.schedule(runnable,period,TimeUnit.MILLISECONDS);

  }

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Removes unnecessary files from the cf directory at startup: these include temp files, orphans, zero-length files and compacted sstables. Files that cannot be recognized will be ignored.

 */

public static void scrubDataDirectories(TableMetadata metadata) throws StartupException {

  Directories directories=new Directories(metadata);

  Set<File> cleanedDirectories=new HashSet<>();

  clearEphemeralSnapshots(directories);

  directories.removeTemporaryDirectories();

  logger.trace("Removing temporary or obsoleted files from unfinished operations for table {}",metadata.name);

  if (!LifecycleTransaction.removeUnfinishedLeftovers(metadata))   throw new StartupException(StartupException.ERR_WRONG_DISK_STATE,String.format("Cannot remove temporary or obsoleted files for %s due to a problem with transaction " + "log files. Please check records with problems in the log messages above and fix them. " + "Refer to the 3.0 upgrading instructions in NEWS.txt "+ "for a description of transaction log files.",metadata.toString()));

  logger.trace("Further extra check for orphan sstable files for {}",metadata.name);

  for (  Map.Entry<Descriptor,Set<Component>> sstableFiles : directories.sstableLister(Directories.OnTxnErr.IGNORE).list().entrySet()) {

    Descriptor desc=sstableFiles.getKey();

    File directory=desc.directory;

    Set<Component> components=sstableFiles.getValue();

    if (!cleanedDirectories.contains(directory)) {

      cleanedDirectories.add(directory);

      for (      File tmpFile : desc.getTemporaryFiles()) {

        logger.info("Removing unfinished temporary file {}",tmpFile);

        tmpFile.delete();

      }

    }

    File dataFile=new File(desc.filenameFor(Component.DATA));

    if (components.contains(Component.DATA) && dataFile.length() > 0)     continue;

    logger.warn("Removing orphans for {}: {}",desc,components);

    for (    Component component : components) {

      File file=new File(desc.filenameFor(component));

      if (file.exists())       FileUtils.deleteWithConfirm(desc.filenameFor(component));

    }

  }

  Pattern tmpCacheFilePattern=Pattern.compile(metadata.keyspace + "-" + metadata.name+ "-(Key|Row)Cache.*\\.tmp$");

  File dir=new File(DatabaseDescriptor.getSavedCachesLocation());

  if (dir.exists()) {

    assert dir.isDirectory();

    for (    File file : dir.listFiles())     if (tmpCacheFilePattern.matcher(file.getName()).matches())     if (!file.delete())     logger.warn("could not delete {}",file.getAbsolutePath());

  }

  for (  IndexMetadata index : metadata.indexes)   if (!index.isCustom()) {

    TableMetadata indexMetadata=CassandraIndex.indexCfsMetadata(metadata,index);

    scrubDataDirectories(indexMetadata);

  }

}

Location: ColumnFamilyStore.java

Content: 

@VisibleForTesting public CompactionManager.AllSSTableOpStatus scrub(boolean disableSnapshot,boolean skipCorrupted,boolean reinsertOverflowedTTL,boolean alwaysFail,boolean checkData,int jobs) throws ExecutionException, InterruptedException {

  if (!disableSnapshot)   snapshotWithoutFlush("pre-scrub-" + System.currentTimeMillis());

  try {

    return CompactionManager.instance.performScrub(ColumnFamilyStore.this,skipCorrupted,checkData,reinsertOverflowedTTL,jobs);

  }

 catch (  Throwable t) {

    if (!rebuildOnFailedScrub(t))     throw t;

    return alwaysFail ? CompactionManager.AllSSTableOpStatus.ABORTED : CompactionManager.AllSSTableOpStatus.SUCCESSFUL;

  }

}

Location: ColumnFamilyStore.java

Content: 

public CompactionManager.AllSSTableOpStatus scrub(boolean disableSnapshot,boolean skipCorrupted,boolean checkData,boolean reinsertOverflowedTTL,int jobs) throws ExecutionException, InterruptedException {

  return scrub(disableSnapshot,skipCorrupted,reinsertOverflowedTTL,false,checkData,jobs);

}

Location: ColumnFamilyStore.java

Content: 

@SuppressWarnings("resource") public RefViewFragment selectAndReference(Function<View,Iterable<SSTableReader>> filter){

  long failingSince=-1L;

  while (true) {

    ViewFragment view=select(filter);

    Refs<SSTableReader> refs=Refs.tryRef(view.sstables);

    if (refs != null)     return new RefViewFragment(view.sstables,view.memtables,refs);

    if (failingSince <= 0) {

      failingSince=System.nanoTime();

    }

 else     if (System.nanoTime() - failingSince > TimeUnit.MILLISECONDS.toNanos(100)) {

      List<SSTableReader> released=new ArrayList<>();

      for (      SSTableReader reader : view.sstables)       if (reader.selfRef().globalCount() == 0)       released.add(reader);

      NoSpamLogger.log(logger,NoSpamLogger.Level.WARN,1,TimeUnit.SECONDS,"Spinning trying to capture readers {}, released: {}, ",view.sstables,released);

      failingSince=System.nanoTime();

    }

  }

}

Location: ColumnFamilyStore.java

Content: 

public ViewFragment select(Function<View,Iterable<SSTableReader>> filter){

  View view=data.getView();

  List<SSTableReader> sstables=Lists.newArrayList(filter.apply(view));

  return new ViewFragment(sstables,view.getAllMemtables());

}

Location: ColumnFamilyStore.java

Content: 

private static void setCommitLogUpperBound(AtomicReference<CommitLogPosition> commitLogUpperBound){

  CommitLogPosition lastReplayPosition;

  while (true) {

    lastReplayPosition=new Memtable.LastCommitLogPosition((CommitLog.instance.getCurrentPosition()));

    CommitLogPosition currentLast=commitLogUpperBound.get();

    if ((currentLast == null || currentLast.compareTo(lastReplayPosition) <= 0) && commitLogUpperBound.compareAndSet(currentLast,lastReplayPosition))     break;

  }

}

Location: ColumnFamilyStore.java

Content: 

public static void shutdownExecutorsAndWait(long timeout,TimeUnit unit) throws InterruptedException, TimeoutException {

  List<ExecutorService> executors=new ArrayList<>(perDiskflushExecutors.length + 3);

  Collections.addAll(executors,reclaimExecutor,postFlushExecutor,flushExecutor);

  Collections.addAll(executors,perDiskflushExecutors);

  ExecutorUtils.shutdownAndWait(timeout,unit,executors);

}

Location: ColumnFamilyStore.java

Content: 

public static void shutdownPostFlushExecutor() throws InterruptedException {

  postFlushExecutor.shutdown();

  postFlushExecutor.awaitTermination(60,TimeUnit.SECONDS);

}

Location: ColumnFamilyStore.java

Content: 

public void snapshotWithoutFlush(String snapshotName){

  snapshotWithoutFlush(snapshotName,null,false,null);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * @param ephemeral If this flag is set to true, the snapshot will be cleaned during next startup

 */

public Set<SSTableReader> snapshotWithoutFlush(String snapshotName,Predicate<SSTableReader> predicate,boolean ephemeral,RateLimiter rateLimiter){

  if (rateLimiter == null)   rateLimiter=DatabaseDescriptor.getSnapshotRateLimiter();

  Set<SSTableReader> snapshottedSSTables=new HashSet<>();

  final JSONArray filesJSONArr=new JSONArray();

  for (  ColumnFamilyStore cfs : concatWithIndexes()) {

    try (RefViewFragment currentView=cfs.selectAndReference(View.select(SSTableSet.CANONICAL,(x) -> predicate == null || predicate.apply(x)))){

      for (      SSTableReader ssTable : currentView.sstables) {

        File snapshotDirectory=Directories.getSnapshotDirectory(ssTable.descriptor,snapshotName);

        rateLimiter.acquire(SSTableReader.componentsFor(ssTable.descriptor).size());

        ssTable.createLinks(snapshotDirectory.getPath());

        filesJSONArr.add(ssTable.descriptor.relativeFilenameFor(Component.DATA));

        if (logger.isTraceEnabled())         logger.trace("Snapshot for {} keyspace data file {} created in {}",keyspace,ssTable.getFilename(),snapshotDirectory);

        snapshottedSSTables.add(ssTable);

      }

    }

   }

  writeSnapshotManifest(filesJSONArr,snapshotName);

  if (!SchemaConstants.isLocalSystemKeyspace(metadata.keyspace) && !SchemaConstants.isReplicatedSystemKeyspace(metadata.keyspace))   writeSnapshotSchema(snapshotName);

  if (ephemeral)   createEphemeralSnapshotMarkerFile(snapshotName);

  return snapshottedSSTables;

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Take a snap shot of this columnfamily store.

 * @param snapshotName the name of the associated with the snapshot

 */

public Set<SSTableReader> snapshot(String snapshotName){

  return snapshot(snapshotName,false,null);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Take a snap shot of this columnfamily store.

 * @param snapshotName the name of the associated with the snapshot

 * @param skipFlush Skip blocking flush of memtable

 * @param rateLimiter Rate limiter for hardlinks-per-second

 */

public Set<SSTableReader> snapshot(String snapshotName,boolean skipFlush,RateLimiter rateLimiter){

  return snapshot(snapshotName,null,false,skipFlush,rateLimiter);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * @param ephemeral If this flag is set to true, the snapshot will be cleaned up during next startup

 * @param skipFlush Skip blocking flush of memtable

 */

public Set<SSTableReader> snapshot(String snapshotName,Predicate<SSTableReader> predicate,boolean ephemeral,boolean skipFlush){

  return snapshot(snapshotName,predicate,ephemeral,skipFlush,null);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * @param ephemeral If this flag is set to true, the snapshot will be cleaned up during next startup

 * @param skipFlush Skip blocking flush of memtable

 * @param rateLimiter Rate limiter for hardlinks-per-second

 */

public Set<SSTableReader> snapshot(String snapshotName,Predicate<SSTableReader> predicate,boolean ephemeral,boolean skipFlush,RateLimiter rateLimiter){

  if (!skipFlush) {

    forceBlockingFlush();

  }

  return snapshotWithoutFlush(snapshotName,predicate,ephemeral,rateLimiter);

}

Location: ColumnFamilyStore.java

Content: 

public CompactionManager.AllSSTableOpStatus sstablesRewrite(boolean excludeCurrentVersion,int jobs) throws ExecutionException, InterruptedException {

  return CompactionManager.instance.performSSTableRewrite(ColumnFamilyStore.this,excludeCurrentVersion,jobs);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Switches the memtable iff the live memtable is the one provided

 * @param memtable

 */

public ListenableFuture<CommitLogPosition> switchMemtableIfCurrent(Memtable memtable){

synchronized (data) {

    if (data.getView().getCurrentMemtable() == memtable)     return switchMemtable();

  }

  return waitForFlushes();

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * Truncate deletes the entire column family's data with no expensive tombstone creation

 */

public void truncateBlocking(){

  logger.info("Truncating {}.{}",keyspace.getName(),name);

  final long truncatedAt;

  final CommitLogPosition replayAfter;

  if (keyspace.getMetadata().params.durableWrites || DatabaseDescriptor.isAutoSnapshot()) {

    replayAfter=forceBlockingFlush();

    viewManager.forceBlockingFlush();

  }

 else {

    viewManager.dumpMemtables();

    try {

      replayAfter=dumpMemtable().get();

    }

 catch (    Exception e) {

      throw new RuntimeException(e);

    }

  }

  long now=System.currentTimeMillis();

  for (  ColumnFamilyStore cfs : concatWithIndexes())   for (  SSTableReader sstable : cfs.getLiveSSTables())   now=Math.max(now,sstable.maxDataAge);

  truncatedAt=now;

  Runnable truncateRunnable=new Runnable(){

    public void run(){

      logger.info("Truncating {}.{} with truncatedAt={}",keyspace.getName(),getTableName(),truncatedAt);

      ActiveRepairService.instance.abort((prs) -> prs.getTableIds().contains(metadata.id),"Stopping parent sessions {} due to truncation of tableId=" + metadata.id);

      data.notifyTruncated(truncatedAt);

      if (DatabaseDescriptor.isAutoSnapshot())       snapshot(Keyspace.getTimestampedSnapshotNameWithPrefix(name,SNAPSHOT_TRUNCATE_PREFIX));

      discardSSTables(truncatedAt);

      indexManager.truncateAllIndexesBlocking(truncatedAt);

      viewManager.truncateBlocking(replayAfter,truncatedAt);

      SystemKeyspace.saveTruncationRecord(ColumnFamilyStore.this,truncatedAt,replayAfter);

      logger.trace("cleaning out row cache");

      invalidateCaches();

    }

  }

;

  runWithCompactionsDisabled(Executors.callable(truncateRunnable),true,true);

  logger.info("Truncate of {}.{} is complete",keyspace.getName(),name);

}

Location: ColumnFamilyStore.java

Content: 

void unregisterMBean() throws MalformedObjectNameException {

  ObjectName[] objectNames={new ObjectName(mbeanName),new ObjectName(oldMBeanName)};

  for (  ObjectName objectName : objectNames) {

    if (MBeanWrapper.instance.isRegistered(objectName))     MBeanWrapper.instance.unregisterMBean(objectName);

  }

  metric.release();

}

Location: ColumnFamilyStore.java

Content: 

public void updateSpeculationThreshold(){

  try {

    sampleReadLatencyNanos=metadata().params.speculativeRetry.calculateThreshold(metric.coordinatorReadLatency.getSnapshot(),sampleReadLatencyNanos);

    additionalWriteLatencyNanos=metadata().params.additionalWritePolicy.calculateThreshold(metric.coordinatorWriteLatency.getSnapshot(),additionalWriteLatencyNanos);

  }

 catch (  Throwable e) {

    logger.error("Exception caught while calculating speculative retry threshold for {}: {}",metadata(),e);

  }

}

Location: ColumnFamilyStore.java

Content: 

private void validateCompactionThresholds(int minThreshold,int maxThreshold){

  if (minThreshold > maxThreshold)   throw new RuntimeException(String.format("The min_compaction_threshold cannot be larger than the max_compaction_threshold. " + "Min is '%d', Max is '%d'.",minThreshold,maxThreshold));

  if (maxThreshold == 0 || minThreshold == 0)   throw new RuntimeException("Disabling compaction by setting min_compaction_threshold or max_compaction_threshold to 0 " + "is deprecated, set the compaction strategy option 'enabled' to 'false' instead or use the nodetool command 'disableautocompaction'.");

}

Location: ColumnFamilyStore.java

Content: 

public CompactionManager.AllSSTableOpStatus verify(Verifier.Options options) throws ExecutionException, InterruptedException {

  return CompactionManager.instance.performVerify(ColumnFamilyStore.this,options);

}

Location: ColumnFamilyStore.java

Content: 

/** 

 * @return a Future yielding the commit log position that can be guaranteed to have been successfully writtento sstables for this table once the future completes

 */

private ListenableFuture<CommitLogPosition> waitForFlushes(){

  final Memtable current=data.getView().getCurrentMemtable();

  ListenableFutureTask<CommitLogPosition> task=ListenableFutureTask.create(() -> {

    logger.debug("forceFlush requested but everything is clean in {}",name);

    return current.getCommitLogLowerBound();

  }

);

  postFlushExecutor.execute(task);

  return task;

}

Location: ColumnFamilyStore.java

Content: 

private void writeSnapshotManifest(final JSONArray filesJSONArr,final String snapshotName){

  final File manifestFile=getDirectories().getSnapshotManifestFile(snapshotName);

  try {

    if (!manifestFile.getParentFile().exists())     manifestFile.getParentFile().mkdirs();

    try (PrintStream out=new PrintStream(manifestFile)){

      final JSONObject manifestJSON=new JSONObject();

      manifestJSON.put("files",filesJSONArr);

      out.println(manifestJSON.toJSONString());

    }

   }

 catch (  IOException e) {

    throw new FSWriteError(e,manifestFile);

  }

}

Location: ColumnFamilyStore.java

Content: 

private void writeSnapshotSchema(final String snapshotName){

  final File schemaFile=getDirectories().getSnapshotSchemaFile(snapshotName);

  try {

    if (!schemaFile.getParentFile().exists())     schemaFile.getParentFile().mkdirs();

    try (PrintStream out=new PrintStream(schemaFile)){

      SchemaCQLHelper.reCreateStatementsForSchemaCql(metadata(),keyspace.getMetadata().types).forEach(out::println);

    }

   }

 catch (  IOException e) {

    throw new FSWriteError(e,schemaFile);

  }

}

