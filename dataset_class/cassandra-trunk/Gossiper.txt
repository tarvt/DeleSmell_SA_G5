Location: Gossiper.java

Content: 

public void addExpireTimeForEndpoint(InetAddressAndPort endpoint,long expireTime){

  if (logger.isDebugEnabled()) {

    logger.debug("adding expire time for endpoint : {} ({})",endpoint,expireTime);

  }

  expireTimeEndpointMap.put(endpoint,expireTime);

}

Location: Gossiper.java

Content: 

private void addLocalApplicationStateInternal(ApplicationState state,VersionedValue value){

  assert taskLock.isHeldByCurrentThread();

  InetAddressAndPort epAddr=FBUtilities.getBroadcastAddressAndPort();

  EndpointState epState=endpointStateMap.get(epAddr);

  assert epState != null : "Can't find endpoint state for " + epAddr;

  doBeforeChangeNotifications(epAddr,epState,state,value);

  value=StorageService.instance.valueFactory.cloneWithHigherVersion(value);

  epState.addApplicationState(state,value);

  doOnChangeNotifications(epAddr,state,value);

}

Location: Gossiper.java

Content: 

public void addLocalApplicationStates(List<Pair<ApplicationState,VersionedValue>> states){

  taskLock.lock();

  try {

    for (    Pair<ApplicationState,VersionedValue> pair : states) {

      addLocalApplicationStateInternal(pair.left,pair.right);

    }

  }

  finally {

    taskLock.unlock();

  }

}

Location: Gossiper.java

Content: 

public void addLocalApplicationState(ApplicationState applicationState,VersionedValue value){

  addLocalApplicationStates(Arrays.asList(Pair.create(applicationState,value)));

}

Location: Gossiper.java

Content: 

/** 

 * Add an endpoint we knew about previously, but whose state is unknown

 */

public void addSavedEndpoint(InetAddressAndPort ep){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  if (ep.equals(FBUtilities.getBroadcastAddressAndPort())) {

    logger.debug("Attempt to add self as saved endpoint");

    return;

  }

  EndpointState epState=endpointStateMap.get(ep);

  if (epState != null) {

    logger.debug("not replacing a previous epState for {}, but reusing it: {}",ep,epState);

    epState.setHeartBeatState(HeartBeatState.empty());

  }

 else {

    epState=new EndpointState(HeartBeatState.empty());

    logger.info("Adding {} as there was no previous epState; new state is {}",ep,epState);

  }

  epState.markDead();

  endpointStateMap.put(ep,epState);

  silentlyMarkDead(ep,epState);

  if (logger.isTraceEnabled())   logger.trace("Adding saved endpoint {} {}",ep,epState.getHeartBeatState().getGeneration());

}

Location: Gossiper.java

Content: 

/** 

 * This method will begin removing an existing endpoint from the cluster by spoofing its state This should never be called unless this coordinator has had 'removenode' invoked

 * @param endpoint    - the endpoint being removed

 * @param hostId      - the ID of the host being removed

 * @param localHostId - my own host ID for replication coordination

 */

public void advertiseRemoving(InetAddressAndPort endpoint,UUID hostId,UUID localHostId){

  EndpointState epState=endpointStateMap.get(endpoint);

  int generation=epState.getHeartBeatState().getGeneration();

  logger.info("Removing host: {}",hostId);

  logger.info("Sleeping for {}ms to ensure {} does not change",StorageService.RING_DELAY,endpoint);

  Uninterruptibles.sleepUninterruptibly(StorageService.RING_DELAY,TimeUnit.MILLISECONDS);

  epState=endpointStateMap.get(endpoint);

  if (epState.getHeartBeatState().getGeneration() != generation)   throw new RuntimeException("Endpoint " + endpoint + " generation changed while trying to remove it");

  logger.info("Advertising removal for {}",endpoint);

  epState.updateTimestamp();

  epState.getHeartBeatState().forceNewerGenerationUnsafe();

  Map<ApplicationState,VersionedValue> states=new EnumMap<>(ApplicationState.class);

  states.put(ApplicationState.STATUS_WITH_PORT,StorageService.instance.valueFactory.removingNonlocal(hostId));

  states.put(ApplicationState.STATUS,StorageService.instance.valueFactory.removingNonlocal(hostId));

  states.put(ApplicationState.REMOVAL_COORDINATOR,StorageService.instance.valueFactory.removalCoordinator(localHostId));

  epState.addApplicationStates(states);

  endpointStateMap.put(endpoint,epState);

}

Location: Gossiper.java

Content: 

/** 

 * Handles switching the endpoint's state from REMOVING_TOKEN to REMOVED_TOKEN This should only be called after advertiseRemoving

 * @param endpoint

 * @param hostId

 */

public void advertiseTokenRemoved(InetAddressAndPort endpoint,UUID hostId){

  EndpointState epState=endpointStateMap.get(endpoint);

  epState.updateTimestamp();

  epState.getHeartBeatState().forceNewerGenerationUnsafe();

  long expireTime=computeExpireTime();

  epState.addApplicationState(ApplicationState.STATUS_WITH_PORT,StorageService.instance.valueFactory.removedNonlocal(hostId,expireTime));

  epState.addApplicationState(ApplicationState.STATUS,StorageService.instance.valueFactory.removedNonlocal(hostId,expireTime));

  logger.info("Completing removal of {}",endpoint);

  addExpireTimeForEndpoint(endpoint,expireTime);

  endpointStateMap.put(endpoint,epState);

  Uninterruptibles.sleepUninterruptibly(intervalInMillis * 2,TimeUnit.MILLISECONDS);

}

Location: Gossiper.java

Content: 

private void applyNewStates(InetAddressAndPort addr,EndpointState localState,EndpointState remoteState){

  int oldVersion=localState.getHeartBeatState().getHeartBeatVersion();

  localState.setHeartBeatState(remoteState.getHeartBeatState());

  if (logger.isTraceEnabled())   logger.trace("Updating heartbeat state version to {} from {} for {} ...",localState.getHeartBeatState().getHeartBeatVersion(),oldVersion,addr);

  Set<Entry<ApplicationState,VersionedValue>> remoteStates=remoteState.states();

  assert remoteState.getHeartBeatState().getGeneration() == localState.getHeartBeatState().getGeneration();

  Set<Entry<ApplicationState,VersionedValue>> updatedStates=remoteStates.stream().filter(entry -> {

switch (entry.getKey()) {

case INTERNAL_IP:

      if (remoteState.getApplicationState(ApplicationState.INTERNAL_ADDRESS_AND_PORT) != null)       return false;

    break;

case STATUS:

  if (remoteState.getApplicationState(ApplicationState.STATUS_WITH_PORT) != null)   return false;

break;

case RPC_ADDRESS:

if (remoteState.getApplicationState(ApplicationState.NATIVE_ADDRESS_AND_PORT) != null) return false;

break;

default :

break;

}

VersionedValue local=localState.getApplicationState(entry.getKey());

return (local == null || local.version < entry.getValue().version);

}

).collect(Collectors.toSet());

if (logger.isTraceEnabled() && updatedStates.size() > 0) {

for (Entry<ApplicationState,VersionedValue> entry : updatedStates) {

logger.trace("Updating {} state version to {} for {}",entry.getKey().toString(),entry.getValue().version,addr);

}

}

localState.addApplicationStates(updatedStates);

for (Entry<ApplicationState,VersionedValue> updatedEntry : updatedStates) doOnChangeNotifications(addr,updatedEntry.getKey(),updatedEntry.getValue());

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void applyStateLocally(Map<InetAddressAndPort,EndpointState> epStateMap){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  for (  Entry<InetAddressAndPort,EndpointState> entry : epStateMap.entrySet()) {

    InetAddressAndPort ep=entry.getKey();

    if (ep.equals(FBUtilities.getBroadcastAddressAndPort()) && !isInShadowRound())     continue;

    if (justRemovedEndpoints.containsKey(ep)) {

      if (logger.isTraceEnabled())       logger.trace("Ignoring gossip for {} because it is quarantined",ep);

      continue;

    }

    EndpointState localEpStatePtr=endpointStateMap.get(ep);

    EndpointState remoteState=entry.getValue();

    if (localEpStatePtr != null) {

      int localGeneration=localEpStatePtr.getHeartBeatState().getGeneration();

      int remoteGeneration=remoteState.getHeartBeatState().getGeneration();

      long localTime=System.currentTimeMillis() / 1000;

      if (logger.isTraceEnabled())       logger.trace("{} local generation {}, remote generation {}",ep,localGeneration,remoteGeneration);

      if (remoteGeneration > localTime + MAX_GENERATION_DIFFERENCE) {

        logger.warn("received an invalid gossip generation for peer {}; local time = {}, received generation = {}",ep,localTime,remoteGeneration);

      }

 else       if (remoteGeneration > localGeneration) {

        if (logger.isTraceEnabled())         logger.trace("Updating heartbeat state generation to {} from {} for {}",remoteGeneration,localGeneration,ep);

        handleMajorStateChange(ep,remoteState);

      }

 else       if (remoteGeneration == localGeneration) {

        int localMaxVersion=getMaxEndpointStateVersion(localEpStatePtr);

        int remoteMaxVersion=getMaxEndpointStateVersion(remoteState);

        if (remoteMaxVersion > localMaxVersion) {

          applyNewStates(ep,localEpStatePtr,remoteState);

        }

 else         if (logger.isTraceEnabled())         logger.trace("Ignoring remote version {} <= {} for {}",remoteMaxVersion,localMaxVersion,ep);

        if (!localEpStatePtr.isAlive() && !isDeadState(localEpStatePtr))         markAlive(ep,localEpStatePtr);

      }

 else {

        if (logger.isTraceEnabled())         logger.trace("Ignoring remote generation {} < {}",remoteGeneration,localGeneration);

      }

    }

 else {

      FailureDetector.instance.report(ep);

      handleMajorStateChange(ep,remoteState);

    }

  }

}

Location: Gossiper.java

Content: 

@VisibleForTesting void buildSeedsList(){

  for (  InetAddressAndPort seed : DatabaseDescriptor.getSeeds()) {

    if (seed.equals(FBUtilities.getBroadcastAddressAndPort()))     continue;

    seeds.add(seed);

  }

}

Location: Gossiper.java

Content: 

/** 

 * determine which endpoint started up earlier

 */

public int compareEndpointStartup(InetAddressAndPort addr1,InetAddressAndPort addr2){

  EndpointState ep1=getEndpointStateForEndpoint(addr1);

  EndpointState ep2=getEndpointStateForEndpoint(addr2);

  assert ep1 != null && ep2 != null;

  return ep1.getHeartBeatState().getGeneration() - ep2.getHeartBeatState().getGeneration();

}

Location: Gossiper.java

Content: 

public static long computeExpireTime(){

  return System.currentTimeMillis() + Gossiper.aVeryLongTime;

}

Location: Gossiper.java

Content: 

private void doBeforeChangeNotifications(InetAddressAndPort addr,EndpointState epState,ApplicationState apState,VersionedValue newValue){

  for (  IEndpointStateChangeSubscriber subscriber : subscribers) {

    subscriber.beforeChange(addr,epState,apState,newValue);

  }

}

Location: Gossiper.java

Content: 

private boolean doGossipToLiveMember(Message<GossipDigestSyn> message){

  int size=liveEndpoints.size();

  if (size == 0)   return false;

  return sendGossip(message,liveEndpoints);

}

Location: Gossiper.java

Content: 

private void doOnChangeNotifications(InetAddressAndPort addr,ApplicationState state,VersionedValue value){

  for (  IEndpointStateChangeSubscriber subscriber : subscribers) {

    subscriber.onChange(addr,state,value);

  }

}

Location: Gossiper.java

Content: 

public synchronized Map<InetAddressAndPort,EndpointState> doShadowRound(){

  return doShadowRound(Collections.EMPTY_SET);

}

Location: Gossiper.java

Content: 

/** 

 * Do a single 'shadow' round of gossip by retrieving endpoint states that will be stored exclusively in the map return value, instead of endpointStateMap. Used when preparing to join the ring: <ul> <li>when replacing a node, to get and assume its tokens</li> <li>when joining, to check that the local host id matches any previous id for the endpoint address</li> </ul> Method is synchronized, as we use an in-progress flag to indicate that shadow round must be cleared again by calling  {@link Gossiper#maybeFinishShadowRound(InetAddressAndPort,boolean,Map)}. This will update {@link Gossiper#endpointShadowStateMap} with received values, in order to return an immutable copy to thecaller of  {@link Gossiper#doShadowRound()}. Therefor only a single shadow round execution is permitted at the same time.

 * @param peers Additional peers to try gossiping with.

 * @return endpoint states gathered during shadow round or empty map

 */

public synchronized Map<InetAddressAndPort,EndpointState> doShadowRound(Set<InetAddressAndPort> peers){

  buildSeedsList();

  if (seeds.isEmpty() && peers.isEmpty())   return endpointShadowStateMap;

  boolean isSeed=DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddressAndPort());

  int shadowRoundDelay=isSeed ? StorageService.RING_DELAY : StorageService.RING_DELAY * 2;

  seedsInShadowRound.clear();

  endpointShadowStateMap.clear();

  List<GossipDigest> gDigests=new ArrayList<GossipDigest>();

  GossipDigestSyn digestSynMessage=new GossipDigestSyn(DatabaseDescriptor.getClusterName(),DatabaseDescriptor.getPartitionerName(),gDigests);

  Message<GossipDigestSyn> message=Message.out(GOSSIP_DIGEST_SYN,digestSynMessage);

  inShadowRound=true;

  boolean includePeers=false;

  int slept=0;

  try {

    while (true) {

      if (slept % 5000 == 0) {

        logger.trace("Sending shadow round GOSSIP DIGEST SYN to seeds {}",seeds);

        for (        InetAddressAndPort seed : seeds)         MessagingService.instance().send(message,seed);

        if (includePeers) {

          logger.trace("Sending shadow round GOSSIP DIGEST SYN to known peers {}",peers);

          for (          InetAddressAndPort peer : peers)           MessagingService.instance().send(message,peer);

        }

        includePeers=true;

      }

      Thread.sleep(1000);

      if (!inShadowRound)       break;

      slept+=1000;

      if (slept > shadowRoundDelay) {

        if (!isSeed)         throw new RuntimeException("Unable to gossip with any peers");

        inShadowRound=false;

        break;

      }

    }

  }

 catch (  InterruptedException wtf) {

    throw new RuntimeException(wtf);

  }

  return ImmutableMap.copyOf(endpointShadowStateMap);

}

Location: Gossiper.java

Content: 

@VisibleForTesting void doStatusCheck(){

  if (logger.isTraceEnabled())   logger.trace("Performing status check ...");

  long now=System.currentTimeMillis();

  long nowNano=System.nanoTime();

  long pending=((JMXEnabledThreadPoolExecutor)Stage.GOSSIP.executor()).metrics.pendingTasks.getValue();

  if (pending > 0 && lastProcessedMessageAt < now - 1000) {

    Uninterruptibles.sleepUninterruptibly(100,TimeUnit.MILLISECONDS);

    if (lastProcessedMessageAt < now - 1000) {

      logger.warn("Gossip stage has {} pending tasks; skipping status check (no nodes will be marked down)",pending);

      return;

    }

  }

  Set<InetAddressAndPort> eps=endpointStateMap.keySet();

  for (  InetAddressAndPort endpoint : eps) {

    if (endpoint.equals(FBUtilities.getBroadcastAddressAndPort()))     continue;

    FailureDetector.instance.interpret(endpoint);

    EndpointState epState=endpointStateMap.get(endpoint);

    if (epState != null) {

      if (isGossipOnlyMember(endpoint) && !justRemovedEndpoints.containsKey(endpoint) && TimeUnit.NANOSECONDS.toMillis(nowNano - epState.getUpdateTimestamp()) > fatClientTimeout) {

        logger.info("FatClient {} has been silent for {}ms, removing from gossip",endpoint,fatClientTimeout);

        runInGossipStageBlocking(() -> {

          removeEndpoint(endpoint);

          evictFromMembership(endpoint);

        }

);

      }

      long expireTime=getExpireTimeForEndpoint(endpoint);

      if (!epState.isAlive() && (now > expireTime) && (!StorageService.instance.getTokenMetadata().isMember(endpoint))) {

        if (logger.isDebugEnabled()) {

          logger.debug("time is expiring for endpoint : {} ({})",endpoint,expireTime);

        }

        runInGossipStageBlocking(() -> evictFromMembership(endpoint));

      }

    }

  }

  if (!justRemovedEndpoints.isEmpty()) {

    for (    Entry<InetAddressAndPort,Long> entry : justRemovedEndpoints.entrySet()) {

      if ((now - entry.getValue()) > QUARANTINE_DELAY) {

        if (logger.isDebugEnabled())         logger.debug("{} elapsed, {} gossip quarantine over",QUARANTINE_DELAY,entry.getKey());

        justRemovedEndpoints.remove(entry.getKey());

      }

    }

  }

}

Location: Gossiper.java

Content: 

/** 

 * Removes the endpoint from gossip completely

 * @param endpoint endpoint to be removed from the current membership.

 */

private void evictFromMembership(InetAddressAndPort endpoint){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  unreachableEndpoints.remove(endpoint);

  endpointStateMap.remove(endpoint);

  expireTimeEndpointMap.remove(endpoint);

  FailureDetector.instance.remove(endpoint);

  quarantineEndpoint(endpoint);

  if (logger.isDebugEnabled())   logger.debug("evicting {} from gossip",endpoint);

  GossiperDiagnostics.evictedFromMembership(this,endpoint);

}

Location: Gossiper.java

Content: 

/** 

 * This method is used to figure the state that the Gossiper has but Gossipee doesn't. The delta digests and the delta state are built up. When a  {@link EndpointState} is "empty" then it is filtered out and not added to the delta state (see CASSANDRA-16213).

 */

void examineGossiper(List<GossipDigest> gDigestList,List<GossipDigest> deltaGossipDigestList,Map<InetAddressAndPort,EndpointState> deltaEpStateMap){

  assert !gDigestList.isEmpty() : "examineGossiper called with empty digest list";

  for (  GossipDigest gDigest : gDigestList) {

    int remoteGeneration=gDigest.getGeneration();

    int maxRemoteVersion=gDigest.getMaxVersion();

    EndpointState epStatePtr=endpointStateMap.get(gDigest.getEndpoint());

    if (epStatePtr != null) {

      int localGeneration=epStatePtr.getHeartBeatState().getGeneration();

      int maxLocalVersion=getMaxEndpointStateVersion(epStatePtr);

      if (remoteGeneration == localGeneration && maxRemoteVersion == maxLocalVersion)       continue;

      if (remoteGeneration > localGeneration) {

        requestAll(gDigest,deltaGossipDigestList,remoteGeneration);

      }

 else       if (remoteGeneration < localGeneration) {

        sendAll(gDigest,deltaEpStateMap,HeartBeatState.EMPTY_VERSION);

      }

 else       if (remoteGeneration == localGeneration) {

        if (maxRemoteVersion > maxLocalVersion) {

          deltaGossipDigestList.add(new GossipDigest(gDigest.getEndpoint(),remoteGeneration,maxLocalVersion));

        }

 else         if (maxRemoteVersion < maxLocalVersion) {

          sendAll(gDigest,deltaEpStateMap,maxRemoteVersion);

        }

      }

    }

 else {

      requestAll(gDigest,deltaGossipDigestList,remoteGeneration);

    }

  }

}

Location: Gossiper.java

Content: 

/** 

 * Used during a shadow round to collect the current state; this method clones the current state, no filtering is done. During the shadow round its desirable to return gossip state for remote instances that were created by this process also known as "empty", this is done for host replacement to be able to replace downed hosts that are in the ring but have no state in gossip (see CASSANDRA-16213). This method is different than  {@link #examineGossiper(List,List,Map)} with respect to how "empty" states aredealt with; they are kept.

 */

Map<InetAddressAndPort,EndpointState> examineShadowState(){

  logger.debug("Shadow request received, adding all states");

  Map<InetAddressAndPort,EndpointState> map=new HashMap<>();

  for (  Entry<InetAddressAndPort,EndpointState> e : endpointStateMap.entrySet()) {

    InetAddressAndPort endpoint=e.getKey();

    EndpointState state=new EndpointState(e.getValue());

    if (state.isEmptyWithoutStatus()) {

      UUID hostId=SystemKeyspace.loadHostIds().get(endpoint);

      if (null != hostId) {

        state.addApplicationState(ApplicationState.HOST_ID,StorageService.instance.valueFactory.hostId(hostId));

      }

      Set<Token> tokens=SystemKeyspace.loadTokens().get(endpoint);

      if (null != tokens && !tokens.isEmpty()) {

        state.addApplicationState(ApplicationState.TOKENS,StorageService.instance.valueFactory.tokens(tokens));

      }

    }

    map.put(endpoint,state);

  }

  return map;

}

Location: Gossiper.java

Content: 

public void forceNewerGeneration(){

  EndpointState epstate=endpointStateMap.get(FBUtilities.getBroadcastAddressAndPort());

  epstate.getHeartBeatState().forceNewerGenerationUnsafe();

}

Location: Gossiper.java

Content: 

public int getCurrentGenerationNumber(InetAddressAndPort endpoint){

  return endpointStateMap.get(endpoint).getHeartBeatState().getGeneration();

}

Location: Gossiper.java

Content: 

public int getEndpointCount(){

  return endpointStateMap.size();

}

Location: Gossiper.java

Content: 

public long getEndpointDowntime(InetAddressAndPort ep){

  Long downtime=unreachableEndpoints.get(ep);

  if (downtime != null)   return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - downtime);

 else   return 0L;

}

Location: Gossiper.java

Content: 

public ImmutableSet<InetAddressAndPort> getEndpoints(){

  return ImmutableSet.copyOf(endpointStateMap.keySet());

}

Location: Gossiper.java

Content: 

public EndpointState getEndpointStateForEndpoint(InetAddressAndPort ep){

  return endpointStateMap.get(ep);

}

Location: Gossiper.java

Content: 

protected long getExpireTimeForEndpoint(InetAddressAndPort endpoint){

  Long storedTime=expireTimeEndpointMap.get(endpoint);

  return storedTime == null ? computeExpireTime() : storedTime;

}

Location: Gossiper.java

Content: 

private static String getGossipStatus(EndpointState epState){

  if (epState == null) {

    return "";

  }

  VersionedValue versionedValue=epState.getApplicationState(ApplicationState.STATUS_WITH_PORT);

  if (versionedValue == null) {

    versionedValue=epState.getApplicationState(ApplicationState.STATUS);

    if (versionedValue == null) {

      return "";

    }

  }

  String value=versionedValue.value;

  String[] pieces=value.split(VersionedValue.DELIMITER_STR,-1);

  assert (pieces.length > 0);

  return pieces[0];

}

Location: Gossiper.java

Content: 

public UUID getHostId(InetAddressAndPort endpoint,Map<InetAddressAndPort,EndpointState> epStates){

  return UUID.fromString(epStates.get(endpoint).getApplicationState(ApplicationState.HOST_ID).value);

}

Location: Gossiper.java

Content: 

Map<InetAddressAndPort,Long> getJustRemovedEndpoints(){

  return ImmutableMap.copyOf(justRemovedEndpoints);

}

Location: Gossiper.java

Content: 

long getLastProcessedMessageAt(){

  return lastProcessedMessageAt;

}

Location: Gossiper.java

Content: 

/** 

 * @return a list of live gossip participants, including fat clients

 */

public Set<InetAddressAndPort> getLiveMembers(){

  Set<InetAddressAndPort> liveMembers=new HashSet<>(liveEndpoints);

  if (!liveMembers.contains(FBUtilities.getBroadcastAddressAndPort()))   liveMembers.add(FBUtilities.getBroadcastAddressAndPort());

  return liveMembers;

}

Location: Gossiper.java

Content: 

/** 

 * @return a list of live ring members.

 */

public Set<InetAddressAndPort> getLiveTokenOwners(){

  return StorageService.instance.getLiveRingMembers(true);

}

Location: Gossiper.java

Content: 

/** 

 * Return either: the greatest heartbeat or application state

 * @param epState

 * @return

 */

int getMaxEndpointStateVersion(EndpointState epState){

  int maxVersion=epState.getHeartBeatState().getHeartBeatVersion();

  for (  Map.Entry<ApplicationState,VersionedValue> state : epState.states())   maxVersion=Math.max(maxVersion,state.getValue().version);

  return maxVersion;

}

Location: Gossiper.java

Content: 

@Nullable public CassandraVersion getReleaseVersion(InetAddressAndPort ep){

  EndpointState state=getEndpointStateForEndpoint(ep);

  return state != null ? state.getReleaseVersion() : null;

}

Location: Gossiper.java

Content: 

@Nullable public UUID getSchemaVersion(InetAddressAndPort ep){

  EndpointState state=getEndpointStateForEndpoint(ep);

  return state != null ? state.getSchemaVersion() : null;

}

Location: Gossiper.java

Content: 

Set<InetAddressAndPort> getSeedsInShadowRound(){

  return ImmutableSet.copyOf(seedsInShadowRound);

}

Location: Gossiper.java

Content: 

EndpointState getStateForVersionBiggerThan(InetAddressAndPort forEndpoint,int version){

  EndpointState epState=endpointStateMap.get(forEndpoint);

  EndpointState reqdEndpointState=null;

  if (epState != null) {

    HeartBeatState heartBeatState=epState.getHeartBeatState();

    int localHbGeneration=heartBeatState.getGeneration();

    int localHbVersion=heartBeatState.getHeartBeatVersion();

    if (localHbVersion > version) {

      reqdEndpointState=new EndpointState(new HeartBeatState(localHbGeneration,localHbVersion));

      if (logger.isTraceEnabled())       logger.trace("local heartbeat version {} greater than {} for {}",localHbVersion,version,forEndpoint);

    }

    Map<ApplicationState,VersionedValue> states=new EnumMap<>(ApplicationState.class);

    for (    Entry<ApplicationState,VersionedValue> entry : epState.states()) {

      VersionedValue value=entry.getValue();

      if (value.version > version) {

        if (reqdEndpointState == null) {

          reqdEndpointState=new EndpointState(new HeartBeatState(localHbGeneration,localHbVersion));

        }

        final ApplicationState key=entry.getKey();

        if (logger.isTraceEnabled())         logger.trace("Adding state {}: {}",key,value.value);

        states.put(key,value);

      }

    }

    if (reqdEndpointState != null)     reqdEndpointState.addApplicationStates(states);

  }

  return reqdEndpointState;

}

Location: Gossiper.java

Content: 

Map<InetAddressAndPort,Long> getUnreachableEndpoints(){

  return ImmutableMap.copyOf(unreachableEndpoints);

}

Location: Gossiper.java

Content: 

/** 

 * @return a list of unreachable gossip participants, including fat clients

 */

public Set<InetAddressAndPort> getUnreachableMembers(){

  return unreachableEndpoints.keySet();

}

Location: Gossiper.java

Content: 

/** 

 * @return a list of unreachable token owners

 */

public Set<InetAddressAndPort> getUnreachableTokenOwners(){

  Set<InetAddressAndPort> tokenOwners=new HashSet<>();

  for (  InetAddressAndPort endpoint : unreachableEndpoints.keySet()) {

    if (StorageService.instance.getTokenMetadata().isMember(endpoint))     tokenOwners.add(endpoint);

  }

  return tokenOwners;

}

Location: Gossiper.java

Content: 

private static long getVeryLongTime(){

  String newVLT=System.getProperty("cassandra.very_long_time_ms");

  if (newVLT != null) {

    logger.info("Overriding aVeryLongTime to {}ms",newVLT);

    return Long.parseLong(newVLT);

  }

  return 259200 * 1000;

}

Location: Gossiper.java

Content: 

Gossiper(boolean registerJmx){

  fatClientTimeout=(QUARANTINE_DELAY / 2);

  FailureDetector.instance.registerFailureDetectionEventListener(this);

  if (registerJmx) {

    MBeanWrapper.instance.registerMBean(this,MBEAN_NAME);

  }

}

Location: Gossiper.java

Content: 

/** 

 * This method is called whenever there is a "big" change in ep state (a generation change for a known node).

 * @param ep      endpoint

 * @param epState EndpointState for the endpoint

 */

private void handleMajorStateChange(InetAddressAndPort ep,EndpointState epState){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  EndpointState localEpState=endpointStateMap.get(ep);

  if (!isDeadState(epState)) {

    if (localEpState != null)     logger.info("Node {} has restarted, now UP",ep);

 else     logger.info("Node {} is now part of the cluster",ep);

  }

  if (logger.isTraceEnabled())   logger.trace("Adding endpoint state for {}",ep);

  endpointStateMap.put(ep,epState);

  if (localEpState != null) {

    for (    IEndpointStateChangeSubscriber subscriber : subscribers)     subscriber.onRestart(ep,localEpState);

  }

  if (!isDeadState(epState))   markAlive(ep,epState);

 else {

    logger.debug("Not marking {} alive due to dead state",ep);

    markDead(ep,epState);

  }

  for (  IEndpointStateChangeSubscriber subscriber : subscribers)   subscriber.onJoin(ep,epState);

  if (isShutdown(ep))   markAsShutdown(ep);

  GossiperDiagnostics.majorStateChangeHandled(this,ep,epState);

}

Location: Gossiper.java

Content: 

public boolean haveMajorVersion3Nodes(){

  return haveMajorVersion3NodesMemoized.get();

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void initializeNodeUnsafe(InetAddressAndPort addr,UUID uuid,int generationNbr){

  initializeNodeUnsafe(addr,uuid,MessagingService.current_version,generationNbr);

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void initializeNodeUnsafe(InetAddressAndPort addr,UUID uuid,int netVersion,int generationNbr){

  HeartBeatState hbState=new HeartBeatState(generationNbr);

  EndpointState newState=new EndpointState(hbState);

  newState.markAlive();

  EndpointState oldState=endpointStateMap.putIfAbsent(addr,newState);

  EndpointState localState=oldState == null ? newState : oldState;

  Map<ApplicationState,VersionedValue> states=new EnumMap<>(ApplicationState.class);

  states.put(ApplicationState.NET_VERSION,StorageService.instance.valueFactory.networkVersion(netVersion));

  states.put(ApplicationState.HOST_ID,StorageService.instance.valueFactory.hostId(uuid));

  localState.addApplicationStates(states);

}

Location: Gossiper.java

Content: 

/** 

 * Creates a new dead  {@link EndpointState} that is {@link EndpointState#isEmptyWithoutStatus() empty}.  This is used during host replacement for edge cases where the seed notified that the endpoint was empty, so need to add such state into gossip explicitly (as empty endpoints are not gossiped outside of the shadow round). see CASSANDRA-16213

 */

public void initializeUnreachableNodeUnsafe(InetAddressAndPort addr){

  EndpointState state=new EndpointState(HeartBeatState.empty());

  state.markDead();

  EndpointState oldState=endpointStateMap.putIfAbsent(addr,state);

  if (null != oldState) {

    throw new RuntimeException("Attempted to initialize endpoint state for unreachable node, " + "but found existing endpoint state for it.");

  }

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void injectApplicationState(InetAddressAndPort endpoint,ApplicationState state,VersionedValue value){

  EndpointState localState=endpointStateMap.get(endpoint);

  localState.addApplicationState(state,value);

}

Location: Gossiper.java

Content: 

public boolean isDeadState(EndpointState epState){

  String status=getGossipStatus(epState);

  if (status.isEmpty())   return false;

  return DEAD_STATES.contains(status);

}

Location: Gossiper.java

Content: 

public boolean isGossipOnlyMember(InetAddressAndPort endpoint){

  EndpointState epState=endpointStateMap.get(endpoint);

  if (epState == null) {

    return false;

  }

  return !isDeadState(epState) && !StorageService.instance.getTokenMetadata().isMember(endpoint);

}

Location: Gossiper.java

Content: 

private static boolean isInGossipStage(){

  return ((JMXEnabledSingleThreadExecutor)Stage.GOSSIP.executor()).isExecutedBy(Thread.currentThread());

}

Location: Gossiper.java

Content: 

protected boolean isInShadowRound(){

  return inShadowRound;

}

Location: Gossiper.java

Content: 

public boolean isKnownEndpoint(InetAddressAndPort endpoint){

  return endpointStateMap.containsKey(endpoint);

}

Location: Gossiper.java

Content: 

/** 

 * Check if this node can safely be started and join the ring. If the node is bootstrapping, examines gossip state for any previous status to decide whether it's safe to allow this node to start and bootstrap. If not bootstrapping, compares the host ID that the node itself has (obtained by reading from system.local or generated if not present) with the host ID obtained from gossip for the endpoint address (if any). This latter case prevents a non-bootstrapping, new node from being started with the same address of a previously started, but currently down predecessor.

 * @param endpoint - the endpoint to check

 * @param localHostUUID - the host id to check

 * @param isBootstrapping - whether the node intends to bootstrap when joining

 * @param epStates - endpoint states in the cluster

 * @return true if it is safe to start the node, false otherwise

 */

public boolean isSafeForStartup(InetAddressAndPort endpoint,UUID localHostUUID,boolean isBootstrapping,Map<InetAddressAndPort,EndpointState> epStates){

  EndpointState epState=epStates.get(endpoint);

  if (epState == null)   return true;

  String status=getGossipStatus(epState);

  if (status.equals(VersionedValue.HIBERNATE) && !SystemKeyspace.bootstrapComplete()) {

    logger.warn("A node with the same IP in hibernate status was detected. Was a replacement already attempted?");

    return false;

  }

  if (isDeadState(epState))   return true;

  if (isBootstrapping) {

    final List<String> unsafeStatuses=new ArrayList<String>(){

{

        add("");

        add(VersionedValue.STATUS_NORMAL);

        add(VersionedValue.SHUTDOWN);

      }

    }

;

    return !unsafeStatuses.contains(status);

  }

 else {

    VersionedValue previous=epState.getApplicationState(ApplicationState.HOST_ID);

    return UUID.fromString(previous.value).equals(localHostUUID);

  }

}

Location: Gossiper.java

Content: 

private boolean isShutdown(InetAddressAndPort endpoint){

  EndpointState epState=endpointStateMap.get(endpoint);

  if (epState == null) {

    return false;

  }

  VersionedValue versionedValue=epState.getApplicationState(ApplicationState.STATUS_WITH_PORT);

  if (versionedValue == null) {

    versionedValue=epState.getApplicationState(ApplicationState.STATUS);

    if (versionedValue == null) {

      return false;

    }

  }

  String value=versionedValue.value;

  String[] pieces=value.split(VersionedValue.DELIMITER_STR,-1);

  assert (pieces.length > 0);

  String state=pieces[0];

  return state.equals(VersionedValue.SHUTDOWN);

}

Location: Gossiper.java

Content: 

public boolean isSilentShutdownState(EndpointState epState){

  String status=getGossipStatus(epState);

  if (status.isEmpty())   return false;

  return SILENT_SHUTDOWN_STATES.contains(status);

}

Location: Gossiper.java

Content: 

/** 

 * The gossip digest is built based on randomization rather than just looping through the collection of live endpoints.

 * @param gDigests list of Gossip Digests.

 */

private void makeRandomGossipDigest(List<GossipDigest> gDigests){

  EndpointState epState;

  int generation=0;

  int maxVersion=0;

  List<InetAddressAndPort> endpoints=new ArrayList<>(endpointStateMap.keySet());

  Collections.shuffle(endpoints,random);

  for (  InetAddressAndPort endpoint : endpoints) {

    epState=endpointStateMap.get(endpoint);

    if (epState != null) {

      generation=epState.getHeartBeatState().getGeneration();

      maxVersion=getMaxEndpointStateVersion(epState);

    }

    gDigests.add(new GossipDigest(endpoint,generation,maxVersion));

  }

  if (logger.isTraceEnabled()) {

    StringBuilder sb=new StringBuilder();

    for (    GossipDigest gDigest : gDigests) {

      sb.append(gDigest);

      sb.append(" ");

    }

    logger.trace("Gossip Digests are : {}",sb);

  }

}

Location: Gossiper.java

Content: 

private void markAlive(final InetAddressAndPort addr,final EndpointState localState){

  localState.markDead();

  Message<NoPayload> echoMessage=Message.out(ECHO_REQ,noPayload);

  logger.trace("Sending ECHO_REQ to {}",addr);

  RequestCallback echoHandler=msg -> {

    runInGossipStageBlocking(() -> realMarkAlive(addr,localState));

  }

;

  MessagingService.instance().sendWithCallback(echoMessage,addr,echoHandler);

  GossiperDiagnostics.markedAlive(this,addr,localState);

}

Location: Gossiper.java

Content: 

/** 

 * This method is used to mark a node as shutdown; that is it gracefully exited on its own and told us about it

 * @param endpoint endpoint that has shut itself down

 */

protected void markAsShutdown(InetAddressAndPort endpoint){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  EndpointState epState=endpointStateMap.get(endpoint);

  if (epState == null)   return;

  epState.addApplicationState(ApplicationState.STATUS_WITH_PORT,StorageService.instance.valueFactory.shutdown(true));

  epState.addApplicationState(ApplicationState.STATUS,StorageService.instance.valueFactory.shutdown(true));

  epState.addApplicationState(ApplicationState.RPC_READY,StorageService.instance.valueFactory.rpcReady(false));

  epState.getHeartBeatState().forceHighestPossibleVersionUnsafe();

  markDead(endpoint,epState);

  FailureDetector.instance.forceConviction(endpoint);

  GossiperDiagnostics.markedAsShutdown(this,endpoint);

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void markDead(InetAddressAndPort addr,EndpointState localState){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  if (logger.isTraceEnabled())   logger.trace("marking as down {}",addr);

  silentlyMarkDead(addr,localState);

  logger.info("InetAddress {} is now DOWN",addr);

  for (  IEndpointStateChangeSubscriber subscriber : subscribers)   subscriber.onDead(addr,localState);

  if (logger.isTraceEnabled())   logger.trace("Notified {}",subscribers);

  GossiperDiagnostics.markedDead(this,addr,localState);

}

Location: Gossiper.java

Content: 

protected void maybeFinishShadowRound(InetAddressAndPort respondent,boolean isInShadowRound,Map<InetAddressAndPort,EndpointState> epStateMap){

  if (inShadowRound) {

    if (!isInShadowRound) {

      if (!seeds.contains(respondent))       logger.warn("Received an ack from {}, who isn't a seed. Ensure your seed list includes a live node. Exiting shadow round",respondent);

      logger.debug("Received a regular ack from {}, can now exit shadow round",respondent);

      endpointShadowStateMap.putAll(epStateMap);

      inShadowRound=false;

      seedsInShadowRound.clear();

    }

 else {

      logger.debug("Received an ack from {} indicating it is also in shadow round",respondent);

      seedsInShadowRound.add(respondent);

      if (seedsInShadowRound.containsAll(seeds)) {

        logger.debug("All seeds are in a shadow round, clearing this node to exit its own");

        inShadowRound=false;

        seedsInShadowRound.clear();

      }

    }

  }

}

Location: Gossiper.java

Content: 

private void maybeGossipToSeed(Message<GossipDigestSyn> prod){

  int size=seeds.size();

  if (size > 0) {

    if (size == 1 && seeds.contains(FBUtilities.getBroadcastAddressAndPort())) {

      return;

    }

    if (liveEndpoints.size() == 0) {

      sendGossip(prod,seeds);

    }

 else {

      double probability=seeds.size() / (double)(liveEndpoints.size() + unreachableEndpoints.size());

      double randDbl=random.nextDouble();

      if (randDbl <= probability)       sendGossip(prod,seeds);

    }

  }

}

Location: Gossiper.java

Content: 

private void maybeGossipToUnreachableMember(Message<GossipDigestSyn> message){

  double liveEndpointCount=liveEndpoints.size();

  double unreachableEndpointCount=unreachableEndpoints.size();

  if (unreachableEndpointCount > 0) {

    double prob=unreachableEndpointCount / (liveEndpointCount + 1);

    double randDbl=random.nextDouble();

    if (randDbl < prob) {

      sendGossip(message,Sets.filter(unreachableEndpoints.keySet(),ep -> !isDeadState(getEndpointStateMap().get(ep))));

    }

  }

}

Location: Gossiper.java

Content: 

public void maybeInitializeLocalState(int generationNbr){

  HeartBeatState hbState=new HeartBeatState(generationNbr);

  EndpointState localState=new EndpointState(hbState);

  localState.markAlive();

  endpointStateMap.putIfAbsent(FBUtilities.getBroadcastAddressAndPort(),localState);

}

Location: Gossiper.java

Content: 

private boolean nodesAgreeOnSchema(Collection<InetAddressAndPort> nodes){

  UUID expectedVersion=null;

  for (  InetAddressAndPort node : nodes) {

    EndpointState state=getEndpointStateForEndpoint(node);

    UUID remoteVersion=state.getSchemaVersion();

    if (null == expectedVersion)     expectedVersion=remoteVersion;

    if (null == expectedVersion || !expectedVersion.equals(remoteVersion))     return false;

  }

  return true;

}

Location: Gossiper.java

Content: 

void notifyFailureDetector(InetAddressAndPort endpoint,EndpointState remoteEndpointState){

  EndpointState localEndpointState=endpointStateMap.get(endpoint);

  if (localEndpointState != null) {

    IFailureDetector fd=FailureDetector.instance;

    int localGeneration=localEndpointState.getHeartBeatState().getGeneration();

    int remoteGeneration=remoteEndpointState.getHeartBeatState().getGeneration();

    if (remoteGeneration > localGeneration) {

      localEndpointState.updateTimestamp();

      if (!localEndpointState.isAlive()) {

        logger.debug("Clearing interval times for {} due to generation change",endpoint);

        fd.remove(endpoint);

      }

      fd.report(endpoint);

      return;

    }

    if (remoteGeneration == localGeneration) {

      int localVersion=getMaxEndpointStateVersion(localEndpointState);

      int remoteVersion=remoteEndpointState.getHeartBeatState().getHeartBeatVersion();

      if (remoteVersion > localVersion) {

        localEndpointState.updateTimestamp();

        fd.report(endpoint);

      }

    }

  }

}

Location: Gossiper.java

Content: 

void notifyFailureDetector(Map<InetAddressAndPort,EndpointState> remoteEpStateMap){

  for (  Entry<InetAddressAndPort,EndpointState> entry : remoteEpStateMap.entrySet()) {

    notifyFailureDetector(entry.getKey(),entry.getValue());

  }

}

Location: Gossiper.java

Content: 

/** 

 * Quarantines the endpoint for QUARANTINE_DELAY

 * @param endpoint

 */

private void quarantineEndpoint(InetAddressAndPort endpoint){

  quarantineEndpoint(endpoint,System.currentTimeMillis());

}

Location: Gossiper.java

Content: 

/** 

 * Quarantines the endpoint until quarantineExpiration + QUARANTINE_DELAY

 * @param endpoint

 * @param quarantineExpiration

 */

private void quarantineEndpoint(InetAddressAndPort endpoint,long quarantineExpiration){

  justRemovedEndpoints.put(endpoint,quarantineExpiration);

  GossiperDiagnostics.quarantinedEndpoint(this,endpoint,quarantineExpiration);

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void realMarkAlive(final InetAddressAndPort addr,final EndpointState localState){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  if (logger.isTraceEnabled())   logger.trace("marking as alive {}",addr);

  localState.markAlive();

  localState.updateTimestamp();

  liveEndpoints.add(addr);

  unreachableEndpoints.remove(addr);

  expireTimeEndpointMap.remove(addr);

  logger.debug("removing expire time for endpoint : {}",addr);

  logger.info("InetAddress {} is now UP",addr);

  for (  IEndpointStateChangeSubscriber subscriber : subscribers)   subscriber.onAlive(addr,localState);

  if (logger.isTraceEnabled())   logger.trace("Notified {}",subscribers);

  GossiperDiagnostics.realMarkedAlive(this,addr,localState);

}

Location: Gossiper.java

Content: 

/** 

 * Register for interesting state changes.

 * @param subscriber module which implements the IEndpointStateChangeSubscriber

 */

public void register(IEndpointStateChangeSubscriber subscriber){

  subscribers.add(subscriber);

}

Location: Gossiper.java

Content: 

/** 

 * Remove the Endpoint and evict immediately, to avoid gossiping about this node. This should only be called when a token is taken over by a new IP address.

 * @param endpoint The endpoint that has been replaced

 */

public void replacedEndpoint(InetAddressAndPort endpoint){

  hongshuai();

  if (disableThreadValidation || isInGossipStage())   return;

  IllegalStateException e=new IllegalStateException("Attempting gossip state mutation from illegal thread: " + Thread.currentThread().getName());

  if (DatabaseDescriptor.strictRuntimeChecks()) {

    throw e;

  }

 else {

    noSpamLogger.getStatement(Throwables.getStackTraceAsString(e)).error(e.getMessage(),e);

  }

  removeEndpoint(endpoint);

  evictFromMembership(endpoint);

  replacementQuarantine(endpoint);

  GossiperDiagnostics.replacedEndpoint(this,endpoint);

}

Location: Gossiper.java

Content: 

/** 

 * Quarantine endpoint specifically for replacement purposes.

 * @param endpoint

 */

public void replacementQuarantine(InetAddressAndPort endpoint){

  logger.debug("");

  quarantineEndpoint(endpoint,System.currentTimeMillis() + QUARANTINE_DELAY);

  GossiperDiagnostics.replacementQuarantine(this,endpoint);

}

Location: Gossiper.java

Content: 

private void requestAll(GossipDigest gDigest,List<GossipDigest> deltaGossipDigestList,int remoteGeneration){

  deltaGossipDigestList.add(new GossipDigest(gDigest.getEndpoint(),remoteGeneration,0));

  if (logger.isTraceEnabled())   logger.trace("requestAll for {}",gDigest.getEndpoint());

}

Location: Gossiper.java

Content: 

public static void runInGossipStageBlocking(Runnable runnable){

  if (isInGossipStage()) {

    runnable.run();

    return;

  }

  ListenableFutureTask task=ListenableFutureTask.create(runnable,null);

  Stage.GOSSIP.execute(task);

  try {

    task.get();

  }

 catch (  InterruptedException|ExecutionException e) {

    throw new AssertionError(e);

  }

}

Location: Gossiper.java

Content: 

public boolean seenAnySeed(){

  for (  Map.Entry<InetAddressAndPort,EndpointState> entry : endpointStateMap.entrySet()) {

    if (seeds.contains(entry.getKey()))     return true;

    try {

      VersionedValue internalIp=entry.getValue().getApplicationState(ApplicationState.INTERNAL_IP);

      VersionedValue internalIpAndPort=entry.getValue().getApplicationState(ApplicationState.INTERNAL_ADDRESS_AND_PORT);

      InetAddressAndPort endpoint=null;

      if (internalIpAndPort != null) {

        endpoint=InetAddressAndPort.getByName(internalIpAndPort.value);

      }

 else       if (internalIp != null) {

        endpoint=InetAddressAndPort.getByName(internalIp.value);

      }

      if (endpoint != null && seeds.contains(endpoint))       return true;

    }

 catch (    UnknownHostException e) {

      throw new RuntimeException(e);

    }

  }

  return false;

}

Location: Gossiper.java

Content: 

private void sendAll(GossipDigest gDigest,Map<InetAddressAndPort,EndpointState> deltaEpStateMap,int maxRemoteVersion){

  EndpointState localEpStatePtr=getStateForVersionBiggerThan(gDigest.getEndpoint(),maxRemoteVersion);

  if (localEpStatePtr != null)   deltaEpStateMap.put(gDigest.getEndpoint(),localEpStatePtr);

}

Location: Gossiper.java

Content: 

/** 

 * Returns true if the chosen target was also a seed. False otherwise

 * @param message

 * @param epSet   a set of endpoint from which a random endpoint is chosen.

 * @return true if the chosen endpoint is also a seed.

 */

private boolean sendGossip(Message<GossipDigestSyn> message,Set<InetAddressAndPort> epSet){

  List<InetAddressAndPort> endpoints=ImmutableList.copyOf(epSet);

  int size=endpoints.size();

  if (size < 1)   return false;

  int index=(size == 1) ? 0 : random.nextInt(size);

  InetAddressAndPort to=endpoints.get(index);

  if (logger.isTraceEnabled())   logger.trace("Sending a GossipDigestSyn to {} ...",to);

  if (firstSynSendAt == 0)   firstSynSendAt=System.nanoTime();

  MessagingService.instance().send(message,to);

  boolean isSeed=seeds.contains(to);

  GossiperDiagnostics.sendGossipDigestSyn(this,to);

  return isSeed;

}

Location: Gossiper.java

Content: 

public void setLastProcessedMessageAt(long timeInMillis){

  this.lastProcessedMessageAt=timeInMillis;

}

Location: Gossiper.java

Content: 

/** 

 * Used by  {@link #markDead(InetAddressAndPort,EndpointState)} and {@link #addSavedEndpoint(InetAddressAndPort)}to register a endpoint as dead.  This method is "silent" to avoid triggering listeners, diagnostics, or logs on startup via addSavedEndpoint.

 */

private void silentlyMarkDead(InetAddressAndPort addr,EndpointState localState){

  localState.markDead();

  liveEndpoints.remove(addr);

  unreachableEndpoints.put(addr,System.nanoTime());

}

Location: Gossiper.java

Content: 

public void start(int generationNumber){

  start(generationNumber,new EnumMap<ApplicationState,VersionedValue>(ApplicationState.class));

}

Location: Gossiper.java

Content: 

/** 

 * Start the gossiper with the generation number, preloading the map of application states before starting

 */

public void start(int generationNbr,Map<ApplicationState,VersionedValue> preloadLocalStates){

  buildSeedsList();

  maybeInitializeLocalState(generationNbr);

  EndpointState localState=endpointStateMap.get(FBUtilities.getBroadcastAddressAndPort());

  localState.addApplicationStates(preloadLocalStates);

  DatabaseDescriptor.getEndpointSnitch().gossiperStarting();

  if (logger.isTraceEnabled())   logger.trace("gossip started with generation {}",localState.getHeartBeatState().getGeneration());

  scheduledGossipTask=executor.scheduleWithFixedDelay(new GossipTask(),Gossiper.intervalInMillis,Gossiper.intervalInMillis,TimeUnit.MILLISECONDS);

}

Location: Gossiper.java

Content: 

public void stop(){

  EndpointState mystate=endpointStateMap.get(FBUtilities.getBroadcastAddressAndPort());

  if (mystate != null && !isSilentShutdownState(mystate) && StorageService.instance.isJoined()) {

    logger.info("Announcing shutdown");

    addLocalApplicationState(ApplicationState.STATUS_WITH_PORT,StorageService.instance.valueFactory.shutdown(true));

    addLocalApplicationState(ApplicationState.STATUS,StorageService.instance.valueFactory.shutdown(true));

    Message message=Message.out(Verb.GOSSIP_SHUTDOWN,noPayload);

    for (    InetAddressAndPort ep : liveEndpoints)     MessagingService.instance().send(message,ep);

    Uninterruptibles.sleepUninterruptibly(Integer.getInteger("cassandra.shutdown_announce_in_ms",2000),TimeUnit.MILLISECONDS);

  }

 else   logger.warn("No local state, state is in silent shutdown, or node hasn't joined, not announcing shutdown");

  if (scheduledGossipTask != null)   scheduledGossipTask.cancel(false);

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void stopShutdownAndWait(long timeout,TimeUnit unit) throws InterruptedException, TimeoutException {

  hongshuai();

  EndpointState mystate=endpointStateMap.get(FBUtilities.getBroadcastAddressAndPort());

  if (mystate != null && !isSilentShutdownState(mystate) && StorageService.instance.isJoined()) {

    logger.info("Announcing shutdown");

    addLocalApplicationState(ApplicationState.STATUS_WITH_PORT,StorageService.instance.valueFactory.shutdown(true));

    addLocalApplicationState(ApplicationState.STATUS,StorageService.instance.valueFactory.shutdown(true));

    Message message=Message.out(Verb.GOSSIP_SHUTDOWN,noPayload);

    for (    InetAddressAndPort ep : liveEndpoints)     MessagingService.instance().send(message,ep);

    Uninterruptibles.sleepUninterruptibly(Integer.getInteger("cassandra.shutdown_announce_in_ms",2000),TimeUnit.MILLISECONDS);

  }

 else   logger.warn("No local state, state is in silent shutdown, or node hasn't joined, not announcing shutdown");

  if (scheduledGossipTask != null)   scheduledGossipTask.cancel(false);

  ExecutorUtils.shutdownAndWait(timeout,unit,executor);

}

Location: Gossiper.java

Content: 

/** 

 * Unregister interest for state changes.

 * @param subscriber module which implements the IEndpointStateChangeSubscriber

 */

public void unregister(IEndpointStateChangeSubscriber subscriber){

  subscribers.remove(subscriber);

}

Location: Gossiper.java

Content: 

@VisibleForTesting public void unsafeAnulEndpoint(InetAddressAndPort endpoint){

  removeEndpoint(endpoint);

  justRemovedEndpoints.remove(endpoint);

  endpointStateMap.remove(endpoint);

  expireTimeEndpointMap.remove(endpoint);

  unreachableEndpoints.remove(endpoint);

}

Location: Gossiper.java

Content: 

/** 

 * Blockingly wait for all live nodes to agree on the current schema version.

 * @param maxWait maximum time to wait for schema agreement

 * @param unit TimeUnit of maxWait

 * @return true if agreement was reached, false if not

 */

public boolean waitForSchemaAgreement(long maxWait,TimeUnit unit,BooleanSupplier abortCondition){

  int waited=0;

  int toWait=50;

  Set<InetAddressAndPort> members=getLiveTokenOwners();

  while (true) {

    if (nodesAgreeOnSchema(members))     return true;

    if (waited >= unit.toMillis(maxWait) || abortCondition.getAsBoolean())     return false;

    Uninterruptibles.sleepUninterruptibly(toWait,TimeUnit.MILLISECONDS);

    waited+=toWait;

    toWait=Math.min(1000,toWait * 2);

  }

}

Location: Gossiper.java

Content: 

public static void waitToSettle(){

  int forceAfter=Integer.getInteger("cassandra.skip_wait_for_gossip_to_settle",-1);

  if (forceAfter == 0) {

    return;

  }

  final int GOSSIP_SETTLE_MIN_WAIT_MS=5000;

  final int GOSSIP_SETTLE_POLL_INTERVAL_MS=1000;

  final int GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED=3;

  logger.info("Waiting for gossip to settle...");

  Uninterruptibles.sleepUninterruptibly(GOSSIP_SETTLE_MIN_WAIT_MS,TimeUnit.MILLISECONDS);

  int totalPolls=0;

  int numOkay=0;

  int epSize=Gossiper.instance.getEndpointCount();

  while (numOkay < GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED) {

    Uninterruptibles.sleepUninterruptibly(GOSSIP_SETTLE_POLL_INTERVAL_MS,TimeUnit.MILLISECONDS);

    int currentSize=Gossiper.instance.getEndpointCount();

    totalPolls++;

    if (currentSize == epSize) {

      logger.debug("Gossip looks settled.");

      numOkay++;

    }

 else {

      logger.info("Gossip not settled after {} polls.",totalPolls);

      numOkay=0;

    }

    epSize=currentSize;

    if (forceAfter > 0 && totalPolls > forceAfter) {

      logger.warn("Gossip not settled but startup forced by cassandra.skip_wait_for_gossip_to_settle. Gossip total polls: {}",totalPolls);

      break;

    }

  }

  if (totalPolls > GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED)   logger.info("Gossip settled after {} extra polls; proceeding",totalPolls - GOSSIP_SETTLE_POLL_SUCCESSES_REQUIRED);

 else   logger.info("No gossip backlog; proceeding");

}

