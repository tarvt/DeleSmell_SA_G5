Location: SystemKeyspace.java

Content: 

public static boolean bootstrapComplete(){

  return getBootstrapState() == BootstrapState.COMPLETED;

}

Location: SystemKeyspace.java

Content: 

public static boolean bootstrapInProgress(){

  return getBootstrapState() == BootstrapState.IN_PROGRESS;

}

Location: SystemKeyspace.java

Content: 

@SuppressWarnings("unchecked") private static Range<Token> byteBufferToRange(ByteBuffer rawRange,IPartitioner partitioner){

  try {

    return (Range<Token>)Range.tokenSerializer.deserialize(ByteStreams.newDataInput(ByteBufferUtil.getArray(rawRange)),partitioner,0);

  }

 catch (  IOException e) {

    throw new IOError(e);

  }

}

Location: SystemKeyspace.java

Content: 

/** 

 * One of three things will happen if you try to read the system keyspace: 1. files are present and you can read them: great 2. no files are there: great (new node is assumed) 3. files are present but you can't read them: bad

 * @throws ConfigurationException

 */

public static void checkHealth() throws ConfigurationException {

  Keyspace keyspace;

  try {

    keyspace=Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME);

  }

 catch (  AssertionError err) {

    ConfigurationException ex=new ConfigurationException("Could not read system keyspace!");

    ex.initCause(err);

    throw ex;

  }

  ColumnFamilyStore cfs=keyspace.getColumnFamilyStore(LOCAL);

  String req="SELECT cluster_name FROM system.%s WHERE key='%s'";

  UntypedResultSet result=executeInternal(format(req,LOCAL,LOCAL));

  if (result.isEmpty() || !result.one().has("cluster_name")) {

    if (!cfs.getLiveSSTables().isEmpty())     throw new ConfigurationException("Found system keyspace files, but they couldn't be loaded!");

    return;

  }

  String savedClusterName=result.one().getString("cluster_name");

  if (!DatabaseDescriptor.getClusterName().equals(savedClusterName))   throw new ConfigurationException("Saved cluster name " + savedClusterName + " != configured name "+ DatabaseDescriptor.getClusterName());

}

Location: SystemKeyspace.java

Content: 

/** 

 * truncates size_estimates and table_estimates tables

 */

public static void clearAllEstimates(){

  for (  TableMetadata table : Arrays.asList(LegacySizeEstimates,TableEstimates)) {

    String cql=String.format("TRUNCATE TABLE " + table.toString());

    executeInternal(cql);

  }

}

Location: SystemKeyspace.java

Content: 

/** 

 * Clears size estimates for a table (on table drop)

 */

public static void clearEstimates(String keyspace,String table){

  String cqlFormat="DELETE FROM %s WHERE keyspace_name = ? AND table_name = ?";

  String cql=format(cqlFormat,LegacySizeEstimates.toString());

  executeInternal(cql,keyspace,table);

  cql=String.format(cqlFormat,TableEstimates.toString());

  executeInternal(cql,keyspace,table);

}

Location: SystemKeyspace.java

Content: 

/** 

 * Clears persisted read rates from system.sstable_activity for SSTables that have been deleted.

 */

public static void clearSSTableReadMeter(String keyspace,String table,int generation){

  String cql="DELETE FROM system.%s WHERE keyspace_name=? AND columnfamily_name=? and generation=?";

  executeInternal(format(cql,SSTABLE_ACTIVITY),keyspace,table,generation);

}

Location: SystemKeyspace.java

Content: 

private static Collection<Token> deserializeTokens(Collection<String> tokensStrings){

  Token.TokenFactory factory=StorageService.instance.getTokenFactory();

  List<Token> tokens=new ArrayList<>(tokensStrings.size());

  for (  String tk : tokensStrings)   tokens.add(factory.fromString(tk));

  return tokens;

}

Location: SystemKeyspace.java

Content: 

public static void finishStartup(){

  SchemaKeyspace.saveSystemKeyspacesSchema();

}

Location: SystemKeyspace.java

Content: 

public static void finishViewBuildStatus(String ksname,String viewName){

  setViewBuilt(ksname,viewName,false);

  executeInternal(String.format("DELETE FROM system.%s WHERE keyspace_name = ? AND view_name = ?",VIEW_BUILDS_IN_PROGRESS),ksname,viewName);

  forceBlockingFlush(VIEW_BUILDS_IN_PROGRESS);

}

Location: SystemKeyspace.java

Content: 

public static void forceBlockingFlush(String... cfnames){

  if (!DatabaseDescriptor.isUnsafeSystem()) {

    List<ListenableFuture<CommitLogPosition>> futures=new ArrayList<>();

    for (    String cfname : cfnames) {

      futures.add(Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(cfname).forceFlush());

    }

    FBUtilities.waitOnFutures(futures);

  }

}

Location: SystemKeyspace.java

Content: 

private static Functions functions(){

  return Functions.builder().add(UuidFcts.all()).add(TimeFcts.all()).add(BytesConversionFcts.all()).add(AggregateFcts.all()).add(CastFcts.all()).add(OperationFcts.all()).build();

}

Location: SystemKeyspace.java

Content: 

public static BootstrapState getBootstrapState(){

  String req="SELECT bootstrapped FROM system.%s WHERE key='%s'";

  UntypedResultSet result=executeInternal(format(req,LOCAL,LOCAL));

  if (result.isEmpty() || !result.one().has("bootstrapped"))   return BootstrapState.NEEDS_BOOTSTRAP;

  return BootstrapState.valueOf(result.one().getString("bootstrapped"));

}

Location: SystemKeyspace.java

Content: 

public static List<String> getBuiltIndexes(String keyspaceName,Set<String> indexNames){

  List<String> names=new ArrayList<>(indexNames);

  String req="SELECT index_name from %s.\"%s\" WHERE table_name=? AND index_name IN ?";

  UntypedResultSet results=executeInternal(format(req,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_INDEXES),keyspaceName,names);

  return StreamSupport.stream(results.spliterator(),false).map(r -> r.getString("index_name")).collect(Collectors.toList());

}

Location: SystemKeyspace.java

Content: 

/** 

 * Read the host ID from the system keyspace, creating (and storing) one if none exists.

 */

public static UUID getLocalHostId(){

  String req="SELECT host_id FROM system.%s WHERE key='%s'";

  UntypedResultSet result=executeInternal(format(req,LOCAL,LOCAL));

  if (!result.isEmpty() && result.one().has("host_id"))   return result.one().getUUID("host_id");

  UUID hostId=UUID.randomUUID();

  logger.warn("No host ID found, created {} (Note: This should happen exactly once per node).",hostId);

  return setLocalHostId(hostId);

}

Location: SystemKeyspace.java

Content: 

/** 

 * Get preferred IP for given endpoint if it is known. Otherwise this returns given endpoint itself.

 * @param ep endpoint address to check

 * @return Preferred IP for given endpoint if present, otherwise returns given ep

 */

public static InetAddressAndPort getPreferredIP(InetAddressAndPort ep){

  String req="SELECT preferred_ip, preferred_port FROM system.%s WHERE peer=? AND peer_port = ?";

  UntypedResultSet result=executeInternal(String.format(req,PEERS_V2),ep.address,ep.port);

  if (!result.isEmpty() && result.one().has("preferred_ip")) {

    UntypedResultSet.Row row=result.one();

    return InetAddressAndPort.getByAddressOverrideDefaults(row.getInetAddress("preferred_ip"),row.getInt("preferred_port"));

  }

  return ep;

}

Location: SystemKeyspace.java

Content: 

/** 

 * Try to determine what the previous version, if any, was installed on this node. Primary source of truth is the release version in system.local. If the previous version cannot be determined by looking there then either: * the node never had a C* install before * the was a very old version (pre 1.2) installed, which did not include system.local

 * @return either a version read from the system.local table or one of two special valuesindicating either no previous version (SystemUpgrade.NULL_VERSION) or an unreadable, legacy version (SystemUpgrade.UNREADABLE_VERSION).

 */

private static String getPreviousVersionString(){

  String req="SELECT release_version FROM system.%s WHERE key='%s'";

  UntypedResultSet result=executeInternal(format(req,SystemKeyspace.LOCAL,SystemKeyspace.LOCAL));

  if (result.isEmpty() || !result.one().has("release_version")) {

    for (    File dataDirectory : Directories.getKSChildDirectories(SchemaConstants.SYSTEM_KEYSPACE_NAME)) {

      if (dataDirectory.getName().equals("Versions") && dataDirectory.listFiles().length > 0) {

        logger.trace("Found unreadable versions info in pre 1.2 system.Versions table");

        return UNREADABLE_VERSION.toString();

      }

    }

    return NULL_VERSION.toString();

  }

  return result.one().getString("release_version");

}

Location: SystemKeyspace.java

Content: 

public static Collection<Token> getSavedTokens(){

  String req="SELECT tokens FROM system.%s WHERE key='%s'";

  UntypedResultSet result=executeInternal(format(req,LOCAL,LOCAL));

  return result.isEmpty() || !result.one().has("tokens") ? Collections.<Token>emptyList() : deserializeTokens(result.one().getSet("tokens",UTF8Type.instance));

}

Location: SystemKeyspace.java

Content: 

/** 

 * Returns a RestorableMeter tracking the average read rate of a particular SSTable, restoring the last-seen rate from values in system.sstable_activity if present.

 * @param keyspace the keyspace the sstable belongs to

 * @param table the table the sstable belongs to

 * @param generation the generation number for the sstable

 */

public static RestorableMeter getSSTableReadMeter(String keyspace,String table,int generation){

  String cql="SELECT * FROM system.%s WHERE keyspace_name=? and columnfamily_name=? and generation=?";

  UntypedResultSet results=executeInternal(format(cql,SSTABLE_ACTIVITY),keyspace,table,generation);

  if (results.isEmpty())   return new RestorableMeter();

  UntypedResultSet.Row row=results.one();

  double m15rate=row.getDouble("rate_15m");

  double m120rate=row.getDouble("rate_120m");

  return new RestorableMeter(m15rate,m120rate);

}

Location: SystemKeyspace.java

Content: 

public static synchronized Map<InetAddressAndPort,Set<Range<Token>>> getTransferredRanges(String description,String keyspace,IPartitioner partitioner){

  Map<InetAddressAndPort,Set<Range<Token>>> result=new HashMap<>();

  String query="SELECT * FROM system.%s WHERE operation = ? AND keyspace_name = ?";

  UntypedResultSet rs=executeInternal(String.format(query,TRANSFERRED_RANGES_V2),description,keyspace);

  for (  UntypedResultSet.Row row : rs) {

    InetAddress peerAddress=row.getInetAddress("peer");

    int port=row.getInt("peer_port");

    InetAddressAndPort peer=InetAddressAndPort.getByAddressOverrideDefaults(peerAddress,port);

    Set<ByteBuffer> rawRanges=row.getSet("ranges",BytesType.instance);

    Set<Range<Token>> ranges=Sets.newHashSetWithExpectedSize(rawRanges.size());

    for (    ByteBuffer rawRange : rawRanges) {

      ranges.add(byteBufferToRange(rawRange,partitioner));

    }

    result.put(peer,ranges);

  }

  return ImmutableMap.copyOf(result);

}

Location: SystemKeyspace.java

Content: 

public static long getTruncatedAt(TableId id){

  Pair<CommitLogPosition,Long> record=getTruncationRecord(id);

  return record == null ? Long.MIN_VALUE : record.right;

}

Location: SystemKeyspace.java

Content: 

public static CommitLogPosition getTruncatedPosition(TableId id){

  Pair<CommitLogPosition,Long> record=getTruncationRecord(id);

  return record == null ? null : record.left;

}

Location: SystemKeyspace.java

Content: 

private static synchronized Pair<CommitLogPosition,Long> getTruncationRecord(TableId id){

  if (truncationRecords == null)   truncationRecords=readTruncationRecords();

  return truncationRecords.get(id);

}

Location: SystemKeyspace.java

Content: 

public static Map<Range<Token>,Pair<Token,Long>> getViewBuildStatus(String ksname,String viewName){

  String req="SELECT start_token, end_token, last_token, keys_built FROM system.%s WHERE keyspace_name = ? AND view_name = ?";

  Token.TokenFactory factory=ViewBuildsInProgress.partitioner.getTokenFactory();

  UntypedResultSet rs=executeInternal(format(req,VIEW_BUILDS_IN_PROGRESS),ksname,viewName);

  if (rs == null || rs.isEmpty())   return Collections.emptyMap();

  Map<Range<Token>,Pair<Token,Long>> status=new HashMap<>();

  for (  UntypedResultSet.Row row : rs) {

    Token start=factory.fromString(row.getString("start_token"));

    Token end=factory.fromString(row.getString("end_token"));

    Range<Token> range=new Range<>(start,end);

    Token lastToken=row.has("last_token") ? factory.fromString(row.getString("last_token")) : null;

    long keysBuilt=row.has("keys_built") ? row.getLong("keys_built") : 0;

    status.put(range,Pair.create(lastToken,keysBuilt));

  }

  return status;

}

Location: SystemKeyspace.java

Content: 

public static int incrementAndGetGeneration(){

  String req="SELECT gossip_generation FROM system.%s WHERE key='%s'";

  UntypedResultSet result=executeInternal(format(req,LOCAL,LOCAL));

  int generation;

  if (result.isEmpty() || !result.one().has("gossip_generation")) {

    generation=(int)(System.currentTimeMillis() / 1000);

  }

 else {

    final int storedGeneration=result.one().getInt("gossip_generation") + 1;

    final int now=(int)(System.currentTimeMillis() / 1000);

    if (storedGeneration >= now) {

      logger.warn("Using stored Gossip Generation {} as it is greater than current system time {}.  See CASSANDRA-3654 if you experience problems",storedGeneration,now);

      generation=storedGeneration;

    }

 else {

      generation=now;

    }

  }

  req="INSERT INTO system.%s (key, gossip_generation) VALUES ('%s', ?)";

  executeInternal(format(req,LOCAL,LOCAL),generation);

  forceBlockingFlush(LOCAL);

  return generation;

}

Location: SystemKeyspace.java

Content: 

public static boolean isIndexBuilt(String keyspaceName,String indexName){

  String req="SELECT index_name FROM %s.\"%s\" WHERE table_name=? AND index_name=?";

  UntypedResultSet result=executeInternal(format(req,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_INDEXES),keyspaceName,indexName);

  return !result.isEmpty();

}

Location: SystemKeyspace.java

Content: 

public static boolean isViewBuilt(String keyspaceName,String viewName){

  String req="SELECT view_name FROM %s.\"%s\" WHERE keyspace_name=? AND view_name=?";

  UntypedResultSet result=executeInternal(format(req,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_VIEWS),keyspaceName,viewName);

  return !result.isEmpty();

}

Location: SystemKeyspace.java

Content: 

public static boolean isViewStatusReplicated(String keyspaceName,String viewName){

  String req="SELECT status_replicated FROM %s.\"%s\" WHERE keyspace_name=? AND view_name=?";

  UntypedResultSet result=executeInternal(format(req,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_VIEWS),keyspaceName,viewName);

  if (result.isEmpty())   return false;

  UntypedResultSet.Row row=result.one();

  return row.has("status_replicated") && row.getBoolean("status_replicated");

}

Location: SystemKeyspace.java

Content: 

/** 

 * Return a map of IP addresses containing a map of dc and rack info

 */

public static Map<InetAddressAndPort,Map<String,String>> loadDcRackInfo(){

  Map<InetAddressAndPort,Map<String,String>> result=new HashMap<>();

  for (  UntypedResultSet.Row row : executeInternal("SELECT peer, peer_port, data_center, rack from system." + PEERS_V2)) {

    InetAddress address=row.getInetAddress("peer");

    Integer port=row.getInt("peer_port");

    InetAddressAndPort peer=InetAddressAndPort.getByAddressOverrideDefaults(address,port);

    if (row.has("data_center") && row.has("rack")) {

      Map<String,String> dcRack=new HashMap<>();

      dcRack.put("data_center",row.getString("data_center"));

      dcRack.put("rack",row.getString("rack"));

      result.put(peer,dcRack);

    }

  }

  return result;

}

Location: SystemKeyspace.java

Content: 

/** 

 * Return a map of store host_ids to IP addresses

 */

public static Map<InetAddressAndPort,UUID> loadHostIds(){

  Map<InetAddressAndPort,UUID> hostIdMap=new HashMap<>();

  for (  UntypedResultSet.Row row : executeInternal("SELECT peer, peer_port, host_id FROM system." + PEERS_V2)) {

    InetAddress address=row.getInetAddress("peer");

    Integer port=row.getInt("peer_port");

    InetAddressAndPort peer=InetAddressAndPort.getByAddressOverrideDefaults(address,port);

    if (row.has("host_id")) {

      hostIdMap.put(peer,row.getUUID("host_id"));

    }

  }

  return hostIdMap;

}

Location: SystemKeyspace.java

Content: 

public static PaxosState loadPaxosState(DecoratedKey key,TableMetadata metadata,int nowInSec){

  String req="SELECT * FROM system.%s WHERE row_key = ? AND cf_id = ?";

  UntypedResultSet results=QueryProcessor.executeInternalWithNow(nowInSec,System.nanoTime(),format(req,PAXOS),key.getKey(),metadata.id.asUUID());

  if (results.isEmpty())   return new PaxosState(key,metadata);

  UntypedResultSet.Row row=results.one();

  Commit promised=row.has("in_progress_ballot") ? new Commit(row.getUUID("in_progress_ballot"),new PartitionUpdate.Builder(metadata,key,metadata.regularAndStaticColumns(),1).build()) : Commit.emptyCommit(key,metadata);

  Commit accepted=row.has("proposal_version") && row.has("proposal") ? new Commit(row.getUUID("proposal_ballot"),PartitionUpdate.fromBytes(row.getBytes("proposal"),row.getInt("proposal_version"))) : Commit.emptyCommit(key,metadata);

  Commit mostRecent=row.has("most_recent_commit_version") && row.has("most_recent_commit") ? new Commit(row.getUUID("most_recent_commit_at"),PartitionUpdate.fromBytes(row.getBytes("most_recent_commit"),row.getInt("most_recent_commit_version"))) : Commit.emptyCommit(key,metadata);

  return new PaxosState(promised,accepted,mostRecent);

}

Location: SystemKeyspace.java

Content: 

public static List<Pair<String,String>> loadPreparedStatements(){

  String query=format("SELECT logged_keyspace, query_string FROM %s",PreparedStatements.toString());

  UntypedResultSet resultSet=executeOnceInternal(query);

  List<Pair<String,String>> r=new ArrayList<>();

  for (  UntypedResultSet.Row row : resultSet)   r.add(Pair.create(row.has("logged_keyspace") ? row.getString("logged_keyspace") : null,row.getString("query_string")));

  return r;

}

Location: SystemKeyspace.java

Content: 

/** 

 * Return a map of stored tokens to IP addresses

 */

public static SetMultimap<InetAddressAndPort,Token> loadTokens(){

  SetMultimap<InetAddressAndPort,Token> tokenMap=HashMultimap.create();

  for (  UntypedResultSet.Row row : executeInternal("SELECT peer, peer_port, tokens FROM system." + PEERS_V2)) {

    InetAddress address=row.getInetAddress("peer");

    Integer port=row.getInt("peer_port");

    InetAddressAndPort peer=InetAddressAndPort.getByAddressOverrideDefaults(address,port);

    if (row.has("tokens"))     tokenMap.putAll(peer,deserializeTokens(row.getSet("tokens",UTF8Type.instance)));

  }

  return tokenMap;

}

Location: SystemKeyspace.java

Content: 

private static TableMetadata.Builder parse(String table,String description,String cql){

  return CreateTableStatement.parse(format(cql,table),SchemaConstants.SYSTEM_KEYSPACE_NAME).id(TableId.forSystemTable(SchemaConstants.SYSTEM_KEYSPACE_NAME,table)).gcGraceSeconds(0).memtableFlushPeriod((int)TimeUnit.HOURS.toMillis(1)).comment(description);

}

Location: SystemKeyspace.java

Content: 

public static int paxosTtlSec(TableMetadata metadata){

  return Math.max(3 * 3600,metadata.params.gcGraceSeconds);

}

Location: SystemKeyspace.java

Content: 

public static void persistLocalMetadata(){

  String req="INSERT INTO system.%s (" + "key," + "cluster_name,"+ "release_version,"+ "cql_version,"+ "native_protocol_version,"+ "data_center,"+ "rack,"+ "partitioner,"+ "rpc_address,"+ "rpc_port,"+ "broadcast_address,"+ "broadcast_port,"+ "listen_address,"+ "listen_port"+ ") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  IEndpointSnitch snitch=DatabaseDescriptor.getEndpointSnitch();

  executeOnceInternal(format(req,LOCAL),LOCAL,DatabaseDescriptor.getClusterName(),FBUtilities.getReleaseVersionString(),QueryProcessor.CQL_VERSION.toString(),String.valueOf(ProtocolVersion.CURRENT.asInt()),snitch.getLocalDatacenter(),snitch.getLocalRack(),DatabaseDescriptor.getPartitioner().getClass().getName(),DatabaseDescriptor.getRpcAddress(),DatabaseDescriptor.getNativeTransportPort(),FBUtilities.getJustBroadcastAddress(),DatabaseDescriptor.getStoragePort(),FBUtilities.getJustLocalAddress(),DatabaseDescriptor.getStoragePort());

}

Location: SystemKeyspace.java

Content: 

/** 

 * Writes the current read rates for a given SSTable to system.sstable_activity

 */

public static void persistSSTableReadMeter(String keyspace,String table,int generation,RestorableMeter meter){

  String cql="INSERT INTO system.%s (keyspace_name, columnfamily_name, generation, rate_15m, rate_120m) VALUES (?, ?, ?, ?, ?) USING TTL 864000";

  executeInternal(format(cql,SSTABLE_ACTIVITY),keyspace,table,generation,meter.fifteenMinuteRate(),meter.twoHourRate());

}

Location: SystemKeyspace.java

Content: 

static ByteBuffer rangeToBytes(Range<Token> range){

  try (DataOutputBuffer out=new DataOutputBuffer()){

    Range.tokenSerializer.serialize(range,out,0);

    return out.buffer();

  }

 catch (  IOException e) {

    throw new IOError(e);

  }

}

Location: SystemKeyspace.java

Content: 

@VisibleForTesting public static Set<Range<Token>> rawRangesToRangeSet(Set<ByteBuffer> rawRanges,IPartitioner partitioner){

  return rawRanges.stream().map(buf -> byteBufferToRange(buf,partitioner)).collect(Collectors.toSet());

}

Location: SystemKeyspace.java

Content: 

private static Map<TableId,Pair<CommitLogPosition,Long>> readTruncationRecords(){

  UntypedResultSet rows=executeInternal(format("SELECT truncated_at FROM system.%s WHERE key = '%s'",LOCAL,LOCAL));

  Map<TableId,Pair<CommitLogPosition,Long>> records=new HashMap<>();

  if (!rows.isEmpty() && rows.one().has("truncated_at")) {

    Map<UUID,ByteBuffer> map=rows.one().getMap("truncated_at",UUIDType.instance,BytesType.instance);

    for (    Map.Entry<UUID,ByteBuffer> entry : map.entrySet())     records.put(TableId.fromUUID(entry.getKey()),truncationRecordFromBlob(entry.getValue()));

  }

  return records;

}

Location: SystemKeyspace.java

Content: 

public static void removePreparedStatement(MD5Digest key){

  executeInternal(format("DELETE FROM %s WHERE prepared_id = ?",PreparedStatements.toString()),key.byteBuffer());

}

Location: SystemKeyspace.java

Content: 

/** 

 * This method is used to remove information about truncation time for specified column family

 */

public static synchronized void removeTruncationRecord(TableId id){

  Pair<CommitLogPosition,Long> truncationRecord=getTruncationRecord(id);

  if (truncationRecord == null)   return;

  String req="DELETE truncated_at[?] from system.%s WHERE key = '%s'";

  executeInternal(format(req,LOCAL,LOCAL),id.asUUID());

  truncationRecords=null;

  forceBlockingFlush(LOCAL);

}

Location: SystemKeyspace.java

Content: 

public static void resetAvailableRanges(){

  ColumnFamilyStore availableRanges=Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(AVAILABLE_RANGES_V2);

  availableRanges.truncateBlocking();

}

Location: SystemKeyspace.java

Content: 

public static void resetPreparedStatements(){

  ColumnFamilyStore availableRanges=Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(PREPARED_STATEMENTS);

  availableRanges.truncateBlocking();

}

Location: SystemKeyspace.java

Content: 

public static void savePaxosCommit(Commit commit){

  String cql="UPDATE system.%s USING TIMESTAMP ? AND TTL ? SET proposal_ballot = null, proposal = null, most_recent_commit_at = ?, most_recent_commit = ?, most_recent_commit_version = ? WHERE row_key = ? AND cf_id = ?";

  executeInternal(format(cql,PAXOS),UUIDGen.microsTimestamp(commit.ballot),paxosTtlSec(commit.update.metadata()),commit.ballot,PartitionUpdate.toBytes(commit.update,MessagingService.current_version),MessagingService.current_version,commit.update.partitionKey().getKey(),commit.update.metadata().id.asUUID());

}

Location: SystemKeyspace.java

Content: 

public static void savePaxosPromise(Commit promise){

  String req="UPDATE system.%s USING TIMESTAMP ? AND TTL ? SET in_progress_ballot = ? WHERE row_key = ? AND cf_id = ?";

  executeInternal(format(req,PAXOS),UUIDGen.microsTimestamp(promise.ballot),paxosTtlSec(promise.update.metadata()),promise.ballot,promise.update.partitionKey().getKey(),promise.update.metadata().id.asUUID());

}

Location: SystemKeyspace.java

Content: 

public static void savePaxosProposal(Commit proposal){

  executeInternal(format("UPDATE system.%s USING TIMESTAMP ? AND TTL ? SET proposal_ballot = ?, proposal = ?, proposal_version = ? WHERE row_key = ? AND cf_id = ?",PAXOS),UUIDGen.microsTimestamp(proposal.ballot),paxosTtlSec(proposal.update.metadata()),proposal.ballot,PartitionUpdate.toBytes(proposal.update,MessagingService.current_version),MessagingService.current_version,proposal.update.partitionKey().getKey(),proposal.update.metadata().id.asUUID());

}

Location: SystemKeyspace.java

Content: 

public static synchronized void saveTruncationRecord(ColumnFamilyStore cfs,long truncatedAt,CommitLogPosition position){

  String req="UPDATE system.%s SET truncated_at = truncated_at + ? WHERE key = '%s'";

  executeInternal(format(req,LOCAL,LOCAL),truncationAsMapEntry(cfs,truncatedAt,position));

  truncationRecords=null;

  forceBlockingFlush(LOCAL);

}

Location: SystemKeyspace.java

Content: 

public static void setBootstrapState(BootstrapState state){

  if (getBootstrapState() == state)   return;

  String req="INSERT INTO system.%s (key, bootstrapped) VALUES ('%s', ?)";

  executeInternal(format(req,LOCAL,LOCAL),state.name());

  forceBlockingFlush(LOCAL);

}

Location: SystemKeyspace.java

Content: 

public static void setIndexBuilt(String keyspaceName,String indexName){

  String req="INSERT INTO %s.\"%s\" (table_name, index_name) VALUES (?, ?) IF NOT EXISTS;";

  executeInternal(String.format(req,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_INDEXES),keyspaceName,indexName);

  forceBlockingFlush(BUILT_INDEXES);

}

Location: SystemKeyspace.java

Content: 

public static void setIndexRemoved(String keyspaceName,String indexName){

  String req="DELETE FROM %s.\"%s\" WHERE table_name = ? AND index_name = ? IF EXISTS";

  executeInternal(String.format(req,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_INDEXES),keyspaceName,indexName);

  forceBlockingFlush(BUILT_INDEXES);

}

Location: SystemKeyspace.java

Content: 

/** 

 * Sets the local host ID explicitly.  Should only be called outside of SystemTable when replacing a node.

 */

public static UUID setLocalHostId(UUID hostId){

  String req="INSERT INTO system.%s (key, host_id) VALUES ('%s', ?)";

  executeInternal(format(req,LOCAL,LOCAL),hostId);

  return hostId;

}

Location: SystemKeyspace.java

Content: 

public static void setViewBuiltReplicated(String ksname,String viewName){

  setViewBuilt(ksname,viewName,true);

}

Location: SystemKeyspace.java

Content: 

public static void setViewBuilt(String keyspaceName,String viewName,boolean replicated){

  if (isViewBuilt(keyspaceName,viewName) && isViewStatusReplicated(keyspaceName,viewName) == replicated)   return;

  String req="INSERT INTO %s.\"%s\" (keyspace_name, view_name, status_replicated) VALUES (?, ?, ?)";

  executeInternal(format(req,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_VIEWS),keyspaceName,viewName,replicated);

  forceBlockingFlush(BUILT_VIEWS);

}

Location: SystemKeyspace.java

Content: 

public static void setViewRemoved(String keyspaceName,String viewName){

  String buildReq="DELETE FROM %s.%s WHERE keyspace_name = ? AND view_name = ?";

  executeInternal(String.format(buildReq,SchemaConstants.SYSTEM_KEYSPACE_NAME,VIEW_BUILDS_IN_PROGRESS),keyspaceName,viewName);

  String builtReq="DELETE FROM %s.\"%s\" WHERE keyspace_name = ? AND view_name = ? IF EXISTS";

  executeInternal(String.format(builtReq,SchemaConstants.SYSTEM_KEYSPACE_NAME,BUILT_VIEWS),keyspaceName,viewName);

  forceBlockingFlush(VIEW_BUILDS_IN_PROGRESS,BUILT_VIEWS);

}

Location: SystemKeyspace.java

Content: 

/** 

 * Compare the release version in the system.local table with the one included in the distro. If they don't match, snapshot all tables in the system and schema keyspaces. This is intended to be called at startup to create a backup of the system tables during an upgrade

 * @throws IOException

 */

public static void snapshotOnVersionChange() throws IOException {

  String previous=getPreviousVersionString();

  String next=FBUtilities.getReleaseVersionString();

  FBUtilities.setPreviousReleaseVersionString(previous);

  if (!previous.equals(NULL_VERSION.toString()) && !previous.equals(next)) {

    logger.info("Detected version upgrade from {} to {}, snapshotting system keyspaces",previous,next);

    String snapshotName=Keyspace.getTimestampedSnapshotName(format("upgrade-%s-%s",previous,next));

    for (    String keyspace : SchemaConstants.LOCAL_SYSTEM_KEYSPACE_NAMES)     Keyspace.open(keyspace).snapshot(snapshotName,null,false,null);

  }

}

Location: SystemKeyspace.java

Content: 

private SystemKeyspace(){

}

Location: SystemKeyspace.java

Content: 

private static Set<String> tokensAsSet(Collection<Token> tokens){

  if (tokens.isEmpty())   return Collections.emptySet();

  Token.TokenFactory factory=StorageService.instance.getTokenFactory();

  Set<String> s=new HashSet<>(tokens.size());

  for (  Token tk : tokens)   s.add(factory.toString(tk));

  return s;

}

Location: SystemKeyspace.java

Content: 

private static Map<UUID,ByteBuffer> truncationAsMapEntry(ColumnFamilyStore cfs,long truncatedAt,CommitLogPosition position){

  try (DataOutputBuffer out=DataOutputBuffer.scratchBuffer.get()){

    CommitLogPosition.serializer.serialize(position,out);

    out.writeLong(truncatedAt);

    return singletonMap(cfs.metadata.id.asUUID(),out.asNewBuffer());

  }

 catch (  IOException e) {

    throw new RuntimeException(e);

  }

}

Location: SystemKeyspace.java

Content: 

private static Pair<CommitLogPosition,Long> truncationRecordFromBlob(ByteBuffer bytes){

  try (RebufferingInputStream in=new DataInputBuffer(bytes,true)){

    return Pair.create(CommitLogPosition.serializer.deserialize(in),in.available() > 0 ? in.readLong() : Long.MIN_VALUE);

  }

 catch (  IOException e) {

    throw new RuntimeException(e);

  }

}

Location: SystemKeyspace.java

Content: 

public static synchronized void updateAvailableRanges(String keyspace,Collection<Range<Token>> completedFullRanges,Collection<Range<Token>> completedTransientRanges){

  String cql="UPDATE system.%s SET full_ranges = full_ranges + ?, transient_ranges = transient_ranges + ? WHERE keyspace_name = ?";

  executeInternal(format(cql,AVAILABLE_RANGES_V2),completedFullRanges.stream().map(SystemKeyspace::rangeToBytes).collect(Collectors.toSet()),completedTransientRanges.stream().map(SystemKeyspace::rangeToBytes).collect(Collectors.toSet()),keyspace);

}

Location: SystemKeyspace.java

Content: 

public static void updateCompactionHistory(String ksname,String cfname,long compactedAt,long bytesIn,long bytesOut,Map<Integer,Long> rowsMerged){

  if (ksname.equals("system") && cfname.equals(COMPACTION_HISTORY))   return;

  String req="INSERT INTO system.%s (id, keyspace_name, columnfamily_name, compacted_at, bytes_in, bytes_out, rows_merged) VALUES (?, ?, ?, ?, ?, ?, ?)";

  executeInternal(format(req,COMPACTION_HISTORY),UUIDGen.getTimeUUID(),ksname,cfname,ByteBufferUtil.bytes(compactedAt),bytesIn,bytesOut,rowsMerged);

}

Location: SystemKeyspace.java

Content: 

public static synchronized void updateHintsDropped(InetAddressAndPort ep,UUID timePeriod,int value){

  String req="UPDATE system.%s USING TTL 2592000 SET hints_dropped[ ? ] = ? WHERE peer = ?";

  executeInternal(String.format(req,LEGACY_PEER_EVENTS),timePeriod,value,ep.address);

  req="UPDATE system.%s USING TTL 2592000 SET hints_dropped[ ? ] = ? WHERE peer = ? AND peer_port = ?";

  executeInternal(String.format(req,PEER_EVENTS_V2),timePeriod,value,ep.address,ep.port);

}

Location: SystemKeyspace.java

Content: 

public static synchronized void updatePeerInfo(InetAddressAndPort ep,String columnName,Object value){

  if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))   return;

  String req="INSERT INTO system.%s (peer, %s) VALUES (?, ?)";

  executeInternal(String.format(req,LEGACY_PEERS,columnName),ep.address,value);

  if (columnName.equals("rpc_address")) {

    columnName="native_address";

  }

  req="INSERT INTO system.%s (peer, peer_port, %s) VALUES (?, ?, ?)";

  executeInternal(String.format(req,PEERS_V2,columnName),ep.address,ep.port,value);

}

Location: SystemKeyspace.java

Content: 

public static synchronized void updatePeerNativeAddress(InetAddressAndPort ep,InetAddressAndPort address){

  if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))   return;

  String req="INSERT INTO system.%s (peer, rpc_address) VALUES (?, ?)";

  executeInternal(String.format(req,LEGACY_PEERS),ep.address,address.address);

  req="INSERT INTO system.%s (peer, peer_port, native_address, native_port) VALUES (?, ?, ?, ?)";

  executeInternal(String.format(req,PEERS_V2),ep.address,ep.port,address.address,address.port);

}

Location: SystemKeyspace.java

Content: 

public static synchronized boolean updatePreferredIP(InetAddressAndPort ep,InetAddressAndPort preferred_ip){

  if (preferred_ip.equals(getPreferredIP(ep)))   return false;

  String req="INSERT INTO system.%s (peer, preferred_ip) VALUES (?, ?)";

  executeInternal(String.format(req,LEGACY_PEERS),ep.address,preferred_ip.address);

  req="INSERT INTO system.%s (peer, peer_port, preferred_ip, preferred_port) VALUES (?, ?, ?, ?)";

  executeInternal(String.format(req,PEERS_V2),ep.address,ep.port,preferred_ip.address,preferred_ip.port);

  forceBlockingFlush(LEGACY_PEERS,PEERS_V2);

  return true;

}

Location: SystemKeyspace.java

Content: 

public static synchronized void updateSchemaVersion(UUID version){

  String req="INSERT INTO system.%s (key, schema_version) VALUES ('%s', ?)";

  executeInternal(format(req,LOCAL,LOCAL),version);

}

Location: SystemKeyspace.java

Content: 

/** 

 * Writes the current partition count and size estimates into SIZE_ESTIMATES_CF

 */

public static void updateSizeEstimates(String keyspace,String table,Map<Range<Token>,Pair<Long,Long>> estimates){

  long timestamp=FBUtilities.timestampMicros();

  int nowInSec=FBUtilities.nowInSeconds();

  PartitionUpdate.Builder update=new PartitionUpdate.Builder(LegacySizeEstimates,UTF8Type.instance.decompose(keyspace),LegacySizeEstimates.regularAndStaticColumns(),estimates.size());

  update.add(new RangeTombstone(Slice.make(LegacySizeEstimates.comparator,table),new DeletionTime(timestamp - 1,nowInSec)));

  for (  Map.Entry<Range<Token>,Pair<Long,Long>> entry : estimates.entrySet()) {

    Range<Token> range=entry.getKey();

    Pair<Long,Long> values=entry.getValue();

    update.add(Rows.simpleBuilder(LegacySizeEstimates,table,range.left.toString(),range.right.toString()).timestamp(timestamp).add("partitions_count",values.left).add("mean_partition_size",values.right).build());

  }

  new Mutation(update.build()).apply();

}

Location: SystemKeyspace.java

Content: 

/** 

 * Writes the current partition count and size estimates into table_estimates

 */

public static void updateTableEstimates(String keyspace,String table,String type,Map<Range<Token>,Pair<Long,Long>> estimates){

  long timestamp=FBUtilities.timestampMicros();

  int nowInSec=FBUtilities.nowInSeconds();

  PartitionUpdate.Builder update=new PartitionUpdate.Builder(TableEstimates,UTF8Type.instance.decompose(keyspace),TableEstimates.regularAndStaticColumns(),estimates.size());

  update.add(new RangeTombstone(Slice.make(TableEstimates.comparator,table,type),new DeletionTime(timestamp - 1,nowInSec)));

  for (  Map.Entry<Range<Token>,Pair<Long,Long>> entry : estimates.entrySet()) {

    Range<Token> range=entry.getKey();

    Pair<Long,Long> values=entry.getValue();

    update.add(Rows.simpleBuilder(TableEstimates,table,type,range.left.toString(),range.right.toString()).timestamp(timestamp).add("partitions_count",values.left).add("mean_partition_size",values.right).build());

  }

  new Mutation(update.build()).apply();

}

Location: SystemKeyspace.java

Content: 

/** 

 * This method is used to update the System Keyspace with the new tokens for this node

 */

public static synchronized void updateTokens(Collection<Token> tokens){

  assert !tokens.isEmpty() : "removeEndpoint should be used instead";

  Collection<Token> savedTokens=getSavedTokens();

  if (tokens.containsAll(savedTokens) && tokens.size() == savedTokens.size())   return;

  String req="INSERT INTO system.%s (key, tokens) VALUES ('%s', ?)";

  executeInternal(format(req,LOCAL,LOCAL),tokensAsSet(tokens));

  forceBlockingFlush(LOCAL);

}

Location: SystemKeyspace.java

Content: 

/** 

 * Record tokens being used by another node

 */

public static synchronized void updateTokens(InetAddressAndPort ep,Collection<Token> tokens){

  if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))   return;

  String req="INSERT INTO system.%s (peer, tokens) VALUES (?, ?)";

  executeInternal(String.format(req,LEGACY_PEERS),ep.address,tokensAsSet(tokens));

  req="INSERT INTO system.%s (peer, peer_port, tokens) VALUES (?, ?, ?)";

  executeInternal(String.format(req,PEERS_V2),ep.address,ep.port,tokensAsSet(tokens));

}

Location: SystemKeyspace.java

Content: 

public static synchronized void updateTransferredRanges(StreamOperation streamOperation,InetAddressAndPort peer,String keyspace,Collection<Range<Token>> streamedRanges){

  String cql="UPDATE system.%s SET ranges = ranges + ? WHERE operation = ? AND peer = ? AND keyspace_name = ?";

  Set<ByteBuffer> rangesToUpdate=new HashSet<>(streamedRanges.size());

  for (  Range<Token> range : streamedRanges) {

    rangesToUpdate.add(rangeToBytes(range));

  }

  executeInternal(format(cql,LEGACY_TRANSFERRED_RANGES),rangesToUpdate,streamOperation.getDescription(),peer.address,keyspace);

  cql="UPDATE system.%s SET ranges = ranges + ? WHERE operation = ? AND peer = ? AND peer_port = ? AND keyspace_name = ?";

  executeInternal(String.format(cql,TRANSFERRED_RANGES_V2),rangesToUpdate,streamOperation.getDescription(),peer.address,peer.port,keyspace);

}

Location: SystemKeyspace.java

Content: 

public static void updateViewBuildStatus(String ksname,String viewName,Range<Token> range,Token lastToken,long keysBuilt){

  String req="INSERT INTO system.%s (keyspace_name, view_name, start_token, end_token, last_token, keys_built) VALUES (?, ?, ?, ?, ?, ?)";

  Token.TokenFactory factory=ViewBuildsInProgress.partitioner.getTokenFactory();

  executeInternal(format(req,VIEW_BUILDS_IN_PROGRESS),ksname,viewName,factory.toString(range.left),factory.toString(range.right),factory.toString(lastToken),keysBuilt);

}

Location: SystemKeyspace.java

Content: 

public static boolean wasDecommissioned(){

  return getBootstrapState() == BootstrapState.DECOMMISSIONED;

}

Location: SystemKeyspace.java

Content: 

public static void writePreparedStatement(String loggedKeyspace,MD5Digest key,String cql){

  executeInternal(format("INSERT INTO %s (logged_keyspace, prepared_id, query_string) VALUES (?, ?, ?)",PreparedStatements.toString()),loggedKeyspace,key.byteBuffer(),cql);

  logger.debug("stored prepared statement for logged keyspace '{}': '{}'",loggedKeyspace,cql);

}

